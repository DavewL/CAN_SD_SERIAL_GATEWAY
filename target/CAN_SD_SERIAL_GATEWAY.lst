
c:/Users/Dave/Documents/Particle/CAN_SD_SERIAL_GATEWAY/target/CAN_SD_SERIAL_GATEWAY.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00005e38  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000004  40024000  080a5e50  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         000000c0  20000300  080a5e54  00030300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000d34  200003c0  200003c0  000403c0  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a5f14  080a5f14  00035f14  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a5f3c  080a5f3c  00035f3c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   0019d7d6  00000000  00000000  00035f40  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0002460b  00000000  00000000  001d3716  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00021c29  00000000  00000000  001f7d21  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00002ee8  00000000  00000000  0021994a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00004888  00000000  00000000  0021c832  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00041cec  00000000  00000000  002210ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0005866a  00000000  00000000  00262da6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000a320e  00000000  00000000  002bb410  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000e5b0  00000000  00000000  0035e620  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	64 58 0a 08                                         dX..

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <module_user_pre_init+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <module_user_pre_init+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f004 ff66 	bl	80a4efe <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <module_user_pre_init+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <module_user_pre_init+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f004 ff6b 	bl	80a4f14 <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <module_user_pre_init+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000300 	.word	0x20000300
 80a0048:	080a5e54 	.word	0x080a5e54
 80a004c:	200003c0 	.word	0x200003c0
 80a0050:	200003c0 	.word	0x200003c0
 80a0054:	200010f4 	.word	0x200010f4
 80a0058:	200010f4 	.word	0x200010f4

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f003 fd35 	bl	80a3acc <module_user_init_hook>
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a5da4 	.word	0x080a5da4
 80a0084:	080a5e44 	.word	0x080a5e44

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 ba32 	b.w	80a04f0 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 fa4d 	bl	80a052c <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f003 bcdb 	b.w	80a3a50 <_post_loop>

080a009a <_Znwj>:
 80a009a:	f003 b995 	b.w	80a33c8 <malloc>

080a009e <_ZdlPv>:
 80a009e:	f003 b99b 	b.w	80a33d8 <free>

080a00a2 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00a2:	7800      	ldrb	r0, [r0, #0]
 80a00a4:	fab0 f080 	clz	r0, r0
 80a00a8:	0940      	lsrs	r0, r0, #5
 80a00aa:	4770      	bx	lr

080a00ac <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00ac:	2301      	movs	r3, #1
 80a00ae:	7003      	strb	r3, [r0, #0]
 80a00b0:	4770      	bx	lr
	...

080a00b4 <NVIC_Init>:
 80a00b4:	78c3      	ldrb	r3, [r0, #3]
 80a00b6:	b31b      	cbz	r3, 80a0100 <NVIC_Init+0x4c>
 80a00b8:	4b17      	ldr	r3, [pc, #92]	; (80a0118 <NVIC_Init+0x64>)
 80a00ba:	68da      	ldr	r2, [r3, #12]
 80a00bc:	7843      	ldrb	r3, [r0, #1]
 80a00be:	43d2      	mvns	r2, r2
 80a00c0:	f3c2 2202 	ubfx	r2, r2, #8, #3
 80a00c4:	f1c2 0104 	rsb	r1, r2, #4
 80a00c8:	b2c9      	uxtb	r1, r1
 80a00ca:	408b      	lsls	r3, r1
 80a00cc:	b2d9      	uxtb	r1, r3
 80a00ce:	230f      	movs	r3, #15
 80a00d0:	4113      	asrs	r3, r2
 80a00d2:	7882      	ldrb	r2, [r0, #2]
 80a00d4:	4013      	ands	r3, r2
 80a00d6:	7802      	ldrb	r2, [r0, #0]
 80a00d8:	430b      	orrs	r3, r1
 80a00da:	011b      	lsls	r3, r3, #4
 80a00dc:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 80a00e0:	b2db      	uxtb	r3, r3
 80a00e2:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 80a00e6:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
 80a00ea:	7803      	ldrb	r3, [r0, #0]
 80a00ec:	2201      	movs	r2, #1
 80a00ee:	0959      	lsrs	r1, r3, #5
 80a00f0:	f003 031f 	and.w	r3, r3, #31
 80a00f4:	fa02 f303 	lsl.w	r3, r2, r3
 80a00f8:	4a08      	ldr	r2, [pc, #32]	; (80a011c <NVIC_Init+0x68>)
 80a00fa:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 80a00fe:	4770      	bx	lr
 80a0100:	7803      	ldrb	r3, [r0, #0]
 80a0102:	2101      	movs	r1, #1
 80a0104:	095a      	lsrs	r2, r3, #5
 80a0106:	f003 031f 	and.w	r3, r3, #31
 80a010a:	4099      	lsls	r1, r3
 80a010c:	f102 0320 	add.w	r3, r2, #32
 80a0110:	4a02      	ldr	r2, [pc, #8]	; (80a011c <NVIC_Init+0x68>)
 80a0112:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 80a0116:	4770      	bx	lr
 80a0118:	e000ed00 	.word	0xe000ed00
 80a011c:	e000e100 	.word	0xe000e100

080a0120 <RCC_APB1PeriphClockCmd>:
 80a0120:	4b04      	ldr	r3, [pc, #16]	; (80a0134 <RCC_APB1PeriphClockCmd+0x14>)
 80a0122:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80a0124:	b109      	cbz	r1, 80a012a <RCC_APB1PeriphClockCmd+0xa>
 80a0126:	4310      	orrs	r0, r2
 80a0128:	e001      	b.n	80a012e <RCC_APB1PeriphClockCmd+0xe>
 80a012a:	ea22 0000 	bic.w	r0, r2, r0
 80a012e:	6418      	str	r0, [r3, #64]	; 0x40
 80a0130:	4770      	bx	lr
 80a0132:	bf00      	nop
 80a0134:	40023800 	.word	0x40023800

080a0138 <RCC_APB1PeriphResetCmd>:
 80a0138:	4b04      	ldr	r3, [pc, #16]	; (80a014c <RCC_APB1PeriphResetCmd+0x14>)
 80a013a:	6a1a      	ldr	r2, [r3, #32]
 80a013c:	b109      	cbz	r1, 80a0142 <RCC_APB1PeriphResetCmd+0xa>
 80a013e:	4310      	orrs	r0, r2
 80a0140:	e001      	b.n	80a0146 <RCC_APB1PeriphResetCmd+0xe>
 80a0142:	ea22 0000 	bic.w	r0, r2, r0
 80a0146:	6218      	str	r0, [r3, #32]
 80a0148:	4770      	bx	lr
 80a014a:	bf00      	nop
 80a014c:	40023800 	.word	0x40023800

080a0150 <RCC_APB2PeriphResetCmd>:
 80a0150:	4b04      	ldr	r3, [pc, #16]	; (80a0164 <RCC_APB2PeriphResetCmd+0x14>)
 80a0152:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80a0154:	b109      	cbz	r1, 80a015a <RCC_APB2PeriphResetCmd+0xa>
 80a0156:	4310      	orrs	r0, r2
 80a0158:	e001      	b.n	80a015e <RCC_APB2PeriphResetCmd+0xe>
 80a015a:	ea22 0000 	bic.w	r0, r2, r0
 80a015e:	6258      	str	r0, [r3, #36]	; 0x24
 80a0160:	4770      	bx	lr
 80a0162:	bf00      	nop
 80a0164:	40023800 	.word	0x40023800

080a0168 <TIM_DeInit>:
 80a0168:	b508      	push	{r3, lr}
 80a016a:	4b47      	ldr	r3, [pc, #284]	; (80a0288 <TIM_DeInit+0x120>)
 80a016c:	4298      	cmp	r0, r3
 80a016e:	d105      	bne.n	80a017c <TIM_DeInit+0x14>
 80a0170:	2001      	movs	r0, #1
 80a0172:	4601      	mov	r1, r0
 80a0174:	f7ff ffec 	bl	80a0150 <RCC_APB2PeriphResetCmd>
 80a0178:	2001      	movs	r0, #1
 80a017a:	e03d      	b.n	80a01f8 <TIM_DeInit+0x90>
 80a017c:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80a0180:	d105      	bne.n	80a018e <TIM_DeInit+0x26>
 80a0182:	2001      	movs	r0, #1
 80a0184:	4601      	mov	r1, r0
 80a0186:	f7ff ffd7 	bl	80a0138 <RCC_APB1PeriphResetCmd>
 80a018a:	2001      	movs	r0, #1
 80a018c:	e076      	b.n	80a027c <TIM_DeInit+0x114>
 80a018e:	4b3f      	ldr	r3, [pc, #252]	; (80a028c <TIM_DeInit+0x124>)
 80a0190:	4298      	cmp	r0, r3
 80a0192:	d105      	bne.n	80a01a0 <TIM_DeInit+0x38>
 80a0194:	2002      	movs	r0, #2
 80a0196:	2101      	movs	r1, #1
 80a0198:	f7ff ffce 	bl	80a0138 <RCC_APB1PeriphResetCmd>
 80a019c:	2002      	movs	r0, #2
 80a019e:	e06d      	b.n	80a027c <TIM_DeInit+0x114>
 80a01a0:	4b3b      	ldr	r3, [pc, #236]	; (80a0290 <TIM_DeInit+0x128>)
 80a01a2:	4298      	cmp	r0, r3
 80a01a4:	d105      	bne.n	80a01b2 <TIM_DeInit+0x4a>
 80a01a6:	2004      	movs	r0, #4
 80a01a8:	2101      	movs	r1, #1
 80a01aa:	f7ff ffc5 	bl	80a0138 <RCC_APB1PeriphResetCmd>
 80a01ae:	2004      	movs	r0, #4
 80a01b0:	e064      	b.n	80a027c <TIM_DeInit+0x114>
 80a01b2:	4b38      	ldr	r3, [pc, #224]	; (80a0294 <TIM_DeInit+0x12c>)
 80a01b4:	4298      	cmp	r0, r3
 80a01b6:	d105      	bne.n	80a01c4 <TIM_DeInit+0x5c>
 80a01b8:	2008      	movs	r0, #8
 80a01ba:	2101      	movs	r1, #1
 80a01bc:	f7ff ffbc 	bl	80a0138 <RCC_APB1PeriphResetCmd>
 80a01c0:	2008      	movs	r0, #8
 80a01c2:	e05b      	b.n	80a027c <TIM_DeInit+0x114>
 80a01c4:	4b34      	ldr	r3, [pc, #208]	; (80a0298 <TIM_DeInit+0x130>)
 80a01c6:	4298      	cmp	r0, r3
 80a01c8:	d105      	bne.n	80a01d6 <TIM_DeInit+0x6e>
 80a01ca:	2010      	movs	r0, #16
 80a01cc:	2101      	movs	r1, #1
 80a01ce:	f7ff ffb3 	bl	80a0138 <RCC_APB1PeriphResetCmd>
 80a01d2:	2010      	movs	r0, #16
 80a01d4:	e052      	b.n	80a027c <TIM_DeInit+0x114>
 80a01d6:	4b31      	ldr	r3, [pc, #196]	; (80a029c <TIM_DeInit+0x134>)
 80a01d8:	4298      	cmp	r0, r3
 80a01da:	d105      	bne.n	80a01e8 <TIM_DeInit+0x80>
 80a01dc:	2020      	movs	r0, #32
 80a01de:	2101      	movs	r1, #1
 80a01e0:	f7ff ffaa 	bl	80a0138 <RCC_APB1PeriphResetCmd>
 80a01e4:	2020      	movs	r0, #32
 80a01e6:	e049      	b.n	80a027c <TIM_DeInit+0x114>
 80a01e8:	4b2d      	ldr	r3, [pc, #180]	; (80a02a0 <TIM_DeInit+0x138>)
 80a01ea:	4298      	cmp	r0, r3
 80a01ec:	d109      	bne.n	80a0202 <TIM_DeInit+0x9a>
 80a01ee:	2002      	movs	r0, #2
 80a01f0:	2101      	movs	r1, #1
 80a01f2:	f7ff ffad 	bl	80a0150 <RCC_APB2PeriphResetCmd>
 80a01f6:	2002      	movs	r0, #2
 80a01f8:	2100      	movs	r1, #0
 80a01fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80a01fe:	f7ff bfa7 	b.w	80a0150 <RCC_APB2PeriphResetCmd>
 80a0202:	4b28      	ldr	r3, [pc, #160]	; (80a02a4 <TIM_DeInit+0x13c>)
 80a0204:	4298      	cmp	r0, r3
 80a0206:	d107      	bne.n	80a0218 <TIM_DeInit+0xb0>
 80a0208:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80a020c:	2101      	movs	r1, #1
 80a020e:	f7ff ff9f 	bl	80a0150 <RCC_APB2PeriphResetCmd>
 80a0212:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80a0216:	e7ef      	b.n	80a01f8 <TIM_DeInit+0x90>
 80a0218:	4b23      	ldr	r3, [pc, #140]	; (80a02a8 <TIM_DeInit+0x140>)
 80a021a:	4298      	cmp	r0, r3
 80a021c:	d107      	bne.n	80a022e <TIM_DeInit+0xc6>
 80a021e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80a0222:	2101      	movs	r1, #1
 80a0224:	f7ff ff94 	bl	80a0150 <RCC_APB2PeriphResetCmd>
 80a0228:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80a022c:	e7e4      	b.n	80a01f8 <TIM_DeInit+0x90>
 80a022e:	4b1f      	ldr	r3, [pc, #124]	; (80a02ac <TIM_DeInit+0x144>)
 80a0230:	4298      	cmp	r0, r3
 80a0232:	d107      	bne.n	80a0244 <TIM_DeInit+0xdc>
 80a0234:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80a0238:	2101      	movs	r1, #1
 80a023a:	f7ff ff89 	bl	80a0150 <RCC_APB2PeriphResetCmd>
 80a023e:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80a0242:	e7d9      	b.n	80a01f8 <TIM_DeInit+0x90>
 80a0244:	4b1a      	ldr	r3, [pc, #104]	; (80a02b0 <TIM_DeInit+0x148>)
 80a0246:	4298      	cmp	r0, r3
 80a0248:	d105      	bne.n	80a0256 <TIM_DeInit+0xee>
 80a024a:	2040      	movs	r0, #64	; 0x40
 80a024c:	2101      	movs	r1, #1
 80a024e:	f7ff ff73 	bl	80a0138 <RCC_APB1PeriphResetCmd>
 80a0252:	2040      	movs	r0, #64	; 0x40
 80a0254:	e012      	b.n	80a027c <TIM_DeInit+0x114>
 80a0256:	4b17      	ldr	r3, [pc, #92]	; (80a02b4 <TIM_DeInit+0x14c>)
 80a0258:	4298      	cmp	r0, r3
 80a025a:	d105      	bne.n	80a0268 <TIM_DeInit+0x100>
 80a025c:	2080      	movs	r0, #128	; 0x80
 80a025e:	2101      	movs	r1, #1
 80a0260:	f7ff ff6a 	bl	80a0138 <RCC_APB1PeriphResetCmd>
 80a0264:	2080      	movs	r0, #128	; 0x80
 80a0266:	e009      	b.n	80a027c <TIM_DeInit+0x114>
 80a0268:	4b13      	ldr	r3, [pc, #76]	; (80a02b8 <TIM_DeInit+0x150>)
 80a026a:	4298      	cmp	r0, r3
 80a026c:	d10b      	bne.n	80a0286 <TIM_DeInit+0x11e>
 80a026e:	f44f 7080 	mov.w	r0, #256	; 0x100
 80a0272:	2101      	movs	r1, #1
 80a0274:	f7ff ff60 	bl	80a0138 <RCC_APB1PeriphResetCmd>
 80a0278:	f44f 7080 	mov.w	r0, #256	; 0x100
 80a027c:	2100      	movs	r1, #0
 80a027e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80a0282:	f7ff bf59 	b.w	80a0138 <RCC_APB1PeriphResetCmd>
 80a0286:	bd08      	pop	{r3, pc}
 80a0288:	40010000 	.word	0x40010000
 80a028c:	40000400 	.word	0x40000400
 80a0290:	40000800 	.word	0x40000800
 80a0294:	40000c00 	.word	0x40000c00
 80a0298:	40001000 	.word	0x40001000
 80a029c:	40001400 	.word	0x40001400
 80a02a0:	40010400 	.word	0x40010400
 80a02a4:	40014000 	.word	0x40014000
 80a02a8:	40014400 	.word	0x40014400
 80a02ac:	40014800 	.word	0x40014800
 80a02b0:	40001800 	.word	0x40001800
 80a02b4:	40001c00 	.word	0x40001c00
 80a02b8:	40002000 	.word	0x40002000

080a02bc <TIM_TimeBaseInit>:
 80a02bc:	4a1c      	ldr	r2, [pc, #112]	; (80a0330 <TIM_TimeBaseInit+0x74>)
 80a02be:	8803      	ldrh	r3, [r0, #0]
 80a02c0:	4290      	cmp	r0, r2
 80a02c2:	b29b      	uxth	r3, r3
 80a02c4:	d012      	beq.n	80a02ec <TIM_TimeBaseInit+0x30>
 80a02c6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80a02ca:	4290      	cmp	r0, r2
 80a02cc:	d00e      	beq.n	80a02ec <TIM_TimeBaseInit+0x30>
 80a02ce:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80a02d2:	d00b      	beq.n	80a02ec <TIM_TimeBaseInit+0x30>
 80a02d4:	f5a2 3280 	sub.w	r2, r2, #65536	; 0x10000
 80a02d8:	4290      	cmp	r0, r2
 80a02da:	d007      	beq.n	80a02ec <TIM_TimeBaseInit+0x30>
 80a02dc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80a02e0:	4290      	cmp	r0, r2
 80a02e2:	d003      	beq.n	80a02ec <TIM_TimeBaseInit+0x30>
 80a02e4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80a02e8:	4290      	cmp	r0, r2
 80a02ea:	d103      	bne.n	80a02f4 <TIM_TimeBaseInit+0x38>
 80a02ec:	884a      	ldrh	r2, [r1, #2]
 80a02ee:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80a02f2:	4313      	orrs	r3, r2
 80a02f4:	4a0f      	ldr	r2, [pc, #60]	; (80a0334 <TIM_TimeBaseInit+0x78>)
 80a02f6:	4290      	cmp	r0, r2
 80a02f8:	d008      	beq.n	80a030c <TIM_TimeBaseInit+0x50>
 80a02fa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80a02fe:	4290      	cmp	r0, r2
 80a0300:	bf1f      	itttt	ne
 80a0302:	f423 7340 	bicne.w	r3, r3, #768	; 0x300
 80a0306:	890a      	ldrhne	r2, [r1, #8]
 80a0308:	b29b      	uxthne	r3, r3
 80a030a:	4313      	orrne	r3, r2
 80a030c:	8003      	strh	r3, [r0, #0]
 80a030e:	684b      	ldr	r3, [r1, #4]
 80a0310:	62c3      	str	r3, [r0, #44]	; 0x2c
 80a0312:	880b      	ldrh	r3, [r1, #0]
 80a0314:	8503      	strh	r3, [r0, #40]	; 0x28
 80a0316:	4b06      	ldr	r3, [pc, #24]	; (80a0330 <TIM_TimeBaseInit+0x74>)
 80a0318:	4298      	cmp	r0, r3
 80a031a:	d003      	beq.n	80a0324 <TIM_TimeBaseInit+0x68>
 80a031c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80a0320:	4298      	cmp	r0, r3
 80a0322:	d101      	bne.n	80a0328 <TIM_TimeBaseInit+0x6c>
 80a0324:	7a8b      	ldrb	r3, [r1, #10]
 80a0326:	8603      	strh	r3, [r0, #48]	; 0x30
 80a0328:	2301      	movs	r3, #1
 80a032a:	8283      	strh	r3, [r0, #20]
 80a032c:	4770      	bx	lr
 80a032e:	bf00      	nop
 80a0330:	40010000 	.word	0x40010000
 80a0334:	40001000 	.word	0x40001000

080a0338 <TIM_Cmd>:
 80a0338:	8803      	ldrh	r3, [r0, #0]
 80a033a:	b119      	cbz	r1, 80a0344 <TIM_Cmd+0xc>
 80a033c:	b29b      	uxth	r3, r3
 80a033e:	f043 0301 	orr.w	r3, r3, #1
 80a0342:	e003      	b.n	80a034c <TIM_Cmd+0x14>
 80a0344:	f023 0301 	bic.w	r3, r3, #1
 80a0348:	041b      	lsls	r3, r3, #16
 80a034a:	0c1b      	lsrs	r3, r3, #16
 80a034c:	8003      	strh	r3, [r0, #0]
 80a034e:	4770      	bx	lr

080a0350 <TIM_ITConfig>:
 80a0350:	8983      	ldrh	r3, [r0, #12]
 80a0352:	b29b      	uxth	r3, r3
 80a0354:	b10a      	cbz	r2, 80a035a <TIM_ITConfig+0xa>
 80a0356:	4319      	orrs	r1, r3
 80a0358:	e001      	b.n	80a035e <TIM_ITConfig+0xe>
 80a035a:	ea23 0101 	bic.w	r1, r3, r1
 80a035e:	8181      	strh	r1, [r0, #12]
 80a0360:	4770      	bx	lr

080a0362 <TIM_GetITStatus>:
 80a0362:	8a03      	ldrh	r3, [r0, #16]
 80a0364:	8982      	ldrh	r2, [r0, #12]
 80a0366:	ea11 0003 	ands.w	r0, r1, r3
 80a036a:	b292      	uxth	r2, r2
 80a036c:	d003      	beq.n	80a0376 <TIM_GetITStatus+0x14>
 80a036e:	4211      	tst	r1, r2
 80a0370:	bf14      	ite	ne
 80a0372:	2001      	movne	r0, #1
 80a0374:	2000      	moveq	r0, #0
 80a0376:	4770      	bx	lr

080a0378 <TIM_ClearITPendingBit>:
 80a0378:	43c9      	mvns	r1, r1
 80a037a:	b289      	uxth	r1, r1
 80a037c:	8201      	strh	r1, [r0, #16]
 80a037e:	4770      	bx	lr

080a0380 <_Z17ResetGatewayTimer15GATE_CAN_TIMERS>:
    carloop.can().transmit(message);
}

void ResetGatewayTimer(GATE_CAN_TIMERS eGateCanTimer)
{
  if (eGateCanTimer < NUM_GATE_CAN_TIMERS)
 80a0380:	b920      	cbnz	r0, 80a038c <_Z17ResetGatewayTimer15GATE_CAN_TIMERS+0xc>
  {
    SetTimerWithMilliseconds(&scastGateCanTimers[eGateCanTimer], scawGateCanTimers[eGateCanTimer]);
 80a0382:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80a0386:	4802      	ldr	r0, [pc, #8]	; (80a0390 <_Z17ResetGatewayTimer15GATE_CAN_TIMERS+0x10>)
 80a0388:	f000 bcfa 	b.w	80a0d80 <_Z24SetTimerWithMillisecondsP16TICK_TIMER_S_TAGj>
 80a038c:	4770      	bx	lr
 80a038e:	bf00      	nop
 80a0390:	200003c4 	.word	0x200003c4

080a0394 <_Z21receiveGatewayMesages10CANMessage>:
   ResetGatewayTimer((GATE_CAN_TIMERS)wIndex);
  }
  //battType = VALENCE_REV3;
}

void receiveGatewayMesages(CANMessage message){
 80a0394:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80a0396:	f10d 0e10 	add.w	lr, sp, #16
 80a039a:	e90e 000f 	stmdb	lr, {r0, r1, r2, r3}
 80a039e:	9b00      	ldr	r3, [sp, #0]
    if (message.id == TEST_CONFIG_ID){ //-----------------------------------------
 80a03a0:	2b19      	cmp	r3, #25
 80a03a2:	d10b      	bne.n	80a03bc <_Z21receiveGatewayMesages10CANMessage+0x28>
        ResetGatewayTimer(CT_GATE_CAN_LOST_DELAY);
 80a03a4:	2000      	movs	r0, #0
 80a03a6:	f7ff ffeb 	bl	80a0380 <_Z17ResetGatewayTimer15GATE_CAN_TIMERS>
        testRoutineSource = message.data[0];
 80a03aa:	f89d 2008 	ldrb.w	r2, [sp, #8]
 80a03ae:	4b09      	ldr	r3, [pc, #36]	; (80a03d4 <_Z21receiveGatewayMesages10CANMessage+0x40>)
 80a03b0:	601a      	str	r2, [r3, #0]
        testState = message.data[1];
 80a03b2:	f89d 2009 	ldrb.w	r2, [sp, #9]
 80a03b6:	4b08      	ldr	r3, [pc, #32]	; (80a03d8 <_Z21receiveGatewayMesages10CANMessage+0x44>)
 80a03b8:	601a      	str	r2, [r3, #0]
 80a03ba:	e008      	b.n	80a03ce <_Z21receiveGatewayMesages10CANMessage+0x3a>
    }
    if (message.id == BATT_STATS_ID){
 80a03bc:	3b20      	subs	r3, #32
 80a03be:	2b01      	cmp	r3, #1
 80a03c0:	d805      	bhi.n	80a03ce <_Z21receiveGatewayMesages10CANMessage+0x3a>
        ResetGatewayTimer(CT_GATE_CAN_LOST_DELAY);
 80a03c2:	2000      	movs	r0, #0
    }
    if (message.id == EL_LOAD_CMD_ID){
        ResetGatewayTimer(CT_GATE_CAN_LOST_DELAY);
    }

}
 80a03c4:	b005      	add	sp, #20
 80a03c6:	f85d eb04 	ldr.w	lr, [sp], #4
        ResetGatewayTimer(CT_GATE_CAN_LOST_DELAY);
        testRoutineSource = message.data[0];
        testState = message.data[1];
    }
    if (message.id == BATT_STATS_ID){
        ResetGatewayTimer(CT_GATE_CAN_LOST_DELAY);
 80a03ca:	f7ff bfd9 	b.w	80a0380 <_Z17ResetGatewayTimer15GATE_CAN_TIMERS>
    }
    if (message.id == EL_LOAD_CMD_ID){
        ResetGatewayTimer(CT_GATE_CAN_LOST_DELAY);
    }

}
 80a03ce:	b005      	add	sp, #20
 80a03d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80a03d4:	200009e8 	.word	0x200009e8
 80a03d8:	200009e4 	.word	0x200009e4

080a03dc <_GLOBAL__sub_I__Z19initGatewayMessagesv>:
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a03dc:	f002 bdce 	b.w	80a2f7c <HAL_Pin_Map>

080a03e0 <_Z11fiveMsTimerv>:
        }
    }
}

void fiveMsTimer(){
    scheduler5msExpired = 1;
 80a03e0:	4b01      	ldr	r3, [pc, #4]	; (80a03e8 <_Z11fiveMsTimerv+0x8>)
 80a03e2:	2201      	movs	r2, #1
 80a03e4:	701a      	strb	r2, [r3, #0]
 80a03e6:	4770      	bx	lr
 80a03e8:	20000438 	.word	0x20000438

080a03ec <_ZNSt17_Function_handlerIFvvEPS0_E9_M_invokeERKSt9_Any_data>:

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
	(*_Base::_M_get_pointer(__functor))(
 80a03ec:	6803      	ldr	r3, [r0, #0]
 80a03ee:	4718      	bx	r3

080a03f0 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a03f0:	2a01      	cmp	r2, #1
 80a03f2:	d002      	beq.n	80a03fa <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0xa>
 80a03f4:	2a02      	cmp	r2, #2
 80a03f6:	d002      	beq.n	80a03fe <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0xe>
 80a03f8:	e004      	b.n	80a0404 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a03fa:	6001      	str	r1, [r0, #0]
	      break;
 80a03fc:	e002      	b.n	80a0404 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
	// Clone a location-invariant function object that fits within
	// an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
	{
	  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 80a03fe:	680b      	ldr	r3, [r1, #0]
 80a0400:	b100      	cbz	r0, 80a0404 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
 80a0402:	6003      	str	r3, [r0, #0]
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a0404:	2000      	movs	r0, #0
 80a0406:	4770      	bx	lr

080a0408 <_ZN13IntervalTimerD1Ev>:
	}
#endif

    }

    ~IntervalTimer() { end(); }
 80a0408:	b510      	push	{r4, lr}
 80a040a:	4604      	mov	r4, r0
 80a040c:	f002 fdaa 	bl	80a2f64 <_ZN13IntervalTimer3endEv>
 80a0410:	4620      	mov	r0, r4
 80a0412:	bd10      	pop	{r4, pc}

080a0414 <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0414:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a0416:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0418:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a041a:	b113      	cbz	r3, 80a0422 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a041c:	2203      	movs	r2, #3
 80a041e:	4601      	mov	r1, r0
 80a0420:	4798      	blx	r3
    }
 80a0422:	4620      	mov	r0, r4
 80a0424:	bd10      	pop	{r4, pc}
	...

080a0428 <_ZN13IntervalTimerC1Ev>:
 	ISRcallback myISRcallback;

    bool beginCycles(void (*isrCallback)(), intPeriod Period, bool scale, TIMid id);

  public:
    IntervalTimer() {
 80a0428:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80a042a:	223b      	movs	r2, #59	; 0x3b
 80a042c:	8042      	strh	r2, [r0, #2]
 80a042e:	f247 522f 	movw	r2, #29999	; 0x752f
 80a0432:	8082      	strh	r2, [r0, #4]
 80a0434:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80a0438:	80c2      	strh	r2, [r0, #6]
	status = TIMER_OFF;

	for (int i=0; i < NUM_SIT; i++)		//Set all SIT slots to unused
		SIT_used[i] = false;
 80a043a:	4a25      	ldr	r2, [pc, #148]	; (80a04d0 <_ZN13IntervalTimerC1Ev+0xa8>)
 	ISRcallback myISRcallback;

    bool beginCycles(void (*isrCallback)(), intPeriod Period, bool scale, TIMid id);

  public:
    IntervalTimer() {
 80a043c:	2300      	movs	r3, #0
 80a043e:	7003      	strb	r3, [r0, #0]
	status = TIMER_OFF;
 80a0440:	7203      	strb	r3, [r0, #8]

	for (int i=0; i < NUM_SIT; i++)		//Set all SIT slots to unused
		SIT_used[i] = false;
 80a0442:	7013      	strb	r3, [r2, #0]
 80a0444:	7053      	strb	r3, [r2, #1]
 80a0446:	7093      	strb	r3, [r2, #2]
 80a0448:	70d3      	strb	r3, [r2, #3]
 80a044a:	7113      	strb	r3, [r2, #4]
		if (!attachSystemInterrupt(SysInterrupt_TIM2_Update, Wiring_TIM2_Interrupt_Handler_override)) ;	//error
		if (!attachSystemInterrupt(SysInterrupt_TIM3_Update, Wiring_TIM3_Interrupt_Handler_override)) ;	//error
		if (!attachSystemInterrupt(SysInterrupt_TIM4_Update, Wiring_TIM4_Interrupt_Handler_override)) ;	//error
	}
#elif defined(STM32F2XX) && defined(PLATFORM_ID)	//Photon
	if (!sysIntSetupDone) {
 80a044c:	7803      	ldrb	r3, [r0, #0]
 	ISRcallback myISRcallback;

    bool beginCycles(void (*isrCallback)(), intPeriod Period, bool scale, TIMid id);

  public:
    IntervalTimer() {
 80a044e:	4604      	mov	r4, r0
		if (!attachSystemInterrupt(SysInterrupt_TIM2_Update, Wiring_TIM2_Interrupt_Handler_override)) ;	//error
		if (!attachSystemInterrupt(SysInterrupt_TIM3_Update, Wiring_TIM3_Interrupt_Handler_override)) ;	//error
		if (!attachSystemInterrupt(SysInterrupt_TIM4_Update, Wiring_TIM4_Interrupt_Handler_override)) ;	//error
	}
#elif defined(STM32F2XX) && defined(PLATFORM_ID)	//Photon
	if (!sysIntSetupDone) {
 80a0450:	2b00      	cmp	r3, #0
 80a0452:	d13a      	bne.n	80a04ca <_ZN13IntervalTimerC1Ev+0xa2>
		sysIntSetupDone = true;
 80a0454:	2301      	movs	r3, #1
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a0456:	4e1f      	ldr	r6, [pc, #124]	; (80a04d4 <_ZN13IntervalTimerC1Ev+0xac>)
	    _M_manager = &_My_handler::_M_manager;
 80a0458:	4d1f      	ldr	r5, [pc, #124]	; (80a04d8 <_ZN13IntervalTimerC1Ev+0xb0>)
 80a045a:	7003      	strb	r3, [r0, #0]
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a045c:	4b1f      	ldr	r3, [pc, #124]	; (80a04dc <_ZN13IntervalTimerC1Ev+0xb4>)
		if (!attachSystemInterrupt(SysInterrupt_TIM3_Update, Wiring_TIM3_Interrupt_Handler_override)) ;	//error
 80a045e:	4669      	mov	r1, sp
 80a0460:	2013      	movs	r0, #19
 80a0462:	9300      	str	r3, [sp, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a0464:	9603      	str	r6, [sp, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a0466:	9502      	str	r5, [sp, #8]
 80a0468:	f003 fc68 	bl	80a3d3c <_Z21attachSystemInterrupt9hal_irq_tSt8functionIFvvEE>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a046c:	4668      	mov	r0, sp
 80a046e:	f7ff ffd1 	bl	80a0414 <_ZNSt14_Function_baseD1Ev>
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a0472:	4b1b      	ldr	r3, [pc, #108]	; (80a04e0 <_ZN13IntervalTimerC1Ev+0xb8>)
		if (!attachSystemInterrupt(SysInterrupt_TIM4_Update, Wiring_TIM4_Interrupt_Handler_override)) ;	//error
 80a0474:	4669      	mov	r1, sp
 80a0476:	201a      	movs	r0, #26
 80a0478:	9300      	str	r3, [sp, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a047a:	9603      	str	r6, [sp, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a047c:	9502      	str	r5, [sp, #8]
 80a047e:	f003 fc5d 	bl	80a3d3c <_Z21attachSystemInterrupt9hal_irq_tSt8functionIFvvEE>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a0482:	4668      	mov	r0, sp
 80a0484:	f7ff ffc6 	bl	80a0414 <_ZNSt14_Function_baseD1Ev>
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a0488:	4b16      	ldr	r3, [pc, #88]	; (80a04e4 <_ZN13IntervalTimerC1Ev+0xbc>)
		if (!attachSystemInterrupt(SysInterrupt_TIM5_Update, Wiring_TIM5_Interrupt_Handler_override)) ;	//error
 80a048a:	4669      	mov	r1, sp
 80a048c:	2021      	movs	r0, #33	; 0x21
 80a048e:	9300      	str	r3, [sp, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a0490:	9603      	str	r6, [sp, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a0492:	9502      	str	r5, [sp, #8]
 80a0494:	f003 fc52 	bl	80a3d3c <_Z21attachSystemInterrupt9hal_irq_tSt8functionIFvvEE>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a0498:	4668      	mov	r0, sp
 80a049a:	f7ff ffbb 	bl	80a0414 <_ZNSt14_Function_baseD1Ev>
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a049e:	4b12      	ldr	r3, [pc, #72]	; (80a04e8 <_ZN13IntervalTimerC1Ev+0xc0>)
		if (!attachSystemInterrupt(SysInterrupt_TIM6_Update, Wiring_TIM6_Interrupt_Handler_override));	//error
 80a04a0:	4669      	mov	r1, sp
 80a04a2:	2024      	movs	r0, #36	; 0x24
 80a04a4:	9300      	str	r3, [sp, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a04a6:	9603      	str	r6, [sp, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a04a8:	9502      	str	r5, [sp, #8]
 80a04aa:	f003 fc47 	bl	80a3d3c <_Z21attachSystemInterrupt9hal_irq_tSt8functionIFvvEE>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a04ae:	4668      	mov	r0, sp
 80a04b0:	f7ff ffb0 	bl	80a0414 <_ZNSt14_Function_baseD1Ev>
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a04b4:	4b0d      	ldr	r3, [pc, #52]	; (80a04ec <_ZN13IntervalTimerC1Ev+0xc4>)
		if (!attachSystemInterrupt(SysInterrupt_TIM7_Update, Wiring_TIM7_Interrupt_Handler_override));	//error
 80a04b6:	4669      	mov	r1, sp
 80a04b8:	2026      	movs	r0, #38	; 0x26
 80a04ba:	9300      	str	r3, [sp, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a04bc:	9603      	str	r6, [sp, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a04be:	9502      	str	r5, [sp, #8]
 80a04c0:	f003 fc3c 	bl	80a3d3c <_Z21attachSystemInterrupt9hal_irq_tSt8functionIFvvEE>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a04c4:	4668      	mov	r0, sp
 80a04c6:	f7ff ffa5 	bl	80a0414 <_ZNSt14_Function_baseD1Ev>
	}
#endif

    }
 80a04ca:	4620      	mov	r0, r4
 80a04cc:	b004      	add	sp, #16
 80a04ce:	bd70      	pop	{r4, r5, r6, pc}
 80a04d0:	20000b18 	.word	0x20000b18
 80a04d4:	080a03ed 	.word	0x080a03ed
 80a04d8:	080a03f1 	.word	0x080a03f1
 80a04dc:	080a2c7d 	.word	0x080a2c7d
 80a04e0:	080a2ca5 	.word	0x080a2ca5
 80a04e4:	080a2ccd 	.word	0x080a2ccd
 80a04e8:	080a2cf5 	.word	0x080a2cf5
 80a04ec:	080a2d1d 	.word	0x080a2d1d

080a04f0 <setup>:
#define OS_160MS_MASK   0x0010
#define OS_320MS_MASK   0x0020
#define OS_640MS_MASK   0x0040
#define OS_1280MS_MASK  0x0080

void setup() {
 80a04f0:	b507      	push	{r0, r1, r2, lr}

    Serial.begin(9600);
 80a04f2:	f003 fba9 	bl	80a3c48 <_Z16_fetch_usbserialv>
 80a04f6:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a04fa:	f003 fb8b 	bl	80a3c14 <_ZN9USBSerial5beginEl>

    ~IntervalTimer() { end(); }

    bool begin(void (*isrCallback)(), intPeriod Period, bool scale) {
		if (Period < 10 || Period > MAX_PERIOD)
 80a04fe:	f241 3386 	movw	r3, #4998	; 0x1386
 80a0502:	4808      	ldr	r0, [pc, #32]	; (80a0524 <setup+0x34>)
 80a0504:	88c2      	ldrh	r2, [r0, #6]
 80a0506:	429a      	cmp	r2, r3
 80a0508:	d907      	bls.n	80a051a <setup+0x2a>
			return false;
		return beginCycles(isrCallback, Period, scale, AUTO);
 80a050a:	23ff      	movs	r3, #255	; 0xff
 80a050c:	9300      	str	r3, [sp, #0]
 80a050e:	f241 3287 	movw	r2, #4999	; 0x1387
 80a0512:	2300      	movs	r3, #0
 80a0514:	4904      	ldr	r1, [pc, #16]	; (80a0528 <setup+0x38>)
 80a0516:	f002 fcef 	bl	80a2ef8 <_ZN13IntervalTimer11beginCyclesEPFvvEmb5TIMid>
    //delay(1000);
    myTimer.begin(fiveMsTimer, 4999, uSec);
    TasksInit();
}
 80a051a:	b003      	add	sp, #12
 80a051c:	f85d eb04 	ldr.w	lr, [sp], #4
void setup() {

    Serial.begin(9600);
    //delay(1000);
    myTimer.begin(fiveMsTimer, 4999, uSec);
    TasksInit();
 80a0520:	f000 baf2 	b.w	80a0b08 <_Z9TasksInitv>
 80a0524:	200003dc 	.word	0x200003dc
 80a0528:	080a03e1 	.word	0x080a03e1

080a052c <loop>:
}

void loop() {
 80a052c:	b538      	push	{r3, r4, r5, lr}
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a052e:	f002 fdad 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
    unsigned long thisTime = millis();
    static unsigned long tempTime = thisTime;
 80a0532:	4d62      	ldr	r5, [pc, #392]	; (80a06bc <loop+0x190>)
 80a0534:	4604      	mov	r4, r0
 80a0536:	682b      	ldr	r3, [r5, #0]
 80a0538:	07db      	lsls	r3, r3, #31
 80a053a:	d406      	bmi.n	80a054a <loop+0x1e>
 80a053c:	4628      	mov	r0, r5
 80a053e:	f7ff fdb0 	bl	80a00a2 <__cxa_guard_acquire>
 80a0542:	b110      	cbz	r0, 80a054a <loop+0x1e>
 80a0544:	4628      	mov	r0, r5
 80a0546:	f7ff fdb1 	bl	80a00ac <__cxa_guard_release>
    static unsigned long prev10msTime = thisTime;
 80a054a:	4d5d      	ldr	r5, [pc, #372]	; (80a06c0 <loop+0x194>)
 80a054c:	682b      	ldr	r3, [r5, #0]
 80a054e:	07d8      	lsls	r0, r3, #31
 80a0550:	d406      	bmi.n	80a0560 <loop+0x34>
 80a0552:	4628      	mov	r0, r5
 80a0554:	f7ff fda5 	bl	80a00a2 <__cxa_guard_acquire>
 80a0558:	b110      	cbz	r0, 80a0560 <loop+0x34>
 80a055a:	4628      	mov	r0, r5
 80a055c:	f7ff fda6 	bl	80a00ac <__cxa_guard_release>
    static unsigned long prev20msTime = thisTime;
 80a0560:	4d58      	ldr	r5, [pc, #352]	; (80a06c4 <loop+0x198>)
 80a0562:	682b      	ldr	r3, [r5, #0]
 80a0564:	07d9      	lsls	r1, r3, #31
 80a0566:	d406      	bmi.n	80a0576 <loop+0x4a>
 80a0568:	4628      	mov	r0, r5
 80a056a:	f7ff fd9a 	bl	80a00a2 <__cxa_guard_acquire>
 80a056e:	b110      	cbz	r0, 80a0576 <loop+0x4a>
 80a0570:	4628      	mov	r0, r5
 80a0572:	f7ff fd9b 	bl	80a00ac <__cxa_guard_release>
    static unsigned long prev40msTime = thisTime;
 80a0576:	4d54      	ldr	r5, [pc, #336]	; (80a06c8 <loop+0x19c>)
 80a0578:	682b      	ldr	r3, [r5, #0]
 80a057a:	07da      	lsls	r2, r3, #31
 80a057c:	d406      	bmi.n	80a058c <loop+0x60>
 80a057e:	4628      	mov	r0, r5
 80a0580:	f7ff fd8f 	bl	80a00a2 <__cxa_guard_acquire>
 80a0584:	b110      	cbz	r0, 80a058c <loop+0x60>
 80a0586:	4628      	mov	r0, r5
 80a0588:	f7ff fd90 	bl	80a00ac <__cxa_guard_release>
    static unsigned long prev80msTime = thisTime;
 80a058c:	4d4f      	ldr	r5, [pc, #316]	; (80a06cc <loop+0x1a0>)
 80a058e:	682b      	ldr	r3, [r5, #0]
 80a0590:	07db      	lsls	r3, r3, #31
 80a0592:	d406      	bmi.n	80a05a2 <loop+0x76>
 80a0594:	4628      	mov	r0, r5
 80a0596:	f7ff fd84 	bl	80a00a2 <__cxa_guard_acquire>
 80a059a:	b110      	cbz	r0, 80a05a2 <loop+0x76>
 80a059c:	4628      	mov	r0, r5
 80a059e:	f7ff fd85 	bl	80a00ac <__cxa_guard_release>
    static unsigned long prev160msTime = thisTime;
 80a05a2:	4d4b      	ldr	r5, [pc, #300]	; (80a06d0 <loop+0x1a4>)
 80a05a4:	682b      	ldr	r3, [r5, #0]
 80a05a6:	07d8      	lsls	r0, r3, #31
 80a05a8:	d408      	bmi.n	80a05bc <loop+0x90>
 80a05aa:	4628      	mov	r0, r5
 80a05ac:	f7ff fd79 	bl	80a00a2 <__cxa_guard_acquire>
 80a05b0:	b120      	cbz	r0, 80a05bc <loop+0x90>
 80a05b2:	4b48      	ldr	r3, [pc, #288]	; (80a06d4 <loop+0x1a8>)
 80a05b4:	4628      	mov	r0, r5
 80a05b6:	601c      	str	r4, [r3, #0]
 80a05b8:	f7ff fd78 	bl	80a00ac <__cxa_guard_release>
    static unsigned long prev320msTime = thisTime;
 80a05bc:	4d46      	ldr	r5, [pc, #280]	; (80a06d8 <loop+0x1ac>)
 80a05be:	682b      	ldr	r3, [r5, #0]
 80a05c0:	07d9      	lsls	r1, r3, #31
 80a05c2:	d408      	bmi.n	80a05d6 <loop+0xaa>
 80a05c4:	4628      	mov	r0, r5
 80a05c6:	f7ff fd6c 	bl	80a00a2 <__cxa_guard_acquire>
 80a05ca:	b120      	cbz	r0, 80a05d6 <loop+0xaa>
 80a05cc:	4b43      	ldr	r3, [pc, #268]	; (80a06dc <loop+0x1b0>)
 80a05ce:	4628      	mov	r0, r5
 80a05d0:	601c      	str	r4, [r3, #0]
 80a05d2:	f7ff fd6b 	bl	80a00ac <__cxa_guard_release>
    static unsigned long prev640msTime = thisTime;
 80a05d6:	4d42      	ldr	r5, [pc, #264]	; (80a06e0 <loop+0x1b4>)
 80a05d8:	682b      	ldr	r3, [r5, #0]
 80a05da:	07da      	lsls	r2, r3, #31
 80a05dc:	d408      	bmi.n	80a05f0 <loop+0xc4>
 80a05de:	4628      	mov	r0, r5
 80a05e0:	f7ff fd5f 	bl	80a00a2 <__cxa_guard_acquire>
 80a05e4:	b120      	cbz	r0, 80a05f0 <loop+0xc4>
 80a05e6:	4b3f      	ldr	r3, [pc, #252]	; (80a06e4 <loop+0x1b8>)
 80a05e8:	4628      	mov	r0, r5
 80a05ea:	601c      	str	r4, [r3, #0]
 80a05ec:	f7ff fd5e 	bl	80a00ac <__cxa_guard_release>
    static unsigned long prev1280msTime = thisTime;
 80a05f0:	4d3d      	ldr	r5, [pc, #244]	; (80a06e8 <loop+0x1bc>)
 80a05f2:	682b      	ldr	r3, [r5, #0]
 80a05f4:	07db      	lsls	r3, r3, #31
 80a05f6:	d408      	bmi.n	80a060a <loop+0xde>
 80a05f8:	4628      	mov	r0, r5
 80a05fa:	f7ff fd52 	bl	80a00a2 <__cxa_guard_acquire>
 80a05fe:	b120      	cbz	r0, 80a060a <loop+0xde>
 80a0600:	4b3a      	ldr	r3, [pc, #232]	; (80a06ec <loop+0x1c0>)
 80a0602:	4628      	mov	r0, r5
 80a0604:	601c      	str	r4, [r3, #0]
 80a0606:	f7ff fd51 	bl	80a00ac <__cxa_guard_release>

    if (onceThrough == 1){
 80a060a:	4b39      	ldr	r3, [pc, #228]	; (80a06f0 <loop+0x1c4>)
 80a060c:	681b      	ldr	r3, [r3, #0]
 80a060e:	2b01      	cmp	r3, #1
 80a0610:	d101      	bne.n	80a0616 <loop+0xea>
      canReceiveMessage();          //check for new CAN messages
 80a0612:	f000 fb55 	bl	80a0cc0 <_Z17canReceiveMessagev>
    }
    if (scheduler5msExpired){
 80a0616:	4b37      	ldr	r3, [pc, #220]	; (80a06f4 <loop+0x1c8>)
 80a0618:	781a      	ldrb	r2, [r3, #0]
 80a061a:	2a00      	cmp	r2, #0
 80a061c:	d04d      	beq.n	80a06ba <loop+0x18e>
    //if ((thisTime-lastTime) >= 5){
        scheduler5msExpired = 0;
 80a061e:	2200      	movs	r2, #0
 80a0620:	701a      	strb	r2, [r3, #0]
        lastTime = thisTime;
        timedLoop++;
 80a0622:	4d35      	ldr	r5, [pc, #212]	; (80a06f8 <loop+0x1cc>)
      canReceiveMessage();          //check for new CAN messages
    }
    if (scheduler5msExpired){
    //if ((thisTime-lastTime) >= 5){
        scheduler5msExpired = 0;
        lastTime = thisTime;
 80a0624:	4b35      	ldr	r3, [pc, #212]	; (80a06fc <loop+0x1d0>)
 80a0626:	601c      	str	r4, [r3, #0]
        timedLoop++;
 80a0628:	682b      	ldr	r3, [r5, #0]
 80a062a:	3301      	adds	r3, #1
 80a062c:	602b      	str	r3, [r5, #0]

        //Serial.printf("millis: %d\n",(thisTime-tempTime));
        //tempTime = thisTime;
        Tasks5ms();
 80a062e:	f000 fa6c 	bl	80a0b0a <_Z8Tasks5msv>

        if ((timedLoop & OS_10MS_MASK) == OS_10MS_MASK){
 80a0632:	682b      	ldr	r3, [r5, #0]
 80a0634:	07d8      	lsls	r0, r3, #31
 80a0636:	d503      	bpl.n	80a0640 <loop+0x114>
          //Serial.println(testState2String);
          prev1280msTime = thisTime;
          Tasks1280ms();
        }
    }
}
 80a0638:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        Tasks5ms();

        if ((timedLoop & OS_10MS_MASK) == OS_10MS_MASK){
          //Serial.printf("millis: %d\n",(thisTime-tempTime));
          //tempTime = thisTime;
          Tasks10ms();
 80a063c:	f000 ba67 	b.w	80a0b0e <_Z9Tasks10msv>
        }

        else if ((timedLoop & OS_20MS_MASK) == OS_20MS_MASK){
 80a0640:	0799      	lsls	r1, r3, #30
 80a0642:	d503      	bpl.n	80a064c <loop+0x120>
          //Serial.println(testState2String);
          prev1280msTime = thisTime;
          Tasks1280ms();
        }
    }
}
 80a0644:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
          //tempTime = thisTime;
          Tasks10ms();
        }

        else if ((timedLoop & OS_20MS_MASK) == OS_20MS_MASK){
          Tasks20ms();
 80a0648:	f000 ba62 	b.w	80a0b10 <_Z9Tasks20msv>
        }

        else if ((timedLoop & OS_40MS_MASK) == OS_40MS_MASK){
 80a064c:	075a      	lsls	r2, r3, #29
 80a064e:	d503      	bpl.n	80a0658 <loop+0x12c>
          //Serial.println(testState2String);
          prev1280msTime = thisTime;
          Tasks1280ms();
        }
    }
}
 80a0650:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        else if ((timedLoop & OS_20MS_MASK) == OS_20MS_MASK){
          Tasks20ms();
        }

        else if ((timedLoop & OS_40MS_MASK) == OS_40MS_MASK){
          Tasks40ms();
 80a0654:	f000 ba5e 	b.w	80a0b14 <_Z9Tasks40msv>
        }

        else if ((timedLoop & OS_80MS_MASK) == OS_80MS_MASK){
 80a0658:	071b      	lsls	r3, r3, #28
 80a065a:	d503      	bpl.n	80a0664 <loop+0x138>
          //Serial.println(testState2String);
          prev1280msTime = thisTime;
          Tasks1280ms();
        }
    }
}
 80a065c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        else if ((timedLoop & OS_40MS_MASK) == OS_40MS_MASK){
          Tasks40ms();
        }

        else if ((timedLoop & OS_80MS_MASK) == OS_80MS_MASK){
          Tasks80ms();
 80a0660:	f000 ba9e 	b.w	80a0ba0 <_Z9Tasks80msv>
        }

        //else if ((timedLoop & OS_160MS_MASK) == OS_160MS_MASK){
        else if ((thisTime-prev160msTime) >= 160){
 80a0664:	4a1b      	ldr	r2, [pc, #108]	; (80a06d4 <loop+0x1a8>)
 80a0666:	6813      	ldr	r3, [r2, #0]
 80a0668:	1ae3      	subs	r3, r4, r3
 80a066a:	2b9f      	cmp	r3, #159	; 0x9f
 80a066c:	d904      	bls.n	80a0678 <loop+0x14c>
          //Serial.println(testState2String);
          //Serial.printf("millis: %d\n",(thisTime-tempTime));
          //tempTime = thisTime;
          prev160msTime = thisTime;
 80a066e:	6014      	str	r4, [r2, #0]
          //Serial.println(testState2String);
          prev1280msTime = thisTime;
          Tasks1280ms();
        }
    }
}
 80a0670:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        else if ((thisTime-prev160msTime) >= 160){
          //Serial.println(testState2String);
          //Serial.printf("millis: %d\n",(thisTime-tempTime));
          //tempTime = thisTime;
          prev160msTime = thisTime;
          Tasks160ms();
 80a0674:	f000 ba95 	b.w	80a0ba2 <_Z10Tasks160msv>
        }

        else if ((thisTime-prev320msTime) >= 320){
 80a0678:	4a18      	ldr	r2, [pc, #96]	; (80a06dc <loop+0x1b0>)
 80a067a:	6813      	ldr	r3, [r2, #0]
 80a067c:	1ae3      	subs	r3, r4, r3
 80a067e:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
 80a0682:	d304      	bcc.n	80a068e <loop+0x162>
          //Serial.printf("millis: %d\n",(thisTime-tempTime));
          //tempTime = thisTime;
          prev320msTime = thisTime;
 80a0684:	6014      	str	r4, [r2, #0]
          //Serial.println(testState2String);
          prev1280msTime = thisTime;
          Tasks1280ms();
        }
    }
}
 80a0686:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

        else if ((thisTime-prev320msTime) >= 320){
          //Serial.printf("millis: %d\n",(thisTime-tempTime));
          //tempTime = thisTime;
          prev320msTime = thisTime;
          Tasks320ms();
 80a068a:	f000 ba8b 	b.w	80a0ba4 <_Z10Tasks320msv>
        }

        else if ((thisTime-prev640msTime) >= 640){
 80a068e:	4a15      	ldr	r2, [pc, #84]	; (80a06e4 <loop+0x1b8>)
 80a0690:	6813      	ldr	r3, [r2, #0]
 80a0692:	1ae3      	subs	r3, r4, r3
 80a0694:	f5b3 7f20 	cmp.w	r3, #640	; 0x280
 80a0698:	d304      	bcc.n	80a06a4 <loop+0x178>
          //Serial.printf("millis: %d\n",(thisTime-tempTime));
          //tempTime = thisTime;
          prev640msTime = thisTime;
 80a069a:	6014      	str	r4, [r2, #0]
          //Serial.println(testState2String);
          prev1280msTime = thisTime;
          Tasks1280ms();
        }
    }
}
 80a069c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

        else if ((thisTime-prev640msTime) >= 640){
          //Serial.printf("millis: %d\n",(thisTime-tempTime));
          //tempTime = thisTime;
          prev640msTime = thisTime;
          Tasks640ms();
 80a06a0:	f000 ba81 	b.w	80a0ba6 <_Z10Tasks640msv>
        }

        else if ((thisTime-prev1280msTime) >= 1280){
 80a06a4:	4a11      	ldr	r2, [pc, #68]	; (80a06ec <loop+0x1c0>)
 80a06a6:	6813      	ldr	r3, [r2, #0]
 80a06a8:	1ae3      	subs	r3, r4, r3
 80a06aa:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80a06ae:	d304      	bcc.n	80a06ba <loop+0x18e>
          //Serial.printf("millis: %d\n",(thisTime-tempTime));
          //tempTime = thisTime;
          //Serial.println(testState2String);
          prev1280msTime = thisTime;
 80a06b0:	6014      	str	r4, [r2, #0]
          Tasks1280ms();
        }
    }
}
 80a06b2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        else if ((thisTime-prev1280msTime) >= 1280){
          //Serial.printf("millis: %d\n",(thisTime-tempTime));
          //tempTime = thisTime;
          //Serial.println(testState2String);
          prev1280msTime = thisTime;
          Tasks1280ms();
 80a06b6:	f000 ba77 	b.w	80a0ba8 <_Z11Tasks1280msv>
 80a06ba:	bd38      	pop	{r3, r4, r5, pc}
 80a06bc:	2000041c 	.word	0x2000041c
 80a06c0:	20000420 	.word	0x20000420
 80a06c4:	200003ec 	.word	0x200003ec
 80a06c8:	20000408 	.word	0x20000408
 80a06cc:	200003d8 	.word	0x200003d8
 80a06d0:	200003f8 	.word	0x200003f8
 80a06d4:	200003f0 	.word	0x200003f0
 80a06d8:	20000404 	.word	0x20000404
 80a06dc:	20000400 	.word	0x20000400
 80a06e0:	20000444 	.word	0x20000444
 80a06e4:	200003d0 	.word	0x200003d0
 80a06e8:	200003f4 	.word	0x200003f4
 80a06ec:	20000424 	.word	0x20000424
 80a06f0:	200003d4 	.word	0x200003d4
 80a06f4:	20000438 	.word	0x20000438
 80a06f8:	20000440 	.word	0x20000440
 80a06fc:	200003fc 	.word	0x200003fc

080a0700 <_GLOBAL__sub_I_scheduler5msExpired>:
    }
}

void fiveMsTimer(){
    scheduler5msExpired = 1;
}
 80a0700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

SYSTEM_THREAD(ENABLED);

void fiveMsTimer(void);
bool scheduler5msExpired = 0;   //flag for os timer
IntervalTimer myTimer;          //used to create the 1ms timer
 80a0702:	4d14      	ldr	r5, [pc, #80]	; (80a0754 <_GLOBAL__sub_I_scheduler5msExpired+0x54>)
 80a0704:	f002 fc3a 	bl	80a2f7c <HAL_Pin_Map>
#include "CANrec.h"
#include <SdFat.h>
#include <SparkIntervalTimer.h>
#include <carloop.h>

SYSTEM_THREAD(ENABLED);
 80a0708:	2100      	movs	r1, #0
 80a070a:	2001      	movs	r0, #1
 80a070c:	f002 fe10 	bl	80a3330 <system_thread_set_state>

void fiveMsTimer(void);
bool scheduler5msExpired = 0;   //flag for os timer
IntervalTimer myTimer;          //used to create the 1ms timer
 80a0710:	4c11      	ldr	r4, [pc, #68]	; (80a0758 <_GLOBAL__sub_I_scheduler5msExpired+0x58>)
 80a0712:	4628      	mov	r0, r5
 80a0714:	f7ff fe88 	bl	80a0428 <_ZN13IntervalTimerC1Ev>
int timedLoop = 0;              //used for the task scheduler



String strWrFileName;           //name of file for writing data
 80a0718:	4f10      	ldr	r7, [pc, #64]	; (80a075c <_GLOBAL__sub_I_scheduler5msExpired+0x5c>)

SYSTEM_THREAD(ENABLED);

void fiveMsTimer(void);
bool scheduler5msExpired = 0;   //flag for os timer
IntervalTimer myTimer;          //used to create the 1ms timer
 80a071a:	4628      	mov	r0, r5
int timedLoop = 0;              //used for the task scheduler



String strWrFileName;           //name of file for writing data
 80a071c:	4d10      	ldr	r5, [pc, #64]	; (80a0760 <_GLOBAL__sub_I_scheduler5msExpired+0x60>)

SYSTEM_THREAD(ENABLED);

void fiveMsTimer(void);
bool scheduler5msExpired = 0;   //flag for os timer
IntervalTimer myTimer;          //used to create the 1ms timer
 80a071e:	4622      	mov	r2, r4
 80a0720:	4910      	ldr	r1, [pc, #64]	; (80a0764 <_GLOBAL__sub_I_scheduler5msExpired+0x64>)
 80a0722:	f003 fccd 	bl	80a40c0 <__aeabi_atexit>
int timedLoop = 0;              //used for the task scheduler



String strWrFileName;           //name of file for writing data
 80a0726:	4e10      	ldr	r6, [pc, #64]	; (80a0768 <_GLOBAL__sub_I_scheduler5msExpired+0x68>)
 80a0728:	4639      	mov	r1, r7
 80a072a:	4628      	mov	r0, r5
 80a072c:	f002 ffb1 	bl	80a3692 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0730:	4628      	mov	r0, r5
String strRdFileName;           //name of file for read only
 80a0732:	4d0e      	ldr	r5, [pc, #56]	; (80a076c <_GLOBAL__sub_I_scheduler5msExpired+0x6c>)
IntervalTimer myTimer;          //used to create the 1ms timer
int timedLoop = 0;              //used for the task scheduler



String strWrFileName;           //name of file for writing data
 80a0734:	4622      	mov	r2, r4
 80a0736:	4631      	mov	r1, r6
 80a0738:	f003 fcc2 	bl	80a40c0 <__aeabi_atexit>
String strRdFileName;           //name of file for read only
 80a073c:	4639      	mov	r1, r7
 80a073e:	4628      	mov	r0, r5
 80a0740:	f002 ffa7 	bl	80a3692 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0744:	4622      	mov	r2, r4
 80a0746:	4631      	mov	r1, r6
 80a0748:	4628      	mov	r0, r5
    }
}

void fiveMsTimer(){
    scheduler5msExpired = 1;
}
 80a074a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
int timedLoop = 0;              //used for the task scheduler



String strWrFileName;           //name of file for writing data
String strRdFileName;           //name of file for read only
 80a074e:	f003 bcb7 	b.w	80a40c0 <__aeabi_atexit>
 80a0752:	bf00      	nop
 80a0754:	200003dc 	.word	0x200003dc
 80a0758:	200003c0 	.word	0x200003c0
 80a075c:	080a5a06 	.word	0x080a5a06
 80a0760:	2000040c 	.word	0x2000040c
 80a0764:	080a0409 	.word	0x080a0409
 80a0768:	080a3605 	.word	0x080a3605
 80a076c:	20000428 	.word	0x20000428

080a0770 <_ZN6SdFileD1Ev>:
#if ENABLE_ARDUINO_FEATURES
/**
 * \class SdFile
 * \brief Class for backward compatibility.
 */
class SdFile : public PrintFile {
 80a0770:	4770      	bx	lr

080a0772 <_Z8dateTimePtS_>:
  //Serial.println("attempting to close READ file");
  readFramesFile.close();
  //readFrameFileExists = 0;
}

void dateTime(uint16_t* date, uint16_t* time) {
 80a0772:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0774:	460e      	mov	r6, r1
 80a0776:	4607      	mov	r7, r0
  // return date using FAT_DATE macro to format fields
  *date = FAT_DATE(Time.year(), Time.month(), Time.day());
 80a0778:	f003 f90c 	bl	80a3994 <_ZN9TimeClass4yearEv>
 80a077c:	4605      	mov	r5, r0
 80a077e:	f003 f901 	bl	80a3984 <_ZN9TimeClass5monthEv>
 80a0782:	4604      	mov	r4, r0
 80a0784:	f003 f8f4 	bl	80a3970 <_ZN9TimeClass3dayEv>
 80a0788:	0164      	lsls	r4, r4, #5
 80a078a:	b2c0      	uxtb	r0, r0
 80a078c:	b2ad      	uxth	r5, r5
 80a078e:	f404 54ff 	and.w	r4, r4, #8160	; 0x1fe0
 80a0792:	f2a5 75bc 	subw	r5, r5, #1980	; 0x7bc
 80a0796:	4304      	orrs	r4, r0
 80a0798:	ea44 2445 	orr.w	r4, r4, r5, lsl #9
 80a079c:	803c      	strh	r4, [r7, #0]

  // return time using FAT_TIME macro to format fields
  *time = FAT_TIME(Time.hour(), Time.minute(), Time.second());
 80a079e:	f003 f8c9 	bl	80a3934 <_ZN9TimeClass4hourEv>
 80a07a2:	4605      	mov	r5, r0
 80a07a4:	f003 f8d0 	bl	80a3948 <_ZN9TimeClass6minuteEv>
 80a07a8:	4604      	mov	r4, r0
 80a07aa:	f003 f8d7 	bl	80a395c <_ZN9TimeClass6secondEv>
 80a07ae:	02ed      	lsls	r5, r5, #11
 80a07b0:	0164      	lsls	r4, r4, #5
 80a07b2:	f405 25ff 	and.w	r5, r5, #522240	; 0x7f800
 80a07b6:	f404 54ff 	and.w	r4, r4, #8160	; 0x1fe0
 80a07ba:	432c      	orrs	r4, r5
 80a07bc:	f3c0 0046 	ubfx	r0, r0, #1, #7
 80a07c0:	4304      	orrs	r4, r0
 80a07c2:	8034      	strh	r4, [r6, #0]
 80a07c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080a07c8 <_ZNK8particle13__SPISettings7printToER5Print>:
  bool operator!=(const __SPISettings& other) const
  {
    return !(other == *this);
  }

  virtual size_t printTo(Print& p) const
 80a07c8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80a07ca:	4602      	mov	r2, r0
  {
    if (default_ && clock_ == 0)
 80a07cc:	7913      	ldrb	r3, [r2, #4]
  bool operator!=(const __SPISettings& other) const
  {
    return !(other == *this);
  }

  virtual size_t printTo(Print& p) const
 80a07ce:	4608      	mov	r0, r1
 80a07d0:	6895      	ldr	r5, [r2, #8]
  {
    if (default_ && clock_ == 0)
 80a07d2:	b133      	cbz	r3, 80a07e2 <_ZNK8particle13__SPISettings7printToER5Print+0x1a>
 80a07d4:	b93d      	cbnz	r5, 80a07e6 <_ZNK8particle13__SPISettings7printToER5Print+0x1e>
      return p.print("<SPISettings default>");
 80a07d6:	490c      	ldr	r1, [pc, #48]	; (80a0808 <_ZNK8particle13__SPISettings7printToER5Print+0x40>)
    else
      return p.printf("<SPISettings %s%lu %s MODE%d>", default_ ? "default " : "", clock_, bitOrder_ == MSBFIRST ? "MSB" : "LSB", dataMode_);
  }
 80a07d8:	b004      	add	sp, #16
 80a07da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }

  virtual size_t printTo(Print& p) const
  {
    if (default_ && clock_ == 0)
      return p.print("<SPISettings default>");
 80a07de:	f002 bfac 	b.w	80a373a <_ZN5Print5printEPKc>
    else
      return p.printf("<SPISettings %s%lu %s MODE%d>", default_ ? "default " : "", clock_, bitOrder_ == MSBFIRST ? "MSB" : "LSB", dataMode_);
 80a07e2:	4b0a      	ldr	r3, [pc, #40]	; (80a080c <_ZNK8particle13__SPISettings7printToER5Print+0x44>)
 80a07e4:	e000      	b.n	80a07e8 <_ZNK8particle13__SPISettings7printToER5Print+0x20>
 80a07e6:	4b0a      	ldr	r3, [pc, #40]	; (80a0810 <_ZNK8particle13__SPISettings7printToER5Print+0x48>)
 80a07e8:	7b16      	ldrb	r6, [r2, #12]
 80a07ea:	4c0a      	ldr	r4, [pc, #40]	; (80a0814 <_ZNK8particle13__SPISettings7printToER5Print+0x4c>)
 80a07ec:	490a      	ldr	r1, [pc, #40]	; (80a0818 <_ZNK8particle13__SPISettings7printToER5Print+0x50>)
    size_t println(const __FlashStringHelper*);

    template <typename... Args>
    inline size_t printf(const char* format, Args... args)
    {
        return this->printf_impl(false, format, args...);
 80a07ee:	7b52      	ldrb	r2, [r2, #13]
 80a07f0:	2e01      	cmp	r6, #1
 80a07f2:	bf08      	it	eq
 80a07f4:	4621      	moveq	r1, r4
 80a07f6:	9202      	str	r2, [sp, #8]
 80a07f8:	9101      	str	r1, [sp, #4]
 80a07fa:	9500      	str	r5, [sp, #0]
 80a07fc:	4a07      	ldr	r2, [pc, #28]	; (80a081c <_ZNK8particle13__SPISettings7printToER5Print+0x54>)
 80a07fe:	2100      	movs	r1, #0
 80a0800:	f002 ffe4 	bl	80a37cc <_ZN5Print11printf_implEbPKcz>
  }
 80a0804:	b004      	add	sp, #16
 80a0806:	bd70      	pop	{r4, r5, r6, pc}
 80a0808:	080a58ad 	.word	0x080a58ad
 80a080c:	080a5a06 	.word	0x080a5a06
 80a0810:	080a589c 	.word	0x080a589c
 80a0814:	080a58a5 	.word	0x080a58a5
 80a0818:	080a58a9 	.word	0x080a58a9
 80a081c:	080a58c3 	.word	0x080a58c3

080a0820 <_ZN6SdFileD0Ev>:
 80a0820:	b510      	push	{r4, lr}
 80a0822:	4604      	mov	r4, r0
 80a0824:	f7ff fc3b 	bl	80a009e <_ZdlPv>
 80a0828:	4620      	mov	r0, r4
 80a082a:	bd10      	pop	{r4, pc}

080a082c <_ZN9PrintFile5writeEPKhj>:
   * include write() is called before a file has been opened, write is called
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const uint8_t *buf, size_t size) {
    return FatFile::write(buf, size);
 80a082c:	3008      	adds	r0, #8
 80a082e:	f001 bcbb 	b.w	80a21a8 <_ZN7FatFile5writeEPKvj>

080a0832 <_ZN9PrintFile5writeEh>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
 80a0832:	b507      	push	{r0, r1, r2, lr}
 80a0834:	ab02      	add	r3, sp, #8
 80a0836:	f803 1d01 	strb.w	r1, [r3, #-1]!
  /** Write a single byte.
   * \param[in] b The byte to be written.
   * \return +1 for success or -1 for failure.
   */
  int write(uint8_t b) {
    return write(&b, 1);
 80a083a:	2201      	movs	r2, #1
 80a083c:	4619      	mov	r1, r3
 80a083e:	3008      	adds	r0, #8
 80a0840:	f001 fcb2 	bl	80a21a8 <_ZN7FatFile5writeEPKvj>
    return FatFile::write(b);
  }
 80a0844:	b003      	add	sp, #12
 80a0846:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a084c <_Z17openReadFrameFile6String.part.3>:
void closeReadFrameFile(void);

//void initSD(int);
//void LogBMS2SD(void);

int openReadFrameFile(String fileName){
 80a084c:	b500      	push	{lr}
 80a084e:	b0e5      	sub	sp, #404	; 0x194
  //Serial.println(tempReadStat);
  if (tempReadStat){
    //Serial.print(fileName);
    //Serial.println(" OPENED");
    char fileLineChars[400];
    readFramesFile.fgets(fileLineChars,400); //read and discard first line
 80a0850:	2300      	movs	r3, #0
 80a0852:	f44f 72c8 	mov.w	r2, #400	; 0x190
 80a0856:	4669      	mov	r1, sp
 80a0858:	4803      	ldr	r0, [pc, #12]	; (80a0868 <_Z17openReadFrameFile6String.part.3+0x1c>)
 80a085a:	f001 fb0d 	bl	80a1e78 <_ZN7FatFile5fgetsEPcsS0_>
    //readFramesFile.fgets(fileLineChars,400); //read and discard second line
    //Serial.println(fileLineChars);
    return 1;
  }
  else return 0;
}
 80a085e:	2001      	movs	r0, #1
 80a0860:	b065      	add	sp, #404	; 0x194
 80a0862:	f85d fb04 	ldr.w	pc, [sp], #4
 80a0866:	bf00      	nop
 80a0868:	20000450 	.word	0x20000450

080a086c <_Z17openReadFrameFile6String>:
void closeReadFrameFile(void);

//void initSD(int);
//void LogBMS2SD(void);

int openReadFrameFile(String fileName){
 80a086c:	b508      	push	{r3, lr}
   *
   * \return The value true is returned for success and
   * the value false is returned for failure.
   */
  bool open(const char* path, oflag_t oflag = O_RDONLY) {
    return open(m_cwd, path, oflag);
 80a086e:	4906      	ldr	r1, [pc, #24]	; (80a0888 <_Z17openReadFrameFile6String+0x1c>)
 80a0870:	6802      	ldr	r2, [r0, #0]
 80a0872:	2300      	movs	r3, #0
 80a0874:	6809      	ldr	r1, [r1, #0]
 80a0876:	4805      	ldr	r0, [pc, #20]	; (80a088c <_Z17openReadFrameFile6String+0x20>)
 80a0878:	f001 fc47 	bl	80a210a <_ZN7FatFile4openEPS_PKci>
  //Serial.println("attempting to open READ file");
  //Serial.println(fileName);
  int tempReadStat = readFramesFile.open(fileName, O_READ);
  //Serial.println(tempReadStat);
  if (tempReadStat){
 80a087c:	b118      	cbz	r0, 80a0886 <_Z17openReadFrameFile6String+0x1a>
    //readFramesFile.fgets(fileLineChars,400); //read and discard second line
    //Serial.println(fileLineChars);
    return 1;
  }
  else return 0;
}
 80a087e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80a0882:	f7ff bfe3 	b.w	80a084c <_Z17openReadFrameFile6String.part.3>
 80a0886:	bd08      	pop	{r3, pc}
 80a0888:	20000af4 	.word	0x20000af4
 80a088c:	20000450 	.word	0x20000450

080a0890 <_Z18openReadWriteFilesi>:
  }
  */
  //Serial.print(fieldSubStringValue);
}

void openReadWriteFiles(int what2log){
 80a0890:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  VCUlogging = (what2log & VCU_LOG_MASK)>>2;     //log general vehicle data
  CSMlogging = (what2log & CSM_TEMP_LOG_MASK)>>3; //log csm temperature data
  TEST_SPRVSRlogging = (what2log & TEST_SUPERVISOR_LOG_MASK)>>4;
  unsigned int nowTime = Time.now();
*/
  strReadFileName = "EL_LOAD_FRAMES.csv";
 80a0892:	490b      	ldr	r1, [pc, #44]	; (80a08c0 <_Z18openReadWriteFilesi+0x30>)
 80a0894:	480b      	ldr	r0, [pc, #44]	; (80a08c4 <_Z18openReadWriteFilesi+0x34>)
 80a0896:	f002 ff29 	bl	80a36ec <_ZN6StringaSEPKc>
  strFileName.concat(".csv");
  Serial.println(strFileName);
  */

/////-------------------------------------------------------------------INIT LOG FILE------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  if (SDcardInitOK){
 80a089a:	4b0b      	ldr	r3, [pc, #44]	; (80a08c8 <_Z18openReadWriteFilesi+0x38>)
 80a089c:	681b      	ldr	r3, [r3, #0]
 80a089e:	b15b      	cbz	r3, 80a08b8 <_Z18openReadWriteFilesi+0x28>
          myFileOk = 1;                                                                                                                                                                                                                                            //--
      }
      else myFileOk = 0;
      */
/////--------------------------------INIT READ FILE--------------------------------
    readFrameFileExists = openReadFrameFile(strReadFileName);                                                                                                                                                                                                    //--
 80a08a0:	4908      	ldr	r1, [pc, #32]	; (80a08c4 <_Z18openReadWriteFilesi+0x34>)
 80a08a2:	4668      	mov	r0, sp
 80a08a4:	f002 ff17 	bl	80a36d6 <_ZN6StringC1ERKS_>
 80a08a8:	4668      	mov	r0, sp
 80a08aa:	f7ff ffdf 	bl	80a086c <_Z17openReadFrameFile6String>
 80a08ae:	4b07      	ldr	r3, [pc, #28]	; (80a08cc <_Z18openReadWriteFilesi+0x3c>)
 80a08b0:	6018      	str	r0, [r3, #0]
 80a08b2:	4668      	mov	r0, sp
 80a08b4:	f002 fea6 	bl	80a3604 <_ZN6StringD1Ev>
  }                                                                                                                                                                                                                                                                //--

}
 80a08b8:	b005      	add	sp, #20
 80a08ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80a08be:	bf00      	nop
 80a08c0:	080a58e1 	.word	0x080a58e1
 80a08c4:	200004c0 	.word	0x200004c0
 80a08c8:	200004d0 	.word	0x200004d0
 80a08cc:	2000043c 	.word	0x2000043c

080a08d0 <_Z12ResetSDTimer9SD_TIMERS>:
  frameNumber = 0;
  readFramesFile.seekSet(0);
}

void ResetSDTimer(SD_TIMERS eSDTimer){
  if (eSDTimer == CT_SD_NEXT_LINE_DELAY){
 80a08d0:	b918      	cbnz	r0, 80a08da <_Z12ResetSDTimer9SD_TIMERS+0xa>
    SetTimerWithMilliseconds(&scastSDtimers[eSDTimer], frameDelaymSec);
 80a08d2:	4b07      	ldr	r3, [pc, #28]	; (80a08f0 <_Z12ResetSDTimer9SD_TIMERS+0x20>)
 80a08d4:	4807      	ldr	r0, [pc, #28]	; (80a08f4 <_Z12ResetSDTimer9SD_TIMERS+0x24>)
 80a08d6:	6819      	ldr	r1, [r3, #0]
 80a08d8:	e007      	b.n	80a08ea <_Z12ResetSDTimer9SD_TIMERS+0x1a>
  }
  else if (eSDTimer < NUM_SD_TIMERS)
 80a08da:	2802      	cmp	r0, #2
 80a08dc:	d807      	bhi.n	80a08ee <_Z12ResetSDTimer9SD_TIMERS+0x1e>
  {
    SetTimerWithMilliseconds(&scastSDtimers[eSDTimer], scawSDtimers[eSDTimer]);
 80a08de:	4b06      	ldr	r3, [pc, #24]	; (80a08f8 <_Z12ResetSDTimer9SD_TIMERS+0x28>)
 80a08e0:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 80a08e4:	4b03      	ldr	r3, [pc, #12]	; (80a08f4 <_Z12ResetSDTimer9SD_TIMERS+0x24>)
 80a08e6:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 80a08ea:	f000 ba49 	b.w	80a0d80 <_Z24SetTimerWithMillisecondsP16TICK_TIMER_S_TAGj>
 80a08ee:	4770      	bx	lr
 80a08f0:	20000300 	.word	0x20000300
 80a08f4:	20000500 	.word	0x20000500
 80a08f8:	080a5908 	.word	0x080a5908

080a08fc <_Z10initSDcardv>:

  // return time using FAT_TIME macro to format fields
  *time = FAT_TIME(Time.hour(), Time.minute(), Time.second());
}//------------------------------------------------------------------------------

void initSDcard(void){
 80a08fc:	b570      	push	{r4, r5, r6, lr}
   *
   * See the timestamp() function.
   */
  static void dateTimeCallback(
    void (*dateTime)(uint16_t* date, uint16_t* time)) {
    m_dateTime = dateTime;
 80a08fe:	4a3b      	ldr	r2, [pc, #236]	; (80a09ec <_Z10initSDcardv+0xf0>)
 80a0900:	b09c      	sub	sp, #112	; 0x70
 80a0902:	4b3b      	ldr	r3, [pc, #236]	; (80a09f0 <_Z10initSDcardv+0xf4>)
  SdFile::dateTimeCallback(dateTime); //make files on SD card have correct creation date/time
  String fieldString;
 80a0904:	493b      	ldr	r1, [pc, #236]	; (80a09f4 <_Z10initSDcardv+0xf8>)
 80a0906:	4668      	mov	r0, sp
 80a0908:	601a      	str	r2, [r3, #0]
 80a090a:	f002 fec2 	bl	80a3692 <_ZN6StringC1EPK19__FlashStringHelper>
  char fileLineChars[200];
  String fileLine;
 80a090e:	4939      	ldr	r1, [pc, #228]	; (80a09f4 <_Z10initSDcardv+0xf8>)
 80a0910:	a804      	add	r0, sp, #16
 80a0912:	f002 febe 	bl	80a3692 <_ZN6StringC1EPK19__FlashStringHelper>
  String tempUserString;
 80a0916:	4937      	ldr	r1, [pc, #220]	; (80a09f4 <_Z10initSDcardv+0xf8>)
 80a0918:	a808      	add	r0, sp, #32
 80a091a:	f002 feba 	bl	80a3692 <_ZN6StringC1EPK19__FlashStringHelper>
  int j = 5;
  int n = 0;  //number of characters read
  int i = 0;
  int tempLogItems = 0;
  unsigned int wIndex;
  String configTxtFileName = "CONFIG.txt";
 80a091e:	4936      	ldr	r1, [pc, #216]	; (80a09f8 <_Z10initSDcardv+0xfc>)
 80a0920:	a80c      	add	r0, sp, #48	; 0x30
 80a0922:	f002 feb6 	bl	80a3692 <_ZN6StringC1EPK19__FlashStringHelper>
  String fieldSubStringHead;
 80a0926:	4933      	ldr	r1, [pc, #204]	; (80a09f4 <_Z10initSDcardv+0xf8>)
 80a0928:	a810      	add	r0, sp, #64	; 0x40
 80a092a:	f002 feb2 	bl	80a3692 <_ZN6StringC1EPK19__FlashStringHelper>
  String fieldSubStringValue;
 80a092e:	4931      	ldr	r1, [pc, #196]	; (80a09f4 <_Z10initSDcardv+0xf8>)
 80a0930:	a814      	add	r0, sp, #80	; 0x50
 80a0932:	f002 feae 	bl	80a3692 <_ZN6StringC1EPK19__FlashStringHelper>

  for (wIndex = 0; wIndex < ((unsigned int)NUM_SD_TIMERS); wIndex++){
   RegisterTimer(&scastSDtimers[wIndex]);
 80a0936:	4d31      	ldr	r5, [pc, #196]	; (80a09fc <_Z10initSDcardv+0x100>)
  unsigned int wIndex;
  String configTxtFileName = "CONFIG.txt";
  String fieldSubStringHead;
  String fieldSubStringValue;

  for (wIndex = 0; wIndex < ((unsigned int)NUM_SD_TIMERS); wIndex++){
 80a0938:	2400      	movs	r4, #0
   RegisterTimer(&scastSDtimers[wIndex]);
 80a093a:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 80a093e:	f000 f9f5 	bl	80a0d2c <_Z13RegisterTimerP16TICK_TIMER_S_TAG>
   ResetSDTimer((SD_TIMERS)wIndex);
 80a0942:	b2e0      	uxtb	r0, r4
  unsigned int wIndex;
  String configTxtFileName = "CONFIG.txt";
  String fieldSubStringHead;
  String fieldSubStringValue;

  for (wIndex = 0; wIndex < ((unsigned int)NUM_SD_TIMERS); wIndex++){
 80a0944:	3401      	adds	r4, #1
   RegisterTimer(&scastSDtimers[wIndex]);
   ResetSDTimer((SD_TIMERS)wIndex);
 80a0946:	f7ff ffc3 	bl	80a08d0 <_Z12ResetSDTimer9SD_TIMERS>
  unsigned int wIndex;
  String configTxtFileName = "CONFIG.txt";
  String fieldSubStringHead;
  String fieldSubStringValue;

  for (wIndex = 0; wIndex < ((unsigned int)NUM_SD_TIMERS); wIndex++){
 80a094a:	2c03      	cmp	r4, #3
 80a094c:	d1f5      	bne.n	80a093a <_Z10initSDcardv+0x3e>
    SPI_CLK_CORE = 72*MHZ,
    SPI_CLK_PHOTON = 60*MHZ
};

namespace particle {
class __SPISettings : public Printable {
 80a094e:	4b2c      	ldr	r3, [pc, #176]	; (80a0a00 <_Z10initSDcardv+0x104>)
   * \param[in] csPin SD card chip select pin.
   * \param[in] spiSettings SPI speed, mode, and bit order.
   * \return true for success else false.
   */
  bool begin(uint8_t csPin = SS, SPISettings spiSettings = SPI_FULL_SPEED) {
    return m_card.begin(&m_spi, csPin, spiSettings) &&
 80a0950:	4c2c      	ldr	r4, [pc, #176]	; (80a0a04 <_Z10initSDcardv+0x108>)
 80a0952:	4a2d      	ldr	r2, [pc, #180]	; (80a0a08 <_Z10initSDcardv+0x10c>)
 80a0954:	9318      	str	r3, [sp, #96]	; 0x60
 80a0956:	f504 668c 	add.w	r6, r4, #1120	; 0x460
 80a095a:	2300      	movs	r3, #0
 80a095c:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
 80a0960:	921a      	str	r2, [sp, #104]	; 0x68
 80a0962:	2501      	movs	r5, #1
 80a0964:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 80a0968:	220c      	movs	r2, #12
 80a096a:	ab18      	add	r3, sp, #96	; 0x60
 80a096c:	f204 416c 	addw	r1, r4, #1132	; 0x46c
 80a0970:	4630      	mov	r0, r6
 80a0972:	f88d 506c 	strb.w	r5, [sp, #108]	; 0x6c
 80a0976:	f001 ff5d 	bl	80a2834 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE>
 80a097a:	b300      	cbz	r0, 80a09be <_Z10initSDcardv+0xc2>
   * \param[in] part partition to initialize.
   * \return The value true is returned for success and
   * the value false is returned for failure.
   */
  bool begin(BlockDriver* blockDev, uint8_t part = 0) {
    m_blockDev = blockDev;
 80a097c:	6026      	str	r6, [r4, #0]
    vwd()->close();
 80a097e:	f204 403c 	addw	r0, r4, #1084	; 0x43c
 80a0982:	f001 fbbb 	bl	80a20fc <_ZN7FatFile5closeEv>
    return (part ? init(part) : init(1) || init(0))
 80a0986:	4629      	mov	r1, r5
 80a0988:	4620      	mov	r0, r4
 80a098a:	f001 fdfc 	bl	80a2586 <_ZN9FatVolume4initEh>
            && vwd()->openRoot(this) && FatFile::setCwd(vwd());
 80a098e:	4601      	mov	r1, r0
 80a0990:	b180      	cbz	r0, 80a09b4 <_Z10initSDcardv+0xb8>
 80a0992:	4c1c      	ldr	r4, [pc, #112]	; (80a0a04 <_Z10initSDcardv+0x108>)
 80a0994:	f204 453c 	addw	r5, r4, #1084	; 0x43c
 80a0998:	4621      	mov	r1, r4
 80a099a:	4628      	mov	r0, r5
 80a099c:	f001 f9a1 	bl	80a1ce2 <_ZN7FatFile8openRootEP9FatVolume>
 80a09a0:	b168      	cbz	r0, 80a09be <_Z10initSDcardv+0xc2>
   * \param[in] dir New current working directory.
   *
   * \return true for success else false.
   */
  static bool setCwd(FatFile* dir) {
    if (!dir->isDir()) {
 80a09a2:	f894 343c 	ldrb.w	r3, [r4, #1084]	; 0x43c
 80a09a6:	f013 0370 	ands.w	r3, r3, #112	; 0x70
      return false;
    }
    m_cwd = dir;
 80a09aa:	bf16      	itet	ne
 80a09ac:	4b17      	ldrne	r3, [pc, #92]	; (80a0a0c <_Z10initSDcardv+0x110>)
 80a09ae:	4618      	moveq	r0, r3
 80a09b0:	601d      	strne	r5, [r3, #0]
 80a09b2:	e005      	b.n	80a09c0 <_Z10initSDcardv+0xc4>
   * the value false is returned for failure.
   */
  bool begin(BlockDriver* blockDev, uint8_t part = 0) {
    m_blockDev = blockDev;
    vwd()->close();
    return (part ? init(part) : init(1) || init(0))
 80a09b4:	4620      	mov	r0, r4
 80a09b6:	f001 fde6 	bl	80a2586 <_ZN9FatVolume4initEh>
 80a09ba:	2800      	cmp	r0, #0
 80a09bc:	d1e9      	bne.n	80a0992 <_Z10initSDcardv+0x96>
 80a09be:	2000      	movs	r0, #0
   RegisterTimer(&scastSDtimers[wIndex]);
   ResetSDTimer((SD_TIMERS)wIndex);
  }

  SDcardInitOK = sd.begin(chipSelect, SD_SCK_HZ(4 * MHZ));
 80a09c0:	4b13      	ldr	r3, [pc, #76]	; (80a0a10 <_Z10initSDcardv+0x114>)
 80a09c2:	6018      	str	r0, [r3, #0]
  int i = 0;
  int tempLogItems = 0;
  unsigned int wIndex;
  String configTxtFileName = "CONFIG.txt";
  String fieldSubStringHead;
  String fieldSubStringValue;
 80a09c4:	a814      	add	r0, sp, #80	; 0x50
 80a09c6:	f002 fe1d 	bl	80a3604 <_ZN6StringD1Ev>
  int n = 0;  //number of characters read
  int i = 0;
  int tempLogItems = 0;
  unsigned int wIndex;
  String configTxtFileName = "CONFIG.txt";
  String fieldSubStringHead;
 80a09ca:	a810      	add	r0, sp, #64	; 0x40
 80a09cc:	f002 fe1a 	bl	80a3604 <_ZN6StringD1Ev>
  int j = 5;
  int n = 0;  //number of characters read
  int i = 0;
  int tempLogItems = 0;
  unsigned int wIndex;
  String configTxtFileName = "CONFIG.txt";
 80a09d0:	a80c      	add	r0, sp, #48	; 0x30
 80a09d2:	f002 fe17 	bl	80a3604 <_ZN6StringD1Ev>
void initSDcard(void){
  SdFile::dateTimeCallback(dateTime); //make files on SD card have correct creation date/time
  String fieldString;
  char fileLineChars[200];
  String fileLine;
  String tempUserString;
 80a09d6:	a808      	add	r0, sp, #32
 80a09d8:	f002 fe14 	bl	80a3604 <_ZN6StringD1Ev>

void initSDcard(void){
  SdFile::dateTimeCallback(dateTime); //make files on SD card have correct creation date/time
  String fieldString;
  char fileLineChars[200];
  String fileLine;
 80a09dc:	a804      	add	r0, sp, #16
 80a09de:	f002 fe11 	bl	80a3604 <_ZN6StringD1Ev>
  *time = FAT_TIME(Time.hour(), Time.minute(), Time.second());
}//------------------------------------------------------------------------------

void initSDcard(void){
  SdFile::dateTimeCallback(dateTime); //make files on SD card have correct creation date/time
  String fieldString;
 80a09e2:	4668      	mov	r0, sp
 80a09e4:	f002 fe0e 	bl	80a3604 <_ZN6StringD1Ev>
      i = 0;
    }
  }
  */
  //Serial.print(fieldSubStringValue);
}
 80a09e8:	b01c      	add	sp, #112	; 0x70
 80a09ea:	bd70      	pop	{r4, r5, r6, pc}
 80a09ec:	080a0773 	.word	0x080a0773
 80a09f0:	20000af8 	.word	0x20000af8
 80a09f4:	080a5a06 	.word	0x080a5a06
 80a09f8:	080a58fb 	.word	0x080a58fb
 80a09fc:	20000500 	.word	0x20000500
 80a0a00:	080a5880 	.word	0x080a5880
 80a0a04:	20000518 	.word	0x20000518
 80a0a08:	003d0900 	.word	0x003d0900
 80a0a0c:	20000af4 	.word	0x20000af4
 80a0a10:	200004d0 	.word	0x200004d0

080a0a14 <_GLOBAL__sub_I_sd>:
  }
  else if (eSDTimer < NUM_SD_TIMERS)
  {
    SetTimerWithMilliseconds(&scastSDtimers[eSDTimer], scawSDtimers[eSDTimer]);
  }
}
 80a0a14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0a16:	f002 fab1 	bl	80a2f7c <HAL_Pin_Map>
 */
class FatVolume {
 public:
  /** Create an instance of FatVolume
   */
  FatVolume() : m_fatType(0) {}
 80a0a1a:	4b2d      	ldr	r3, [pc, #180]	; (80a0ad0 <_GLOBAL__sub_I_sd+0xbc>)
#else  // ENABLE_EXTENDED_TRANSFER_CLASS || ENABLE_SDIO_CLASS
class SdSpiCard {
#endif  // ENABLE_EXTENDED_TRANSFER_CLASS || ENABLE_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() : m_errorCode(SD_CARD_ERROR_INIT_NOT_CALLED), m_type(0) {}
 80a0a1c:	2264      	movs	r2, #100	; 0x64
 80a0a1e:	f883 2460 	strb.w	r2, [r3, #1120]	; 0x460
      dataMode_{dataMode}
  {
  }

  __SPISettings()
  {
 80a0a22:	4a2c      	ldr	r2, [pc, #176]	; (80a0ad4 <_GLOBAL__sub_I_sd+0xc0>)
//#include "DeltaQ_CANopen.h"

//SD file declarations-----------------------------------
SdFat sd;
const uint8_t chipSelect = SS;
SdFile myFile;
 80a0a24:	4d2c      	ldr	r5, [pc, #176]	; (80a0ad8 <_GLOBAL__sub_I_sd+0xc4>)
 80a0a26:	f8c3 2470 	str.w	r2, [r3, #1136]	; 0x470
 80a0a2a:	2201      	movs	r2, #1
 80a0a2c:	f883 2474 	strb.w	r2, [r3, #1140]	; 0x474
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
 80a0a30:	482a      	ldr	r0, [pc, #168]	; (80a0adc <_GLOBAL__sub_I_sd+0xc8>)
 80a0a32:	4e2b      	ldr	r6, [pc, #172]	; (80a0ae0 <_GLOBAL__sub_I_sd+0xcc>)
#if IMPLEMENT_SPI_PORT_SELECTION || defined(DOXYGEN)
  /** Set SPI port number.
   * \param[in] spiPort Hardware SPI port.
   */
  void setPort(SPIClass* spiPort) {
    m_spi = spiPort ? spiPort : &SDCARD_SPI;
 80a0a34:	4a2b      	ldr	r2, [pc, #172]	; (80a0ae4 <_GLOBAL__sub_I_sd+0xd0>)
 80a0a36:	2400      	movs	r4, #0
 * \class SdFile
 * \brief Class for backward compatibility.
 */
class SdFile : public PrintFile {
 public:
  SdFile() {}
 80a0a38:	4f2b      	ldr	r7, [pc, #172]	; (80a0ae8 <_GLOBAL__sub_I_sd+0xd4>)
 80a0a3a:	71dc      	strb	r4, [r3, #7]
 80a0a3c:	f883 443c 	strb.w	r4, [r3, #1084]	; 0x43c
 80a0a40:	f883 443d 	strb.w	r4, [r3, #1085]	; 0x43d
 80a0a44:	f883 446a 	strb.w	r4, [r3, #1130]	; 0x46a
 80a0a48:	f8c3 4478 	str.w	r4, [r3, #1144]	; 0x478
 80a0a4c:	f883 447c 	strb.w	r4, [r3, #1148]	; 0x47c
 80a0a50:	f883 447d 	strb.w	r4, [r3, #1149]	; 0x47d
 80a0a54:	f8c3 246c 	str.w	r2, [r3, #1132]	; 0x46c
 80a0a58:	4631      	mov	r1, r6
 80a0a5a:	462a      	mov	r2, r5
 80a0a5c:	7204      	strb	r4, [r0, #8]
 80a0a5e:	7244      	strb	r4, [r0, #9]
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a0a60:	6044      	str	r4, [r0, #4]
 80a0a62:	6007      	str	r7, [r0, #0]
 80a0a64:	f003 fb2c 	bl	80a40c0 <__aeabi_atexit>
 80a0a68:	4820      	ldr	r0, [pc, #128]	; (80a0aec <_GLOBAL__sub_I_sd+0xd8>)
SdFile readFramesFile;
 80a0a6a:	462a      	mov	r2, r5
 80a0a6c:	4631      	mov	r1, r6
 80a0a6e:	7204      	strb	r4, [r0, #8]
 80a0a70:	7244      	strb	r4, [r0, #9]
 80a0a72:	6044      	str	r4, [r0, #4]
 80a0a74:	6007      	str	r7, [r0, #0]
 80a0a76:	f003 fb23 	bl	80a40c0 <__aeabi_atexit>
 80a0a7a:	481d      	ldr	r0, [pc, #116]	; (80a0af0 <_GLOBAL__sub_I_sd+0xdc>)
SdFile readConfigTxtFile;
 80a0a7c:	4631      	mov	r1, r6
 80a0a7e:	6007      	str	r7, [r0, #0]
int SDcardInitOK = 0;
String strFileName;
 80a0a80:	4e1c      	ldr	r6, [pc, #112]	; (80a0af4 <_GLOBAL__sub_I_sd+0xe0>)
 80a0a82:	4f1d      	ldr	r7, [pc, #116]	; (80a0af8 <_GLOBAL__sub_I_sd+0xe4>)
//SD file declarations-----------------------------------
SdFat sd;
const uint8_t chipSelect = SS;
SdFile myFile;
SdFile readFramesFile;
SdFile readConfigTxtFile;
 80a0a84:	462a      	mov	r2, r5
 80a0a86:	7204      	strb	r4, [r0, #8]
 80a0a88:	7244      	strb	r4, [r0, #9]
 80a0a8a:	6044      	str	r4, [r0, #4]
 80a0a8c:	f003 fb18 	bl	80a40c0 <__aeabi_atexit>
int SDcardInitOK = 0;
String strFileName;
 80a0a90:	4c1a      	ldr	r4, [pc, #104]	; (80a0afc <_GLOBAL__sub_I_sd+0xe8>)
 80a0a92:	4631      	mov	r1, r6
 80a0a94:	4638      	mov	r0, r7
 80a0a96:	f002 fdfc 	bl	80a3692 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0a9a:	4638      	mov	r0, r7
int frameDelaySec = 0;
int frameDelaymSec = 100;
String strReadFileName;
 80a0a9c:	4f18      	ldr	r7, [pc, #96]	; (80a0b00 <_GLOBAL__sub_I_sd+0xec>)
const uint8_t chipSelect = SS;
SdFile myFile;
SdFile readFramesFile;
SdFile readConfigTxtFile;
int SDcardInitOK = 0;
String strFileName;
 80a0a9e:	462a      	mov	r2, r5
 80a0aa0:	4621      	mov	r1, r4
 80a0aa2:	f003 fb0d 	bl	80a40c0 <__aeabi_atexit>
int frameDelaySec = 0;
int frameDelaymSec = 100;
String strReadFileName;
 80a0aa6:	4631      	mov	r1, r6
 80a0aa8:	4638      	mov	r0, r7
 80a0aaa:	f002 fdf2 	bl	80a3692 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0aae:	4638      	mov	r0, r7
int attemptedOpen = 0;
int frameNumber = 0;
String logFileHeader = "";
 80a0ab0:	4f14      	ldr	r7, [pc, #80]	; (80a0b04 <_GLOBAL__sub_I_sd+0xf0>)
SdFile readConfigTxtFile;
int SDcardInitOK = 0;
String strFileName;
int frameDelaySec = 0;
int frameDelaymSec = 100;
String strReadFileName;
 80a0ab2:	462a      	mov	r2, r5
 80a0ab4:	4621      	mov	r1, r4
 80a0ab6:	f003 fb03 	bl	80a40c0 <__aeabi_atexit>
int attemptedOpen = 0;
int frameNumber = 0;
String logFileHeader = "";
 80a0aba:	4631      	mov	r1, r6
 80a0abc:	4638      	mov	r0, r7
 80a0abe:	f002 fde8 	bl	80a3692 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0ac2:	462a      	mov	r2, r5
 80a0ac4:	4621      	mov	r1, r4
 80a0ac6:	4638      	mov	r0, r7
  }
  else if (eSDTimer < NUM_SD_TIMERS)
  {
    SetTimerWithMilliseconds(&scastSDtimers[eSDTimer], scawSDtimers[eSDTimer]);
  }
}
 80a0ac8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
int frameDelaySec = 0;
int frameDelaymSec = 100;
String strReadFileName;
int attemptedOpen = 0;
int frameNumber = 0;
String logFileHeader = "";
 80a0acc:	f003 baf8 	b.w	80a40c0 <__aeabi_atexit>
 80a0ad0:	20000518 	.word	0x20000518
 80a0ad4:	080a5880 	.word	0x080a5880
 80a0ad8:	200003c0 	.word	0x200003c0
 80a0adc:	20000474 	.word	0x20000474
 80a0ae0:	080a0771 	.word	0x080a0771
 80a0ae4:	20000fd4 	.word	0x20000fd4
 80a0ae8:	080a588c 	.word	0x080a588c
 80a0aec:	20000448 	.word	0x20000448
 80a0af0:	200004d4 	.word	0x200004d4
 80a0af4:	080a5a06 	.word	0x080a5a06
 80a0af8:	200004b0 	.word	0x200004b0
 80a0afc:	080a3605 	.word	0x080a3605
 80a0b00:	200004c0 	.word	0x200004c0
 80a0b04:	200004a0 	.word	0x200004a0

080a0b08 <_Z9TasksInitv>:
 80a0b08:	4770      	bx	lr

080a0b0a <_Z8Tasks5msv>:
    //dispBatteryHeading();
    //initSD(BMS_LOG_MASK);
}

void Tasks5ms(){
  UpdateTimers();
 80a0b0a:	f000 b923 	b.w	80a0d54 <_Z12UpdateTimersv>

080a0b0e <_Z9Tasks10msv>:
 80a0b0e:	4770      	bx	lr

080a0b10 <_Z9Tasks20msv>:
 80a0b10:	4770      	bx	lr
	...

080a0b14 <_Z9Tasks40msv>:
void Tasks20ms(){
  //Serial.printf("%d\n",(millis()-lastTime));
  //lastTime = millis();
}

void Tasks40ms(){
 80a0b14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    static int intervalCounter = 0;
    //String battTypeString;    ///debug only

    OneSecCounter++;
    TwoSecCounter++;
    FiveSecCounter++;
 80a0b16:	481c      	ldr	r0, [pc, #112]	; (80a0b88 <_Z9Tasks40msv+0x74>)

void Tasks40ms(){
    static int intervalCounter = 0;
    //String battTypeString;    ///debug only

    OneSecCounter++;
 80a0b18:	4f1c      	ldr	r7, [pc, #112]	; (80a0b8c <_Z9Tasks40msv+0x78>)
    TwoSecCounter++;
    FiveSecCounter++;
 80a0b1a:	6801      	ldr	r1, [r0, #0]
void Tasks40ms(){
    static int intervalCounter = 0;
    //String battTypeString;    ///debug only

    OneSecCounter++;
    TwoSecCounter++;
 80a0b1c:	4c1c      	ldr	r4, [pc, #112]	; (80a0b90 <_Z9Tasks40msv+0x7c>)

void Tasks40ms(){
    static int intervalCounter = 0;
    //String battTypeString;    ///debug only

    OneSecCounter++;
 80a0b1e:	683a      	ldr	r2, [r7, #0]
    TwoSecCounter++;
    FiveSecCounter++;
 80a0b20:	3101      	adds	r1, #1
 80a0b22:	6001      	str	r1, [r0, #0]
    FifteenSecCounter++;
 80a0b24:	491b      	ldr	r1, [pc, #108]	; (80a0b94 <_Z9Tasks40msv+0x80>)

void Tasks40ms(){
    static int intervalCounter = 0;
    //String battTypeString;    ///debug only

    OneSecCounter++;
 80a0b26:	3201      	adds	r2, #1
    TwoSecCounter++;
 80a0b28:	6823      	ldr	r3, [r4, #0]
    FiveSecCounter++;
    FifteenSecCounter++;

    if (OneSecCounter >= ONESECCOUNT){    ///////----ONE SECOND TIMER
 80a0b2a:	2a18      	cmp	r2, #24
    //String battTypeString;    ///debug only

    OneSecCounter++;
    TwoSecCounter++;
    FiveSecCounter++;
    FifteenSecCounter++;
 80a0b2c:	680d      	ldr	r5, [r1, #0]

void Tasks40ms(){
    static int intervalCounter = 0;
    //String battTypeString;    ///debug only

    OneSecCounter++;
 80a0b2e:	603a      	str	r2, [r7, #0]
    TwoSecCounter++;
 80a0b30:	f103 0301 	add.w	r3, r3, #1
    FiveSecCounter++;
    FifteenSecCounter++;

    if (OneSecCounter >= ONESECCOUNT){    ///////----ONE SECOND TIMER
      //put 1 Second tasks here
      OneSecCounter = 0;
 80a0b34:	bfc8      	it	gt
 80a0b36:	2200      	movgt	r2, #0
    //String battTypeString;    ///debug only

    OneSecCounter++;
    TwoSecCounter++;
    FiveSecCounter++;
    FifteenSecCounter++;
 80a0b38:	f105 0501 	add.w	r5, r5, #1

    if (OneSecCounter >= ONESECCOUNT){    ///////----ONE SECOND TIMER
      //put 1 Second tasks here
      OneSecCounter = 0;
 80a0b3c:	bfc8      	it	gt
 80a0b3e:	603a      	strgt	r2, [r7, #0]
      //toggleLED();    //toggle heartbeat LED
    }
    if (TwoSecCounter >= TWOSECCOUNT){   ////////---TWO SECOND TIMER
 80a0b40:	2b31      	cmp	r3, #49	; 0x31
void Tasks40ms(){
    static int intervalCounter = 0;
    //String battTypeString;    ///debug only

    OneSecCounter++;
    TwoSecCounter++;
 80a0b42:	6023      	str	r3, [r4, #0]
    FiveSecCounter++;
    FifteenSecCounter++;
 80a0b44:	600d      	str	r5, [r1, #0]
 80a0b46:	4626      	mov	r6, r4
 80a0b48:	4605      	mov	r5, r0
 80a0b4a:	460c      	mov	r4, r1
    if (OneSecCounter >= ONESECCOUNT){    ///////----ONE SECOND TIMER
      //put 1 Second tasks here
      OneSecCounter = 0;
      //toggleLED();    //toggle heartbeat LED
    }
    if (TwoSecCounter >= TWOSECCOUNT){   ////////---TWO SECOND TIMER
 80a0b4c:	dd0e      	ble.n	80a0b6c <_Z9Tasks40msv+0x58>
      //put 2 second tasks here
      if ((onceThrough == 0)){
 80a0b4e:	4f12      	ldr	r7, [pc, #72]	; (80a0b98 <_Z9Tasks40msv+0x84>)
 80a0b50:	683b      	ldr	r3, [r7, #0]
 80a0b52:	b94b      	cbnz	r3, 80a0b68 <_Z9Tasks40msv+0x54>
        initSDcard();
 80a0b54:	f7ff fed2 	bl	80a08fc <_Z10initSDcardv>
        openReadWriteFiles(what2logTxt);
 80a0b58:	4b10      	ldr	r3, [pc, #64]	; (80a0b9c <_Z9Tasks40msv+0x88>)
 80a0b5a:	6818      	ldr	r0, [r3, #0]
 80a0b5c:	f7ff fe98 	bl	80a0890 <_Z18openReadWriteFilesi>
        initCAN();
 80a0b60:	f000 f882 	bl	80a0c68 <_Z7initCANv>
        //initDisplay(TWOFORTY_BY_THREETWENTY_SERIAL);  //THREEPOINTTWO_INCH_NEXTION
        //Log2SD(TEST_SUPERVISOR_LOG_MASK);
        //initNetwork();
        //dispBatteryHeading();
        //Serial.println("onceThrough = 0");
        onceThrough = 1;
 80a0b64:	2301      	movs	r3, #1
 80a0b66:	603b      	str	r3, [r7, #0]
      }
      //else {Serial.println("onceThrough = 1");}

      TwoSecCounter = 0;
 80a0b68:	2300      	movs	r3, #0
 80a0b6a:	6033      	str	r3, [r6, #0]
    }
    if (FiveSecCounter >= FIVESECCOUNT){   //////----FIVE SECOND TIMER
 80a0b6c:	682b      	ldr	r3, [r5, #0]
 80a0b6e:	2b7c      	cmp	r3, #124	; 0x7c
      //put 5 Second tasks here
      //Serial.printf("millis: %d\n",(millis()-lastTime));
      //lastTime = millis();
      FiveSecCounter = 0;
 80a0b70:	bfc2      	ittt	gt
 80a0b72:	4b05      	ldrgt	r3, [pc, #20]	; (80a0b88 <_Z9Tasks40msv+0x74>)
 80a0b74:	2200      	movgt	r2, #0
 80a0b76:	601a      	strgt	r2, [r3, #0]
    }
    if (FifteenSecCounter >= FIFTEENSECCOUNT){   //////----FIFTEEN SECOND TIMER
 80a0b78:	6823      	ldr	r3, [r4, #0]
 80a0b7a:	f5b3 7fbb 	cmp.w	r3, #374	; 0x176
        Particle.publish("SOC", battSOC2String, PRIVATE);
        intervalCounter = 0;
      }
      intervalCounter++; 
      */
      FifteenSecCounter = 0;
 80a0b7e:	bfc2      	ittt	gt
 80a0b80:	4b04      	ldrgt	r3, [pc, #16]	; (80a0b94 <_Z9Tasks40msv+0x80>)
 80a0b82:	2200      	movgt	r2, #0
 80a0b84:	601a      	strgt	r2, [r3, #0]
 80a0b86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a0b88:	200009a4 	.word	0x200009a4
 80a0b8c:	2000099c 	.word	0x2000099c
 80a0b90:	200009a0 	.word	0x200009a0
 80a0b94:	200009a8 	.word	0x200009a8
 80a0b98:	200003d4 	.word	0x200003d4
 80a0b9c:	200003cc 	.word	0x200003cc

080a0ba0 <_Z9Tasks80msv>:
 80a0ba0:	4770      	bx	lr

080a0ba2 <_Z10Tasks160msv>:
 80a0ba2:	4770      	bx	lr

080a0ba4 <_Z10Tasks320msv>:
 80a0ba4:	4770      	bx	lr

080a0ba6 <_Z10Tasks640msv>:
 80a0ba6:	4770      	bx	lr

080a0ba8 <_Z11Tasks1280msv>:
void Tasks640ms(){
  //Particle.process();
  //checkNetwork();
}

void Tasks1280ms(){
 80a0ba8:	4770      	bx	lr

080a0baa <_GLOBAL__sub_I_OneSecCounter>:
 80a0baa:	f002 b9e7 	b.w	80a2f7c <HAL_Pin_Map>
	...

080a0bb0 <_Z16ResetGatwayTimer14GATEWAY_TIMERS>:



void ResetGatwayTimer(GATEWAY_TIMERS eGatewayTimer)
{
  if (eGatewayTimer < NUM_GATEWAY_TIMERS)
 80a0bb0:	2806      	cmp	r0, #6
 80a0bb2:	d807      	bhi.n	80a0bc4 <_Z16ResetGatwayTimer14GATEWAY_TIMERS+0x14>
  {
    SetTimerWithMilliseconds(&scastGatewayTimers[eGatewayTimer], scawGatewayTimers[eGatewayTimer]);
 80a0bb4:	4b04      	ldr	r3, [pc, #16]	; (80a0bc8 <_Z16ResetGatwayTimer14GATEWAY_TIMERS+0x18>)
 80a0bb6:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 80a0bba:	4b04      	ldr	r3, [pc, #16]	; (80a0bcc <_Z16ResetGatwayTimer14GATEWAY_TIMERS+0x1c>)
 80a0bbc:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 80a0bc0:	f000 b8de 	b.w	80a0d80 <_Z24SetTimerWithMillisecondsP16TICK_TIMER_S_TAGj>
 80a0bc4:	4770      	bx	lr
 80a0bc6:	bf00      	nop
 80a0bc8:	080a5914 	.word	0x080a5914
 80a0bcc:	200009ac 	.word	0x200009ac

080a0bd0 <_Z11initGatewayv>:

static TICK_TIMER_S scastGatewayTimers[NUM_GATEWAY_TIMERS];

void ResetGatwayTimer(GATEWAY_TIMERS eGatewayTimer);

void initGateway(void){
 80a0bd0:	b538      	push	{r3, r4, r5, lr}
    unsigned int wIndex;
    for (wIndex = 0; wIndex < ((unsigned int)NUM_GATEWAY_TIMERS); wIndex++)
    {
        RegisterTimer(&scastGatewayTimers[wIndex]);
 80a0bd2:	4d08      	ldr	r5, [pc, #32]	; (80a0bf4 <_Z11initGatewayv+0x24>)

void ResetGatwayTimer(GATEWAY_TIMERS eGatewayTimer);

void initGateway(void){
    unsigned int wIndex;
    for (wIndex = 0; wIndex < ((unsigned int)NUM_GATEWAY_TIMERS); wIndex++)
 80a0bd4:	2400      	movs	r4, #0
    {
        RegisterTimer(&scastGatewayTimers[wIndex]);
 80a0bd6:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 80a0bda:	f000 f8a7 	bl	80a0d2c <_Z13RegisterTimerP16TICK_TIMER_S_TAG>
        ResetGatwayTimer((GATEWAY_TIMERS)wIndex);
 80a0bde:	b2e0      	uxtb	r0, r4

void ResetGatwayTimer(GATEWAY_TIMERS eGatewayTimer);

void initGateway(void){
    unsigned int wIndex;
    for (wIndex = 0; wIndex < ((unsigned int)NUM_GATEWAY_TIMERS); wIndex++)
 80a0be0:	3401      	adds	r4, #1
    {
        RegisterTimer(&scastGatewayTimers[wIndex]);
        ResetGatwayTimer((GATEWAY_TIMERS)wIndex);
 80a0be2:	f7ff ffe5 	bl	80a0bb0 <_Z16ResetGatwayTimer14GATEWAY_TIMERS>

void ResetGatwayTimer(GATEWAY_TIMERS eGatewayTimer);

void initGateway(void){
    unsigned int wIndex;
    for (wIndex = 0; wIndex < ((unsigned int)NUM_GATEWAY_TIMERS); wIndex++)
 80a0be6:	2c07      	cmp	r4, #7
 80a0be8:	d1f5      	bne.n	80a0bd6 <_Z11initGatewayv+0x6>
        RegisterTimer(&scastGatewayTimers[wIndex]);
        ResetGatwayTimer((GATEWAY_TIMERS)wIndex);
    }
    initSerialElLoad();

}
 80a0bea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    for (wIndex = 0; wIndex < ((unsigned int)NUM_GATEWAY_TIMERS); wIndex++)
    {
        RegisterTimer(&scastGatewayTimers[wIndex]);
        ResetGatwayTimer((GATEWAY_TIMERS)wIndex);
    }
    initSerialElLoad();
 80a0bee:	f000 b815 	b.w	80a0c1c <_Z16initSerialElLoadv>
 80a0bf2:	bf00      	nop
 80a0bf4:	200009ac 	.word	0x200009ac

080a0bf8 <_GLOBAL__sub_I_testRoutineSource>:
 80a0bf8:	f002 b9c0 	b.w	80a2f7c <HAL_Pin_Map>

080a0bfc <_Z16ResetElLoadTimer13ELLOAD_TIMERS>:
  //Serial.printf("POW %d\n",powerLevel);
}

void ResetElLoadTimer(ELLOAD_TIMERS eElLoadTimer)
{
  if (eElLoadTimer < NUM_ELLOAD_TIMERS)
 80a0bfc:	2801      	cmp	r0, #1
 80a0bfe:	d807      	bhi.n	80a0c10 <_Z16ResetElLoadTimer13ELLOAD_TIMERS+0x14>
  {
    SetTimerWithMilliseconds(&scastElLoadTimers[eElLoadTimer], scawElLoadTimers[eElLoadTimer]);
 80a0c00:	4b04      	ldr	r3, [pc, #16]	; (80a0c14 <_Z16ResetElLoadTimer13ELLOAD_TIMERS+0x18>)
 80a0c02:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 80a0c06:	4b04      	ldr	r3, [pc, #16]	; (80a0c18 <_Z16ResetElLoadTimer13ELLOAD_TIMERS+0x1c>)
 80a0c08:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 80a0c0c:	f000 b8b8 	b.w	80a0d80 <_Z24SetTimerWithMillisecondsP16TICK_TIMER_S_TAGj>
 80a0c10:	4770      	bx	lr
 80a0c12:	bf00      	nop
 80a0c14:	080a5930 	.word	0x080a5930
 80a0c18:	200009ec 	.word	0x200009ec

080a0c1c <_Z16initSerialElLoadv>:
};

static TICK_TIMER_S scastElLoadTimers[NUM_ELLOAD_TIMERS];


void initSerialElLoad(void){
 80a0c1c:	b510      	push	{r4, lr}

  Serial1.begin(9600, SERIAL_8N1);

  for (wIndex = 0; wIndex < ((unsigned int)NUM_ELLOAD_TIMERS); wIndex++)
  {
    RegisterTimer(&scastElLoadTimers[wIndex]);
 80a0c1e:	4c0e      	ldr	r4, [pc, #56]	; (80a0c58 <_Z16initSerialElLoadv+0x3c>)


void initSerialElLoad(void){
  unsigned int wIndex;

  Serial1.begin(9600, SERIAL_8N1);
 80a0c20:	f003 f8fc 	bl	80a3e1c <_Z22__fetch_global_Serial1v>
 80a0c24:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a0c28:	2200      	movs	r2, #0
 80a0c2a:	f003 f8ed 	bl	80a3e08 <_ZN11USARTSerial5beginEmm>

  for (wIndex = 0; wIndex < ((unsigned int)NUM_ELLOAD_TIMERS); wIndex++)
  {
    RegisterTimer(&scastElLoadTimers[wIndex]);
 80a0c2e:	4620      	mov	r0, r4
 80a0c30:	f000 f87c 	bl	80a0d2c <_Z13RegisterTimerP16TICK_TIMER_S_TAG>
    ResetElLoadTimer((ELLOAD_TIMERS)wIndex);
 80a0c34:	2000      	movs	r0, #0
 80a0c36:	f7ff ffe1 	bl	80a0bfc <_Z16ResetElLoadTimer13ELLOAD_TIMERS>

  Serial1.begin(9600, SERIAL_8N1);

  for (wIndex = 0; wIndex < ((unsigned int)NUM_ELLOAD_TIMERS); wIndex++)
  {
    RegisterTimer(&scastElLoadTimers[wIndex]);
 80a0c3a:	f104 0008 	add.w	r0, r4, #8
 80a0c3e:	f000 f875 	bl	80a0d2c <_Z13RegisterTimerP16TICK_TIMER_S_TAG>
    ResetElLoadTimer((ELLOAD_TIMERS)wIndex);
 80a0c42:	2001      	movs	r0, #1
 80a0c44:	f7ff ffda 	bl	80a0bfc <_Z16ResetElLoadTimer13ELLOAD_TIMERS>
  }

  Serial1.println("");
 80a0c48:	f003 f8e8 	bl	80a3e1c <_Z22__fetch_global_Serial1v>
}
 80a0c4c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  {
    RegisterTimer(&scastElLoadTimers[wIndex]);
    ResetElLoadTimer((ELLOAD_TIMERS)wIndex);
  }

  Serial1.println("");
 80a0c50:	4902      	ldr	r1, [pc, #8]	; (80a0c5c <_Z16initSerialElLoadv+0x40>)
 80a0c52:	f002 bd85 	b.w	80a3760 <_ZN5Print7printlnEPKc>
 80a0c56:	bf00      	nop
 80a0c58:	200009ec 	.word	0x200009ec
 80a0c5c:	080a5a06 	.word	0x080a5a06

080a0c60 <_GLOBAL__sub_I__Z16initSerialElLoadv>:
 80a0c60:	f002 b98c 	b.w	80a2f7c <HAL_Pin_Map>

080a0c64 <_ZN7CarloopI16CarloopRevision2ED1Ev>:

    static constexpr auto FEATURES = CARLOOP_CAN | CARLOOP_GPS | CARLOOP_BATTERY;
};

template <typename Config>
class Carloop
 80a0c64:	4770      	bx	lr
	...

080a0c68 <_Z7initCANv>:
#include <carloop.h>

Carloop<CarloopRevision2> carloop;

//-----------------INITIALIZE CANBUS---------------------------------------
void initCAN(void){
 80a0c68:	b510      	push	{r4, lr}
    //setup CANbus interface
    carloop.begin(CARLOOP_CAN);
 80a0c6a:	4c08      	ldr	r4, [pc, #32]	; (80a0c8c <_Z7initCANv+0x24>)
 80a0c6c:	2101      	movs	r1, #1
 80a0c6e:	4620      	mov	r0, r4
 80a0c70:	f000 f99f 	bl	80a0fb2 <_ZN7CarloopI16CarloopRevision2E5beginE17CarloopFeatures_e>
    
    carloop.setCANSpeed(GATEWAY_BAUD);        //must set can speed before enabling bus!
 80a0c74:	4620      	mov	r0, r4
 80a0c76:	4906      	ldr	r1, [pc, #24]	; (80a0c90 <_Z7initCANv+0x28>)
 80a0c78:	f000 f926 	bl	80a0ec8 <_ZN7CarloopI16CarloopRevision2E11setCANSpeedEm>
    initGateway();
 80a0c7c:	f7ff ffa8 	bl	80a0bd0 <_Z11initGatewayv>
    
    carloop.enableCAN();                        //enable canbus
 80a0c80:	4620      	mov	r0, r4
}
 80a0c82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    carloop.begin(CARLOOP_CAN);
    
    carloop.setCANSpeed(GATEWAY_BAUD);        //must set can speed before enabling bus!
    initGateway();
    
    carloop.enableCAN();                        //enable canbus
 80a0c86:	f000 b922 	b.w	80a0ece <_ZN7CarloopI16CarloopRevision2E9enableCANEv>
 80a0c8a:	bf00      	nop
 80a0c8c:	200009fc 	.word	0x200009fc
 80a0c90:	0003d090 	.word	0x0003d090

080a0c94 <_GLOBAL__sub_I_carloop>:
}
 80a0c94:	b510      	push	{r4, lr}
#include "defines.h"
#include "Globals.h"
#include "Gateway.h"
#include <carloop.h>

Carloop<CarloopRevision2> carloop;
 80a0c96:	4c06      	ldr	r4, [pc, #24]	; (80a0cb0 <_GLOBAL__sub_I_carloop+0x1c>)
 80a0c98:	f002 f970 	bl	80a2f7c <HAL_Pin_Map>
 80a0c9c:	4620      	mov	r0, r4
 80a0c9e:	f000 f8ff 	bl	80a0ea0 <_ZN7CarloopI16CarloopRevision2EC1Ev>
 80a0ca2:	4620      	mov	r0, r4
    
    carloop.setCANSpeed(GATEWAY_BAUD);        //must set can speed before enabling bus!
    initGateway();
    
    carloop.enableCAN();                        //enable canbus
}
 80a0ca4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#include "defines.h"
#include "Globals.h"
#include "Gateway.h"
#include <carloop.h>

Carloop<CarloopRevision2> carloop;
 80a0ca8:	4a02      	ldr	r2, [pc, #8]	; (80a0cb4 <_GLOBAL__sub_I_carloop+0x20>)
 80a0caa:	4903      	ldr	r1, [pc, #12]	; (80a0cb8 <_GLOBAL__sub_I_carloop+0x24>)
 80a0cac:	f003 ba08 	b.w	80a40c0 <__aeabi_atexit>
 80a0cb0:	200009fc 	.word	0x200009fc
 80a0cb4:	200003c0 	.word	0x200003c0
 80a0cb8:	080a0c65 	.word	0x080a0c65

080a0cbc <_GLOBAL__sub_I_ReadSDCard.cpp>:
 80a0cbc:	f002 b95e 	b.w	80a2f7c <HAL_Pin_Map>

080a0cc0 <_Z17canReceiveMessagev>:
int msgRec = 1;

extern Carloop<CarloopRevision2> carloop;

//-------------SERVICE NEW CAN MESSAGES-------------------------------------
int canReceiveMessage(){
 80a0cc0:	b5f0      	push	{r4, r5, r6, r7, lr}
     : id { 0 },
       size { sizeof(CANMessage) },
       extended { false },
       rtr { false },
       len { 0 },
       data { 0 }
 80a0cc2:	2300      	movs	r3, #0
 80a0cc4:	b085      	sub	sp, #20
 80a0cc6:	2210      	movs	r2, #16
 80a0cc8:	9300      	str	r3, [sp, #0]
 80a0cca:	f88d 3005 	strb.w	r3, [sp, #5]
 80a0cce:	f88d 3006 	strb.w	r3, [sp, #6]
 80a0cd2:	f88d 3007 	strb.w	r3, [sp, #7]
 80a0cd6:	9302      	str	r3, [sp, #8]
 80a0cd8:	9303      	str	r3, [sp, #12]
 80a0cda:	f88d 2004 	strb.w	r2, [sp, #4]
  CANMessage message;
  int tempBitwise = 0;
  int tempBitwise2 = 0;
  static int timePrevMsg = 0;
  int timeNow = Time.now();
 80a0cde:	f002 fe22 	bl	80a3926 <_ZN9TimeClass3nowEv>

  if(timePrevMsg == 0){
 80a0ce2:	4c0e      	ldr	r4, [pc, #56]	; (80a0d1c <_Z17canReceiveMessagev+0x5c>)
int canReceiveMessage(){
  CANMessage message;
  int tempBitwise = 0;
  int tempBitwise2 = 0;
  static int timePrevMsg = 0;
  int timeNow = Time.now();
 80a0ce4:	4606      	mov	r6, r0

  if(timePrevMsg == 0){
 80a0ce6:	6823      	ldr	r3, [r4, #0]
 80a0ce8:	b903      	cbnz	r3, 80a0cec <_Z17canReceiveMessagev+0x2c>
      timePrevMsg = timeNow;
 80a0cea:	6020      	str	r0, [r4, #0]
  }

  if(carloop.can().receive(message)){  //if new can message received, decode and reset counter
 80a0cec:	480c      	ldr	r0, [pc, #48]	; (80a0d20 <_Z17canReceiveMessagev+0x60>)
 80a0cee:	f000 f8ed 	bl	80a0ecc <_ZN7CarloopI16CarloopRevision2E3canEv>
 80a0cf2:	4669      	mov	r1, sp
 80a0cf4:	f003 f909 	bl	80a3f0a <_ZN10CANChannel7receiveER10CANMessage>
 80a0cf8:	4f0a      	ldr	r7, [pc, #40]	; (80a0d24 <_Z17canReceiveMessagev+0x64>)
 80a0cfa:	b130      	cbz	r0, 80a0d0a <_Z17canReceiveMessagev+0x4a>
    msgRec = 1;
 80a0cfc:	2301      	movs	r3, #1
 80a0cfe:	603b      	str	r3, [r7, #0]
      recCumminsStatus(message);
    } */
    //receiveMessagesTraction();  //DECODE TRACTION MESSAGES
    //receiveMessagesVCU();       //DECODE VCU MESSAGES

    receiveGatewayMesages(message);
 80a0d00:	e89d 000f 	ldmia.w	sp, {r0, r1, r2, r3}
 80a0d04:	f7ff fb46 	bl	80a0394 <_Z21receiveGatewayMesages10CANMessage>
 80a0d08:	e004      	b.n	80a0d14 <_Z17canReceiveMessagev+0x54>

  }
  else{
    if ((timeNow - timePrevMsg) > CAN_LOST_TIME){ //if more than CAN_LOST_TIME seconds has elapsed since last message
 80a0d0a:	6823      	ldr	r3, [r4, #0]
 80a0d0c:	1af6      	subs	r6, r6, r3
 80a0d0e:	2e05      	cmp	r6, #5
      msgRec = 0;
 80a0d10:	bfc8      	it	gt
 80a0d12:	6038      	strgt	r0, [r7, #0]
    }
  }
  return msgRec;
}
 80a0d14:	6838      	ldr	r0, [r7, #0]
 80a0d16:	b005      	add	sp, #20
 80a0d18:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a0d1a:	bf00      	nop
 80a0d1c:	20000aec 	.word	0x20000aec
 80a0d20:	200009fc 	.word	0x200009fc
 80a0d24:	20000304 	.word	0x20000304

080a0d28 <_GLOBAL__sub_I_msgRec>:
 80a0d28:	f002 b928 	b.w	80a2f7c <HAL_Pin_Map>

080a0d2c <_Z13RegisterTimerP16TICK_TIMER_S_TAG>:
}

void RegisterTimer(TICK_TIMER_S * pstTimer)
{
  TICK_TIMER_S * pstCurrentTimer;
  if (scpstHeadTimer == NULL)
 80a0d2c:	4a08      	ldr	r2, [pc, #32]	; (80a0d50 <_Z13RegisterTimerP16TICK_TIMER_S_TAG+0x24>)
 80a0d2e:	6813      	ldr	r3, [r2, #0]
 80a0d30:	b913      	cbnz	r3, 80a0d38 <_Z13RegisterTimerP16TICK_TIMER_S_TAG+0xc>
  {
    scpstHeadTimer = pstTimer;
 80a0d32:	6010      	str	r0, [r2, #0]
    pstTimer->pstNextTimer = NULL;
 80a0d34:	6043      	str	r3, [r0, #4]
 80a0d36:	e007      	b.n	80a0d48 <_Z13RegisterTimerP16TICK_TIMER_S_TAG+0x1c>
  }
  else
  {
    for (pstCurrentTimer = scpstHeadTimer;
          pstCurrentTimer->pstNextTimer != NULL;
 80a0d38:	685a      	ldr	r2, [r3, #4]
 80a0d3a:	b11a      	cbz	r2, 80a0d44 <_Z13RegisterTimerP16TICK_TIMER_S_TAG+0x18>
          pstCurrentTimer = pstCurrentTimer->pstNextTimer)
    {
      if (pstCurrentTimer->pstNextTimer == pstTimer)
 80a0d3c:	4282      	cmp	r2, r0
 80a0d3e:	4613      	mov	r3, r2
 80a0d40:	d1fa      	bne.n	80a0d38 <_Z13RegisterTimerP16TICK_TIMER_S_TAG+0xc>
 80a0d42:	4770      	bx	lr
      {
        return;
      }
    }
    pstCurrentTimer->pstNextTimer = pstTimer;
 80a0d44:	6058      	str	r0, [r3, #4]
    pstTimer->pstNextTimer = NULL;
 80a0d46:	6042      	str	r2, [r0, #4]
  }
}

void ClearTimer(TICK_TIMER_S * kpstTimer)
{
  kpstTimer->wExpirationTime = TICK_TIMER_EXPIRED_MASK;
 80a0d48:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 80a0d4c:	6003      	str	r3, [r0, #0]
 80a0d4e:	4770      	bx	lr
 80a0d50:	20000af0 	.word	0x20000af0

080a0d54 <_Z12UpdateTimersv>:
}

void UpdateTimers(void)
{
  TICK_TIMER_S * pstCurrentTimer;
  for (pstCurrentTimer = scpstHeadTimer;
 80a0d54:	4b09      	ldr	r3, [pc, #36]	; (80a0d7c <_Z12UpdateTimersv+0x28>)
    {
      case TICK_TIMER_EXPIRED_BIT:
      case TICK_TIMER_EXPIRED_MASK:
        break;
      case 0:
        pstCurrentTimer->wExpirationTime = TICK_TIMER_EXPIRED_BIT;
 80a0d56:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}

void UpdateTimers(void)
{
  TICK_TIMER_S * pstCurrentTimer;
  for (pstCurrentTimer = scpstHeadTimer;
 80a0d5a:	681b      	ldr	r3, [r3, #0]
      pstCurrentTimer != NULL;
 80a0d5c:	b163      	cbz	r3, 80a0d78 <_Z12UpdateTimersv+0x24>
      pstCurrentTimer = pstCurrentTimer->pstNextTimer)
  {
    switch (pstCurrentTimer->wExpirationTime)
 80a0d5e:	681a      	ldr	r2, [r3, #0]
 80a0d60:	b13a      	cbz	r2, 80a0d72 <_Z12UpdateTimersv+0x1e>
 80a0d62:	f102 4100 	add.w	r1, r2, #2147483648	; 0x80000000
 80a0d66:	3101      	adds	r1, #1
 80a0d68:	2901      	cmp	r1, #1
 80a0d6a:	d903      	bls.n	80a0d74 <_Z12UpdateTimersv+0x20>
        break;
      case 0:
        pstCurrentTimer->wExpirationTime = TICK_TIMER_EXPIRED_BIT;
        break;
      default:
        pstCurrentTimer->wExpirationTime--;
 80a0d6c:	3a01      	subs	r2, #1
 80a0d6e:	601a      	str	r2, [r3, #0]
        break;
 80a0d70:	e000      	b.n	80a0d74 <_Z12UpdateTimersv+0x20>
    {
      case TICK_TIMER_EXPIRED_BIT:
      case TICK_TIMER_EXPIRED_MASK:
        break;
      case 0:
        pstCurrentTimer->wExpirationTime = TICK_TIMER_EXPIRED_BIT;
 80a0d72:	6018      	str	r0, [r3, #0]
}

void UpdateTimers(void)
{
  TICK_TIMER_S * pstCurrentTimer;
  for (pstCurrentTimer = scpstHeadTimer;
 80a0d74:	685b      	ldr	r3, [r3, #4]
 80a0d76:	e7f1      	b.n	80a0d5c <_Z12UpdateTimersv+0x8>
 80a0d78:	4770      	bx	lr
 80a0d7a:	bf00      	nop
 80a0d7c:	20000af0 	.word	0x20000af0

080a0d80 <_Z24SetTimerWithMillisecondsP16TICK_TIMER_S_TAGj>:

void SetTimerWithMilliseconds(TICK_TIMER_S * pstTimer, unsigned int wMilliseconds)
{
  if ((wMilliseconds / 5) < TICK_TIMER_EXPIRED_MASK)
  {
    pstTimer->wExpirationTime = wMilliseconds / 5; //5 ms refresh interval
 80a0d80:	2305      	movs	r3, #5
 80a0d82:	fbb1 f1f3 	udiv	r1, r1, r3
 80a0d86:	6001      	str	r1, [r0, #0]
 80a0d88:	4770      	bx	lr

080a0d8a <_GLOBAL__sub_I_scpstHeadTimer>:
 80a0d8a:	f002 b8f7 	b.w	80a2f7c <HAL_Pin_Map>

080a0d8e <_ZNSt14_Function_base13_Base_managerIZN7CarloopI16CarloopRevision2E9enableGPSEvEUlvE_E10_M_managerERSt9_Any_dataRKS6_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a0d8e:	2a01      	cmp	r2, #1
 80a0d90:	d002      	beq.n	80a0d98 <_ZNSt14_Function_base13_Base_managerIZN7CarloopI16CarloopRevision2E9enableGPSEvEUlvE_E10_M_managerERSt9_Any_dataRKS6_St18_Manager_operation+0xa>
 80a0d92:	2a02      	cmp	r2, #2
 80a0d94:	d002      	beq.n	80a0d9c <_ZNSt14_Function_base13_Base_managerIZN7CarloopI16CarloopRevision2E9enableGPSEvEUlvE_E10_M_managerERSt9_Any_dataRKS6_St18_Manager_operation+0xe>
 80a0d96:	e004      	b.n	80a0da2 <_ZNSt14_Function_base13_Base_managerIZN7CarloopI16CarloopRevision2E9enableGPSEvEUlvE_E10_M_managerERSt9_Any_dataRKS6_St18_Manager_operation+0x14>
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a0d98:	6001      	str	r1, [r0, #0]
	      break;
 80a0d9a:	e002      	b.n	80a0da2 <_ZNSt14_Function_base13_Base_managerIZN7CarloopI16CarloopRevision2E9enableGPSEvEUlvE_E10_M_managerERSt9_Any_dataRKS6_St18_Manager_operation+0x14>
	// Clone a location-invariant function object that fits within
	// an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
	{
	  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 80a0d9c:	b108      	cbz	r0, 80a0da2 <_ZNSt14_Function_base13_Base_managerIZN7CarloopI16CarloopRevision2E9enableGPSEvEUlvE_E10_M_managerERSt9_Any_dataRKS6_St18_Manager_operation+0x14>
 80a0d9e:	680b      	ldr	r3, [r1, #0]
 80a0da0:	6003      	str	r3, [r0, #0]
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a0da2:	2000      	movs	r0, #0
 80a0da4:	4770      	bx	lr

080a0da6 <_ZN6Thread3runEPv>:
        return *this;
    }

private:

    static os_thread_return_t run(void* param) {
 80a0da6:	b510      	push	{r4, lr}
        Data* th = (Data*)param;
        th->started = true;
 80a0da8:	2301      	movs	r3, #1
 80a0daa:	7403      	strb	r3, [r0, #16]
        if (th->func) {
 80a0dac:	6883      	ldr	r3, [r0, #8]
        return *this;
    }

private:

    static os_thread_return_t run(void* param) {
 80a0dae:	4604      	mov	r4, r0
        Data* th = (Data*)param;
        th->started = true;
        if (th->func) {
 80a0db0:	b10b      	cbz	r3, 80a0db6 <_ZN6Thread3runEPv+0x10>
            (*(th->func))(th->func_param);
 80a0db2:	68c0      	ldr	r0, [r0, #12]
 80a0db4:	e006      	b.n	80a0dc4 <_ZN6Thread3runEPv+0x1e>
      }

      /// Return the stored pointer.
      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
 80a0db6:	6800      	ldr	r0, [r0, #0]
        } else if (th->wrapper) {
 80a0db8:	b128      	cbz	r0, 80a0dc6 <_ZN6Thread3runEPv+0x20>
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a0dba:	6883      	ldr	r3, [r0, #8]
 80a0dbc:	b90b      	cbnz	r3, 80a0dc2 <_ZN6Thread3runEPv+0x1c>
	__throw_bad_function_call();
 80a0dbe:	f003 f99c 	bl	80a40fa <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a0dc2:	68c3      	ldr	r3, [r0, #12]
 80a0dc4:	4798      	blx	r3
            (*(th->wrapper))();
        }
        th->exited = true;
 80a0dc6:	2301      	movs	r3, #1
 80a0dc8:	7463      	strb	r3, [r4, #17]
        os_thread_exit(nullptr);
 80a0dca:	2000      	movs	r0, #0
    }
 80a0dcc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            (*(th->func))(th->func_param);
        } else if (th->wrapper) {
            (*(th->wrapper))();
        }
        th->exited = true;
        os_thread_exit(nullptr);
 80a0dd0:	f002 b9bc 	b.w	80a314c <os_thread_exit>

080a0dd4 <_ZN6ThreadC1EPKcSt8functionIFvvEEhj>:
        return;
    error:
        d_.reset();
    }

    Thread(const char *name, wiring_thread_fn_t function,
 80a0dd4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80a0dd8:	4606      	mov	r6, r0
 80a0dda:	460f      	mov	r7, r1
            os_thread_prio_t priority=OS_THREAD_PRIORITY_DEFAULT, size_t stack_size=OS_THREAD_STACK_SIZE_DEFAULT)
        : d_(new(std::nothrow) Data)
 80a0ddc:	2014      	movs	r0, #20
 80a0dde:	492e      	ldr	r1, [pc, #184]	; (80a0e98 <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0xc4>)
        return;
    error:
        d_.reset();
    }

    Thread(const char *name, wiring_thread_fn_t function,
 80a0de0:	4615      	mov	r5, r2
 80a0de2:	4698      	mov	r8, r3
            os_thread_prio_t priority=OS_THREAD_PRIORITY_DEFAULT, size_t stack_size=OS_THREAD_STACK_SIZE_DEFAULT)
        : d_(new(std::nothrow) Data)
 80a0de4:	f003 f97a 	bl	80a40dc <_ZnwjRKSt9nothrow_t>
 80a0de8:	4604      	mov	r4, r0
 80a0dea:	b130      	cbz	r0, 80a0dfa <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0x26>

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }
 80a0dec:	2300      	movs	r3, #0
        Data() :
            handle(OS_THREAD_INVALID_HANDLE),
            func(nullptr),
            func_param(nullptr),
            started(false),
            exited(false) {
 80a0dee:	7403      	strb	r3, [r0, #16]
 80a0df0:	6003      	str	r3, [r0, #0]
 80a0df2:	6043      	str	r3, [r0, #4]
 80a0df4:	6083      	str	r3, [r0, #8]
 80a0df6:	60c3      	str	r3, [r0, #12]
 80a0df8:	7443      	strb	r3, [r0, #17]
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80a0dfa:	6034      	str	r4, [r6, #0]

    Thread(const char *name, wiring_thread_fn_t function,
            os_thread_prio_t priority=OS_THREAD_PRIORITY_DEFAULT, size_t stack_size=OS_THREAD_STACK_SIZE_DEFAULT)
        : d_(new(std::nothrow) Data)
    {
        if (!d_) {
 80a0dfc:	2c00      	cmp	r4, #0
 80a0dfe:	d038      	beq.n	80a0e72 <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0x9e>
            goto error;
        }
        d_->wrapper.reset(new(std::nothrow) wiring_thread_fn_t(std::move(function)));
 80a0e00:	4925      	ldr	r1, [pc, #148]	; (80a0e98 <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0xc4>)
 80a0e02:	2010      	movs	r0, #16
 80a0e04:	f003 f96a 	bl	80a40dc <_ZnwjRKSt9nothrow_t>
 80a0e08:	4603      	mov	r3, r0
 80a0e0a:	b1b0      	cbz	r0, 80a0e3a <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0x66>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a0e0c:	2200      	movs	r2, #0
 80a0e0e:	6082      	str	r2, [r0, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a0e10:	aa02      	add	r2, sp, #8
 80a0e12:	e895 0003 	ldmia.w	r5, {r0, r1}
 80a0e16:	e882 0003 	stmia.w	r2, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
 80a0e1a:	e893 0003 	ldmia.w	r3, {r0, r1}
 80a0e1e:	e885 0003 	stmia.w	r5, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 80a0e22:	e892 0003 	ldmia.w	r2, {r0, r1}
 80a0e26:	e883 0003 	stmia.w	r3, {r0, r1}
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a0e2a:	6899      	ldr	r1, [r3, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a0e2c:	68aa      	ldr	r2, [r5, #8]
      __a = _GLIBCXX_MOVE(__b);
 80a0e2e:	60a9      	str	r1, [r5, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a0e30:	609a      	str	r2, [r3, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a0e32:	68ea      	ldr	r2, [r5, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a0e34:	68d9      	ldr	r1, [r3, #12]
 80a0e36:	60e9      	str	r1, [r5, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a0e38:	60da      	str	r2, [r3, #12]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a0e3a:	6825      	ldr	r5, [r4, #0]
      __a = _GLIBCXX_MOVE(__b);
 80a0e3c:	6023      	str	r3, [r4, #0]
      void
      reset(pointer __p = pointer()) noexcept
      {
	using std::swap;
	swap(std::get<0>(_M_t), __p);
	if (__p != pointer())
 80a0e3e:	b12d      	cbz	r5, 80a0e4c <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0x78>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a0e40:	4628      	mov	r0, r5
 80a0e42:	f7ff fae7 	bl	80a0414 <_ZNSt14_Function_baseD1Ev>
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
 80a0e46:	4628      	mov	r0, r5
 80a0e48:	f7ff f929 	bl	80a009e <_ZdlPv>
      }

      /// Return the stored pointer.
      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
 80a0e4c:	6830      	ldr	r0, [r6, #0]
        if (!d_->wrapper) {
 80a0e4e:	6803      	ldr	r3, [r0, #0]
 80a0e50:	b17b      	cbz	r3, 80a0e72 <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0x9e>
            goto error;
        }
        if (os_thread_create(&d_->handle, name, priority, &Thread::run, d_.get(), stack_size) != 0) {
 80a0e52:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a0e54:	4642      	mov	r2, r8
 80a0e56:	e88d 0009 	stmia.w	sp, {r0, r3}
 80a0e5a:	4639      	mov	r1, r7
 80a0e5c:	4b0f      	ldr	r3, [pc, #60]	; (80a0e9c <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0xc8>)
 80a0e5e:	3004      	adds	r0, #4
 80a0e60:	f002 f934 	bl	80a30cc <os_thread_create>
 80a0e64:	b928      	cbnz	r0, 80a0e72 <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0x9e>
 80a0e66:	6833      	ldr	r3, [r6, #0]
            goto error;
        }
        while (!d_->started) {
 80a0e68:	7c1b      	ldrb	r3, [r3, #16]
 80a0e6a:	b98b      	cbnz	r3, 80a0e90 <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0xbc>
            os_thread_yield();
 80a0e6c:	f002 f936 	bl	80a30dc <os_thread_yield>
            goto error;
        }
        if (os_thread_create(&d_->handle, name, priority, &Thread::run, d_.get(), stack_size) != 0) {
            goto error;
        }
        while (!d_->started) {
 80a0e70:	e7f9      	b.n	80a0e66 <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0x92>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a0e72:	6834      	ldr	r4, [r6, #0]
      __a = _GLIBCXX_MOVE(__b);
 80a0e74:	2300      	movs	r3, #0
 80a0e76:	6033      	str	r3, [r6, #0]
      void
      reset(pointer __p = pointer()) noexcept
      {
	using std::swap;
	swap(std::get<0>(_M_t), __p);
	if (__p != pointer())
 80a0e78:	b154      	cbz	r4, 80a0e90 <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0xbc>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
 80a0e7a:	6825      	ldr	r5, [r4, #0]
 80a0e7c:	b12d      	cbz	r5, 80a0e8a <_ZN6ThreadC1EPKcSt8functionIFvvEEhj+0xb6>
 80a0e7e:	4628      	mov	r0, r5
 80a0e80:	f7ff fac8 	bl	80a0414 <_ZNSt14_Function_baseD1Ev>
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
 80a0e84:	4628      	mov	r0, r5
 80a0e86:	f7ff f90a 	bl	80a009e <_ZdlPv>
 80a0e8a:	4620      	mov	r0, r4
 80a0e8c:	f7ff f907 	bl	80a009e <_ZdlPv>
            os_thread_yield();
        }
        return;
    error:
        d_.reset();
    }
 80a0e90:	4630      	mov	r0, r6
 80a0e92:	b004      	add	sp, #16
 80a0e94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0e98:	080a5ba4 	.word	0x080a5ba4
 80a0e9c:	080a0da7 	.word	0x080a0da7

080a0ea0 <_ZN7CarloopI16CarloopRevision2EC1Ev>:

#include "carloop.h"
#include <functional>

template<typename Config>
Carloop<Config>::Carloop()
 80a0ea0:	b510      	push	{r4, lr}
 80a0ea2:	4604      	mov	r4, r0
    : canDriver(Config::CAN_PINS),
    canSpeed(Config::CAN_DEFAULT_SPEED),
    gpsSerialThread(NULL)
 80a0ea4:	2320      	movs	r3, #32
 80a0ea6:	461a      	mov	r2, r3
 80a0ea8:	2100      	movs	r1, #0
 80a0eaa:	f003 f81f 	bl	80a3eec <_ZN10CANChannelC1E15HAL_CAN_Channeltt>
 80a0eae:	4b05      	ldr	r3, [pc, #20]	; (80a0ec4 <_ZN7CarloopI16CarloopRevision2EC1Ev+0x24>)
 80a0eb0:	f104 000c 	add.w	r0, r4, #12
 80a0eb4:	6063      	str	r3, [r4, #4]
 80a0eb6:	2300      	movs	r3, #0
 80a0eb8:	60a3      	str	r3, [r4, #8]
 80a0eba:	f000 f8c8 	bl	80a104e <_ZN11TinyGPSPlusC1Ev>
{
}
 80a0ebe:	4620      	mov	r0, r4
 80a0ec0:	bd10      	pop	{r4, pc}
 80a0ec2:	bf00      	nop
 80a0ec4:	0007a120 	.word	0x0007a120

080a0ec8 <_ZN7CarloopI16CarloopRevision2E11setCANSpeedEm>:

template <typename Config>
void Carloop<Config>::setCANSpeed(uint32_t canSpeed)
{
    this->canSpeed = canSpeed;
 80a0ec8:	6041      	str	r1, [r0, #4]
 80a0eca:	4770      	bx	lr

080a0ecc <_ZN7CarloopI16CarloopRevision2E3canEv>:

template <typename Config>
CANChannel &Carloop<Config>::can()
{
    return canDriver;
}
 80a0ecc:	4770      	bx	lr

080a0ece <_ZN7CarloopI16CarloopRevision2E9enableCANEv>:
{
    return batteryVoltage;
}

template <typename Config>
void Carloop<Config>::enableCAN()
 80a0ece:	b510      	push	{r4, lr}
 80a0ed0:	4604      	mov	r4, r0
{
    pinMode(Config::CAN_ENABLE_PIN, OUTPUT);
 80a0ed2:	2101      	movs	r1, #1
 80a0ed4:	2000      	movs	r0, #0
 80a0ed6:	f003 f857 	bl	80a3f88 <pinMode>
    digitalWrite(Config::CAN_ENABLE_PIN, Config::CAN_ENABLE_ACTIVE);
 80a0eda:	2100      	movs	r1, #0
 80a0edc:	4608      	mov	r0, r1
 80a0ede:	f003 f864 	bl	80a3faa <digitalWrite>
    canDriver.begin(canSpeed);
 80a0ee2:	6861      	ldr	r1, [r4, #4]
 80a0ee4:	4620      	mov	r0, r4
}
 80a0ee6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
template <typename Config>
void Carloop<Config>::enableCAN()
{
    pinMode(Config::CAN_ENABLE_PIN, OUTPUT);
    digitalWrite(Config::CAN_ENABLE_PIN, Config::CAN_ENABLE_ACTIVE);
    canDriver.begin(canSpeed);
 80a0eea:	2200      	movs	r2, #0
 80a0eec:	f003 b809 	b.w	80a3f02 <_ZN10CANChannel5beginEmm>

080a0ef0 <_ZN7CarloopI16CarloopRevision2E9enableGPSEv>:
    canDriver.end();
    digitalWrite(Config::CAN_ENABLE_PIN, Config::CAN_ENABLE_INACTIVE);
}

template <typename Config>
void Carloop<Config>::enableGPS()
 80a0ef0:	b530      	push	{r4, r5, lr}
 80a0ef2:	4604      	mov	r4, r0
 80a0ef4:	b087      	sub	sp, #28
{
    pinMode(Config::GPS_ENABLE_PIN, OUTPUT);
 80a0ef6:	2101      	movs	r1, #1
 80a0ef8:	200a      	movs	r0, #10
 80a0efa:	f003 f845 	bl	80a3f88 <pinMode>
    digitalWrite(Config::GPS_ENABLE_PIN, Config::GPS_ENABLE_ACTIVE);
 80a0efe:	2101      	movs	r1, #1
 80a0f00:	200a      	movs	r0, #10
 80a0f02:	f003 f852 	bl	80a3faa <digitalWrite>

    Serial1.begin(Config::GPS_BAUD_RATE);
 80a0f06:	f002 ff89 	bl	80a3e1c <_Z22__fetch_global_Serial1v>
 80a0f0a:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a0f0e:	f002 ff7f 	bl	80a3e10 <_ZN11USARTSerial5beginEm>

    if (!gpsSerialThread) {
 80a0f12:	68a3      	ldr	r3, [r4, #8]
 80a0f14:	b9ab      	cbnz	r3, 80a0f42 <_ZN7CarloopI16CarloopRevision2E9enableGPSEv+0x52>
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a0f16:	4b0c      	ldr	r3, [pc, #48]	; (80a0f48 <_ZN7CarloopI16CarloopRevision2E9enableGPSEv+0x58>)
        // Start a thread that will run this->receiveSerialChars()
        gpsSerialThread = new Thread("gps_serial", [this]() { receiveSerialChars(); });
 80a0f18:	2004      	movs	r0, #4
 80a0f1a:	9305      	str	r3, [sp, #20]
	    _M_manager = &_My_handler::_M_manager;
 80a0f1c:	4b0b      	ldr	r3, [pc, #44]	; (80a0f4c <_ZN7CarloopI16CarloopRevision2E9enableGPSEv+0x5c>)
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a0f1e:	9402      	str	r4, [sp, #8]

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
 80a0f20:	9304      	str	r3, [sp, #16]
 80a0f22:	f7ff f8ba 	bl	80a009a <_Znwj>
 80a0f26:	4605      	mov	r5, r0
 80a0f28:	b138      	cbz	r0, 80a0f3a <_ZN7CarloopI16CarloopRevision2E9enableGPSEv+0x4a>
 80a0f2a:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 80a0f2e:	9300      	str	r3, [sp, #0]
 80a0f30:	aa02      	add	r2, sp, #8
 80a0f32:	2302      	movs	r3, #2
 80a0f34:	4906      	ldr	r1, [pc, #24]	; (80a0f50 <_ZN7CarloopI16CarloopRevision2E9enableGPSEv+0x60>)
 80a0f36:	f7ff ff4d 	bl	80a0dd4 <_ZN6ThreadC1EPKcSt8functionIFvvEEhj>
 80a0f3a:	60a5      	str	r5, [r4, #8]
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a0f3c:	a802      	add	r0, sp, #8
 80a0f3e:	f7ff fa69 	bl	80a0414 <_ZNSt14_Function_baseD1Ev>
    }
}
 80a0f42:	b007      	add	sp, #28
 80a0f44:	bd30      	pop	{r4, r5, pc}
 80a0f46:	bf00      	nop
 80a0f48:	080a1041 	.word	0x080a1041
 80a0f4c:	080a0d8f 	.word	0x080a0d8f
 80a0f50:	080a5993 	.word	0x080a5993

080a0f54 <_ZN7CarloopI16CarloopRevision2E11readBatteryEv>:
    pinMode(Config::BATTERY_PIN, INPUT);
    readBattery();
}

template <typename Config>
float Carloop<Config>::readBattery()
 80a0f54:	b508      	push	{r3, lr}
{
    static constexpr auto MAX_ANALOG_VALUE = 4096;
    static constexpr auto MAX_ANALOG_VOLTAGE = 3.3f;
    auto adcValue = analogRead(Config::BATTERY_PIN);
 80a0f56:	200b      	movs	r0, #11
 80a0f58:	f003 f840 	bl	80a3fdc <analogRead>
    return adcValue * MAX_ANALOG_VOLTAGE / MAX_ANALOG_VALUE * Config::BATTERY_FACTOR;
 80a0f5c:	f003 fd12 	bl	80a4984 <__aeabi_i2f>
 80a0f60:	4905      	ldr	r1, [pc, #20]	; (80a0f78 <_ZN7CarloopI16CarloopRevision2E11readBatteryEv+0x24>)
 80a0f62:	f003 fd63 	bl	80a4a2c <__aeabi_fmul>
 80a0f66:	f04f 5166 	mov.w	r1, #964689920	; 0x39800000
 80a0f6a:	f003 fd5f 	bl	80a4a2c <__aeabi_fmul>
 80a0f6e:	4903      	ldr	r1, [pc, #12]	; (80a0f7c <_ZN7CarloopI16CarloopRevision2E11readBatteryEv+0x28>)
 80a0f70:	f003 fd5c 	bl	80a4a2c <__aeabi_fmul>
}
 80a0f74:	bd08      	pop	{r3, pc}
 80a0f76:	bf00      	nop
 80a0f78:	40533333 	.word	0x40533333
 80a0f7c:	40e66666 	.word	0x40e66666

080a0f80 <_ZN7CarloopI16CarloopRevision2E13enableBatteryEv>:
{
    digitalWrite(Config::GPS_ENABLE_PIN, Config::GPS_ENABLE_INACTIVE);
}

template <typename Config>
void Carloop<Config>::enableBattery()
 80a0f80:	b510      	push	{r4, lr}
 80a0f82:	4604      	mov	r4, r0
{
    pinMode(Config::BATTERY_PIN, INPUT);
 80a0f84:	2100      	movs	r1, #0
 80a0f86:	200b      	movs	r0, #11
 80a0f88:	f002 fffe 	bl	80a3f88 <pinMode>
    readBattery();
 80a0f8c:	4620      	mov	r0, r4
 80a0f8e:	f7ff ffe1 	bl	80a0f54 <_ZN7CarloopI16CarloopRevision2E11readBatteryEv>
 80a0f92:	bd10      	pop	{r4, pc}

080a0f94 <_ZN7CarloopI16CarloopRevision2E6hasCANEv>:
}

template <typename Config>
bool Carloop<Config>::hasCAN()
{
    return Config::FEATURES & features & CARLOOP_CAN;
 80a0f94:	f890 00ec 	ldrb.w	r0, [r0, #236]	; 0xec
}
 80a0f98:	f000 0001 	and.w	r0, r0, #1
 80a0f9c:	4770      	bx	lr

080a0f9e <_ZN7CarloopI16CarloopRevision2E6hasGPSEv>:

template <typename Config>
bool Carloop<Config>::hasGPS()
{
    return Config::FEATURES & features & CARLOOP_GPS;
 80a0f9e:	f890 00ec 	ldrb.w	r0, [r0, #236]	; 0xec
}
 80a0fa2:	f3c0 0040 	ubfx	r0, r0, #1, #1
 80a0fa6:	4770      	bx	lr

080a0fa8 <_ZN7CarloopI16CarloopRevision2E10hasBatteryEv>:

template <typename Config>
bool Carloop<Config>::hasBattery()
{
    return Config::FEATURES & features & CARLOOP_BATTERY;
 80a0fa8:	f890 00ec 	ldrb.w	r0, [r0, #236]	; 0xec
}
 80a0fac:	f3c0 0080 	ubfx	r0, r0, #2, #1
 80a0fb0:	4770      	bx	lr

080a0fb2 <_ZN7CarloopI16CarloopRevision2E5beginE17CarloopFeatures_e>:
{
    this->canSpeed = canSpeed;
}

template <typename Config>
void Carloop<Config>::begin(CarloopFeatures_e features)
 80a0fb2:	b510      	push	{r4, lr}
{
    this->features = features;
 80a0fb4:	f880 10ec 	strb.w	r1, [r0, #236]	; 0xec
{
    this->canSpeed = canSpeed;
}

template <typename Config>
void Carloop<Config>::begin(CarloopFeatures_e features)
 80a0fb8:	4604      	mov	r4, r0
{
    this->features = features;

    if(hasCAN())
 80a0fba:	f7ff ffeb 	bl	80a0f94 <_ZN7CarloopI16CarloopRevision2E6hasCANEv>
 80a0fbe:	b110      	cbz	r0, 80a0fc6 <_ZN7CarloopI16CarloopRevision2E5beginE17CarloopFeatures_e+0x14>
    {
        enableCAN();
 80a0fc0:	4620      	mov	r0, r4
 80a0fc2:	f7ff ff84 	bl	80a0ece <_ZN7CarloopI16CarloopRevision2E9enableCANEv>
    }

    if(hasGPS())
 80a0fc6:	4620      	mov	r0, r4
 80a0fc8:	f7ff ffe9 	bl	80a0f9e <_ZN7CarloopI16CarloopRevision2E6hasGPSEv>
 80a0fcc:	b110      	cbz	r0, 80a0fd4 <_ZN7CarloopI16CarloopRevision2E5beginE17CarloopFeatures_e+0x22>
    {
        enableGPS();
 80a0fce:	4620      	mov	r0, r4
 80a0fd0:	f7ff ff8e 	bl	80a0ef0 <_ZN7CarloopI16CarloopRevision2E9enableGPSEv>
    }

    if(hasBattery())
 80a0fd4:	4620      	mov	r0, r4
 80a0fd6:	f7ff ffe7 	bl	80a0fa8 <_ZN7CarloopI16CarloopRevision2E10hasBatteryEv>
 80a0fda:	b110      	cbz	r0, 80a0fe2 <_ZN7CarloopI16CarloopRevision2E5beginE17CarloopFeatures_e+0x30>
    {
        enableBattery();
 80a0fdc:	4620      	mov	r0, r4
 80a0fde:	f7ff ffcf 	bl	80a0f80 <_ZN7CarloopI16CarloopRevision2E13enableBatteryEv>
 80a0fe2:	bd10      	pop	{r4, pc}

080a0fe4 <_ZN7CarloopI16CarloopRevision2E18receiveSerialCharsEv>:
    return Config::FEATURES & features & CARLOOP_BATTERY;
}

// Receive bytes from the GPS
template <typename Config>
void Carloop<Config>::receiveSerialChars()
 80a0fe4:	b570      	push	{r4, r5, r6, lr}
 80a0fe6:	4604      	mov	r4, r0
{
    while(true) {
        WITH_LOCK(gpsDriver) {
 80a0fe8:	f100 060c 	add.w	r6, r0, #12
    // Additional methods for thread synchronization
#if PLATFORM_THREADING
	os_mutex_recursive_t get_mutex()
	{
        if (mutex == nullptr) {
            os_mutex_recursive_create(&mutex);            
 80a0fec:	f100 05e4 	add.w	r5, r0, #228	; 0xe4

    // Additional methods for thread synchronization
#if PLATFORM_THREADING
	os_mutex_recursive_t get_mutex()
	{
        if (mutex == nullptr) {
 80a0ff0:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
 80a0ff4:	b913      	cbnz	r3, 80a0ffc <_ZN7CarloopI16CarloopRevision2E18receiveSerialCharsEv+0x18>
            os_mutex_recursive_create(&mutex);            
 80a0ff6:	4628      	mov	r0, r5
 80a0ff8:	f002 f890 	bl	80a311c <os_mutex_recursive_create>
	}

	void lock()
	{
#if PLATFORM_THREADING
		os_mutex_recursive_lock(get_mutex());
 80a0ffc:	f8d4 00e4 	ldr.w	r0, [r4, #228]	; 0xe4
 80a1000:	f002 f894 	bl	80a312c <os_mutex_recursive_lock>
            while(Serial1.available())
 80a1004:	f002 ff0a 	bl	80a3e1c <_Z22__fetch_global_Serial1v>
 80a1008:	6803      	ldr	r3, [r0, #0]
 80a100a:	691b      	ldr	r3, [r3, #16]
 80a100c:	4798      	blx	r3
 80a100e:	b148      	cbz	r0, 80a1024 <_ZN7CarloopI16CarloopRevision2E18receiveSerialCharsEv+0x40>
            {
                char c = Serial1.read();
 80a1010:	f002 ff04 	bl	80a3e1c <_Z22__fetch_global_Serial1v>
 80a1014:	6803      	ldr	r3, [r0, #0]
 80a1016:	695b      	ldr	r3, [r3, #20]
 80a1018:	4798      	blx	r3
                gpsDriver.encode(c);
 80a101a:	b2c1      	uxtb	r1, r0
 80a101c:	4630      	mov	r0, r6
 80a101e:	f000 fa8f 	bl	80a1540 <_ZN11TinyGPSPlus6encodeEc>
template <typename Config>
void Carloop<Config>::receiveSerialChars()
{
    while(true) {
        WITH_LOCK(gpsDriver) {
            while(Serial1.available())
 80a1022:	e7ef      	b.n	80a1004 <_ZN7CarloopI16CarloopRevision2E18receiveSerialCharsEv+0x20>

    // Additional methods for thread synchronization
#if PLATFORM_THREADING
	os_mutex_recursive_t get_mutex()
	{
        if (mutex == nullptr) {
 80a1024:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
 80a1028:	b913      	cbnz	r3, 80a1030 <_ZN7CarloopI16CarloopRevision2E18receiveSerialCharsEv+0x4c>
            os_mutex_recursive_create(&mutex);            
 80a102a:	4628      	mov	r0, r5
 80a102c:	f002 f876 	bl	80a311c <os_mutex_recursive_create>
	}

	void unlock()
	{
#if PLATFORM_THREADING
		os_mutex_recursive_unlock(get_mutex());
 80a1030:	f8d4 00e4 	ldr.w	r0, [r4, #228]	; 0xe4
 80a1034:	f002 f882 	bl	80a313c <os_mutex_recursive_unlock>
            {
                char c = Serial1.read();
                gpsDriver.encode(c);
            }
        }
        delay(1);
 80a1038:	2001      	movs	r0, #1
 80a103a:	f002 fcbf 	bl	80a39bc <delay>

// Receive bytes from the GPS
template <typename Config>
void Carloop<Config>::receiveSerialChars()
{
    while(true) {
 80a103e:	e7d7      	b.n	80a0ff0 <_ZN7CarloopI16CarloopRevision2E18receiveSerialCharsEv+0xc>

080a1040 <_ZNSt17_Function_handlerIFvvEZN7CarloopI16CarloopRevision2E9enableGPSEvEUlvE_E9_M_invokeERKSt9_Any_data>:
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a1040:	b508      	push	{r3, lr}

    Serial1.begin(Config::GPS_BAUD_RATE);

    if (!gpsSerialThread) {
        // Start a thread that will run this->receiveSerialChars()
        gpsSerialThread = new Thread("gps_serial", [this]() { receiveSerialChars(); });
 80a1042:	6800      	ldr	r0, [r0, #0]
 80a1044:	f7ff ffce 	bl	80a0fe4 <_ZN7CarloopI16CarloopRevision2E18receiveSerialCharsEv>
 80a1048:	bd08      	pop	{r3, pc}

080a104a <_GLOBAL__sub_I_carloop.cpp>:
 80a104a:	f001 bf97 	b.w	80a2f7c <HAL_Pin_Map>

080a104e <_ZN11TinyGPSPlusC1Ev>:
        return rawLngData;
    }
    double lat();
    double lng();

    TinyGPSLocation() : valid(false), updated(false) {}
 80a104e:	2200      	movs	r2, #0
#define sq(x) ((x) * (x))

TinyGPSPlus::TinyGPSPlus()
    : parity(0), isChecksumTerm(false), curSentenceType(GPS_SENTENCE_OTHER), curTermNumber(0),
      curTermOffset(0), sentenceHasFix(false), customElts(0), customCandidates(0),
      encodedCharCount(0), sentencesWithFixCount(0), failedChecksumCount(0), passedChecksumCount(0)
 80a1050:	2102      	movs	r1, #2
 80a1052:	7002      	strb	r2, [r0, #0]
 80a1054:	7042      	strb	r2, [r0, #1]
    uint16_t deg;
    uint32_t billionths;
    bool negative;

public:
    RawDegrees() : deg(0), billionths(0), negative(false) {}
 80a1056:	8082      	strh	r2, [r0, #4]
 80a1058:	6082      	str	r2, [r0, #8]
 80a105a:	7302      	strb	r2, [r0, #12]
 80a105c:	8202      	strh	r2, [r0, #16]
 80a105e:	6142      	str	r2, [r0, #20]
 80a1060:	7602      	strb	r2, [r0, #24]
 80a1062:	8382      	strh	r2, [r0, #28]
 80a1064:	6202      	str	r2, [r0, #32]
 80a1066:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
 80a106a:	8502      	strh	r2, [r0, #40]	; 0x28
 80a106c:	62c2      	str	r2, [r0, #44]	; 0x2c
 80a106e:	f880 2030 	strb.w	r2, [r0, #48]	; 0x30
    }
    uint16_t year();
    uint8_t month();
    uint8_t day();

    TinyGPSDate() : valid(false), updated(false), date(0) {}
 80a1072:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
 80a1076:	f880 2039 	strb.w	r2, [r0, #57]	; 0x39
 80a107a:	63c2      	str	r2, [r0, #60]	; 0x3c
    uint8_t hour();
    uint8_t minute();
    uint8_t second();
    uint8_t centisecond();

    TinyGPSTime() : valid(false), updated(false), time(0) {}
 80a107c:	f880 2048 	strb.w	r2, [r0, #72]	; 0x48
 80a1080:	f880 2049 	strb.w	r2, [r0, #73]	; 0x49
 80a1084:	64c2      	str	r2, [r0, #76]	; 0x4c
    {
        updated = false;
        return val;
    }

    TinyGPSDecimal() : valid(false), updated(false), val(0) {}
 80a1086:	f880 2058 	strb.w	r2, [r0, #88]	; 0x58
 80a108a:	f880 2059 	strb.w	r2, [r0, #89]	; 0x59
 80a108e:	6602      	str	r2, [r0, #96]	; 0x60
 80a1090:	f880 2068 	strb.w	r2, [r0, #104]	; 0x68
 80a1094:	f880 2069 	strb.w	r2, [r0, #105]	; 0x69
 80a1098:	6702      	str	r2, [r0, #112]	; 0x70
 80a109a:	f880 2078 	strb.w	r2, [r0, #120]	; 0x78
 80a109e:	f880 2079 	strb.w	r2, [r0, #121]	; 0x79
 80a10a2:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
    {
        updated = false;
        return val;
    }

    TinyGPSInteger() : valid(false), updated(false), val(0) {}
 80a10a6:	f880 2088 	strb.w	r2, [r0, #136]	; 0x88
 80a10aa:	f880 2089 	strb.w	r2, [r0, #137]	; 0x89
 80a10ae:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
    {
        updated = false;
        return val;
    }

    TinyGPSDecimal() : valid(false), updated(false), val(0) {}
 80a10b2:	f880 2098 	strb.w	r2, [r0, #152]	; 0x98
 80a10b6:	f880 2099 	strb.w	r2, [r0, #153]	; 0x99
 80a10ba:	f8c0 20a0 	str.w	r2, [r0, #160]	; 0xa0
 80a10be:	f880 20a8 	strb.w	r2, [r0, #168]	; 0xa8
 80a10c2:	f880 20a9 	strb.w	r2, [r0, #169]	; 0xa9
 80a10c6:	f880 10b9 	strb.w	r1, [r0, #185]	; 0xb9
 80a10ca:	f880 20ba 	strb.w	r2, [r0, #186]	; 0xba
 80a10ce:	f880 20bb 	strb.w	r2, [r0, #187]	; 0xbb
 80a10d2:	f880 20bc 	strb.w	r2, [r0, #188]	; 0xbc
 80a10d6:	f8c0 20c0 	str.w	r2, [r0, #192]	; 0xc0
 80a10da:	f8c0 20c4 	str.w	r2, [r0, #196]	; 0xc4
 80a10de:	f8c0 20c8 	str.w	r2, [r0, #200]	; 0xc8
 80a10e2:	f8c0 20cc 	str.w	r2, [r0, #204]	; 0xcc
 80a10e6:	f8c0 20d0 	str.w	r2, [r0, #208]	; 0xd0
 80a10ea:	f8c0 20d4 	str.w	r2, [r0, #212]	; 0xd4
{
    term[0] = '\0';
 80a10ee:	f880 20aa 	strb.w	r2, [r0, #170]	; 0xaa
}
 80a10f2:	4770      	bx	lr

080a10f4 <_ZN11TinyGPSPlus7fromHexEc>:
//
// internal utilities
//
int TinyGPSPlus::fromHex(char a)
{
    if(a >= 'A' && a <= 'F')
 80a10f4:	f1a1 0341 	sub.w	r3, r1, #65	; 0x41
 80a10f8:	2b05      	cmp	r3, #5
 80a10fa:	d802      	bhi.n	80a1102 <_ZN11TinyGPSPlus7fromHexEc+0xe>
        return a - 'A' + 10;
 80a10fc:	f1a1 0037 	sub.w	r0, r1, #55	; 0x37
 80a1100:	4770      	bx	lr
    else if(a >= 'a' && a <= 'f')
 80a1102:	f1a1 0361 	sub.w	r3, r1, #97	; 0x61
 80a1106:	2b05      	cmp	r3, #5
        return a - 'a' + 10;
 80a1108:	bf94      	ite	ls
 80a110a:	f1a1 0057 	subls.w	r0, r1, #87	; 0x57
    else
        return a - '0';
 80a110e:	f1a1 0030 	subhi.w	r0, r1, #48	; 0x30
}
 80a1112:	4770      	bx	lr

080a1114 <_ZN11TinyGPSPlus12parseDecimalEPKc>:

// static
// Parse a (potentially negative) number with up to 2 decimal digits -xxxx.yy
int32_t TinyGPSPlus::parseDecimal(const char *term)
{
 80a1114:	b538      	push	{r3, r4, r5, lr}
 80a1116:	4604      	mov	r4, r0
    bool negative = *term == '-';
 80a1118:	7805      	ldrb	r5, [r0, #0]
    if(negative)
 80a111a:	2d2d      	cmp	r5, #45	; 0x2d
        ++term;
 80a111c:	bf08      	it	eq
 80a111e:	3401      	addeq	r4, #1
    int32_t ret = 100 * (int32_t)atol(term);
 80a1120:	4620      	mov	r0, r4
 80a1122:	f003 fdd3 	bl	80a4ccc <atol>
 80a1126:	2364      	movs	r3, #100	; 0x64
 80a1128:	4358      	muls	r0, r3
 80a112a:	4622      	mov	r2, r4
    while(isdigit(*term))
 80a112c:	f814 3b01 	ldrb.w	r3, [r4], #1
 80a1130:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 80a1134:	2909      	cmp	r1, #9
 80a1136:	d9f8      	bls.n	80a112a <_ZN11TinyGPSPlus12parseDecimalEPKc+0x16>
        ++term;
    if(*term == '.' && isdigit(term[1]))
 80a1138:	2b2e      	cmp	r3, #46	; 0x2e
 80a113a:	d10b      	bne.n	80a1154 <_ZN11TinyGPSPlus12parseDecimalEPKc+0x40>
 80a113c:	7853      	ldrb	r3, [r2, #1]
 80a113e:	3b30      	subs	r3, #48	; 0x30
 80a1140:	2b09      	cmp	r3, #9
 80a1142:	d807      	bhi.n	80a1154 <_ZN11TinyGPSPlus12parseDecimalEPKc+0x40>
    {
        ret += 10 * (term[1] - '0');
 80a1144:	210a      	movs	r1, #10
 80a1146:	fb01 0003 	mla	r0, r1, r3, r0
        if(isdigit(term[2]))
 80a114a:	7893      	ldrb	r3, [r2, #2]
 80a114c:	3b30      	subs	r3, #48	; 0x30
 80a114e:	2b09      	cmp	r3, #9
            ret += term[2] - '0';
 80a1150:	bf98      	it	ls
 80a1152:	18c0      	addls	r0, r0, r3
    }
    return negative ? -ret : ret;
 80a1154:	2d2d      	cmp	r5, #45	; 0x2d
 80a1156:	bf08      	it	eq
 80a1158:	4240      	negeq	r0, r0
}
 80a115a:	bd38      	pop	{r3, r4, r5, pc}

080a115c <_ZN11TinyGPSPlus12parseDegreesEPKcR10RawDegrees>:

// static
// Parse degrees in that funny NMEA format DDMM.MMMM
void TinyGPSPlus::parseDegrees(const char *term, RawDegrees &deg)
{
 80a115c:	b538      	push	{r3, r4, r5, lr}
 80a115e:	4604      	mov	r4, r0
 80a1160:	460d      	mov	r5, r1
    uint32_t leftOfDecimal = (uint32_t)atol(term);
 80a1162:	f003 fdb3 	bl	80a4ccc <atol>
    uint16_t minutes = (uint16_t)(leftOfDecimal % 100);
    uint32_t multiplier = 10000000UL;
    uint32_t tenMillionthsOfMinutes = minutes * multiplier;
 80a1166:	2364      	movs	r3, #100	; 0x64
 80a1168:	fbb0 f2f3 	udiv	r2, r0, r3
 80a116c:	fb03 0012 	mls	r0, r3, r2, r0
 80a1170:	4b11      	ldr	r3, [pc, #68]	; (80a11b8 <_ZN11TinyGPSPlus12parseDegreesEPKcR10RawDegrees+0x5c>)

    deg.deg = (int16_t)(leftOfDecimal / 100);
 80a1172:	802a      	strh	r2, [r5, #0]
void TinyGPSPlus::parseDegrees(const char *term, RawDegrees &deg)
{
    uint32_t leftOfDecimal = (uint32_t)atol(term);
    uint16_t minutes = (uint16_t)(leftOfDecimal % 100);
    uint32_t multiplier = 10000000UL;
    uint32_t tenMillionthsOfMinutes = minutes * multiplier;
 80a1174:	4343      	muls	r3, r0
 80a1176:	4620      	mov	r0, r4

    deg.deg = (int16_t)(leftOfDecimal / 100);

    while(isdigit(*term))
 80a1178:	7802      	ldrb	r2, [r0, #0]
 80a117a:	4604      	mov	r4, r0
 80a117c:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 80a1180:	2909      	cmp	r1, #9
 80a1182:	f100 0001 	add.w	r0, r0, #1
 80a1186:	d9f7      	bls.n	80a1178 <_ZN11TinyGPSPlus12parseDegreesEPKcR10RawDegrees+0x1c>
        ++term;

    if(*term == '.')
 80a1188:	2a2e      	cmp	r2, #46	; 0x2e
 80a118a:	d10b      	bne.n	80a11a4 <_ZN11TinyGPSPlus12parseDegreesEPKcR10RawDegrees+0x48>
 80a118c:	490a      	ldr	r1, [pc, #40]	; (80a11b8 <_ZN11TinyGPSPlus12parseDegreesEPKcR10RawDegrees+0x5c>)
        while(isdigit(*++term))
        {
            multiplier /= 10;
 80a118e:	200a      	movs	r0, #10

    while(isdigit(*term))
        ++term;

    if(*term == '.')
        while(isdigit(*++term))
 80a1190:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 80a1194:	3a30      	subs	r2, #48	; 0x30
 80a1196:	2a09      	cmp	r2, #9
 80a1198:	d804      	bhi.n	80a11a4 <_ZN11TinyGPSPlus12parseDegreesEPKcR10RawDegrees+0x48>
        {
            multiplier /= 10;
 80a119a:	fbb1 f1f0 	udiv	r1, r1, r0
            tenMillionthsOfMinutes += (*term - '0') * multiplier;
 80a119e:	fb01 3302 	mla	r3, r1, r2, r3

    while(isdigit(*term))
        ++term;

    if(*term == '.')
        while(isdigit(*++term))
 80a11a2:	e7f5      	b.n	80a1190 <_ZN11TinyGPSPlus12parseDegreesEPKcR10RawDegrees+0x34>
        {
            multiplier /= 10;
            tenMillionthsOfMinutes += (*term - '0') * multiplier;
        }

    deg.billionths = (5 * tenMillionthsOfMinutes + 1) / 3;
 80a11a4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80a11a8:	3301      	adds	r3, #1
 80a11aa:	2203      	movs	r2, #3
 80a11ac:	fbb3 f3f2 	udiv	r3, r3, r2
 80a11b0:	606b      	str	r3, [r5, #4]
    deg.negative = false;
 80a11b2:	2300      	movs	r3, #0
 80a11b4:	722b      	strb	r3, [r5, #8]
 80a11b6:	bd38      	pop	{r3, r4, r5, pc}
 80a11b8:	00989680 	.word	0x00989680

080a11bc <_ZN15TinyGPSLocation6commitEv>:
    return directions[direction % 16];
}

void TinyGPSLocation::commit()
{
    rawLatData = rawNewLatData;
 80a11bc:	4603      	mov	r3, r0
    int direction = (int)((course + 11.25f) / 22.5f);
    return directions[direction % 16];
}

void TinyGPSLocation::commit()
{
 80a11be:	b510      	push	{r4, lr}
    rawLatData = rawNewLatData;
 80a11c0:	f853 2f1c 	ldr.w	r2, [r3, #28]!
    int direction = (int)((course + 11.25f) / 22.5f);
    return directions[direction % 16];
}

void TinyGPSLocation::commit()
{
 80a11c4:	4604      	mov	r4, r0
    rawLatData = rawNewLatData;
 80a11c6:	6042      	str	r2, [r0, #4]
 80a11c8:	685a      	ldr	r2, [r3, #4]
 80a11ca:	6082      	str	r2, [r0, #8]
 80a11cc:	7a1b      	ldrb	r3, [r3, #8]
 80a11ce:	7303      	strb	r3, [r0, #12]
    rawLngData = rawNewLngData;
 80a11d0:	4603      	mov	r3, r0
 80a11d2:	f853 2f28 	ldr.w	r2, [r3, #40]!
 80a11d6:	6102      	str	r2, [r0, #16]
 80a11d8:	685a      	ldr	r2, [r3, #4]
 80a11da:	6142      	str	r2, [r0, #20]
 80a11dc:	7a1b      	ldrb	r3, [r3, #8]
 80a11de:	7603      	strb	r3, [r0, #24]
 80a11e0:	f001 ff54 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
    lastCommitTime = millis();
    valid = updated = true;
 80a11e4:	2301      	movs	r3, #1

void TinyGPSLocation::commit()
{
    rawLatData = rawNewLatData;
    rawLngData = rawNewLngData;
    lastCommitTime = millis();
 80a11e6:	6360      	str	r0, [r4, #52]	; 0x34
    valid = updated = true;
 80a11e8:	7063      	strb	r3, [r4, #1]
 80a11ea:	7023      	strb	r3, [r4, #0]
    if (rawLngData.deg == 0.0 || rawLatData.deg == 0.0) { valid = false; }
 80a11ec:	8a20      	ldrh	r0, [r4, #16]
 80a11ee:	f003 fa21 	bl	80a4634 <__aeabi_i2d>
 80a11f2:	2200      	movs	r2, #0
 80a11f4:	2300      	movs	r3, #0
 80a11f6:	f003 fad9 	bl	80a47ac <__aeabi_dcmpeq>
 80a11fa:	b938      	cbnz	r0, 80a120c <_ZN15TinyGPSLocation6commitEv+0x50>
 80a11fc:	88a0      	ldrh	r0, [r4, #4]
 80a11fe:	f003 fa19 	bl	80a4634 <__aeabi_i2d>
 80a1202:	2200      	movs	r2, #0
 80a1204:	2300      	movs	r3, #0
 80a1206:	f003 fad1 	bl	80a47ac <__aeabi_dcmpeq>
 80a120a:	b108      	cbz	r0, 80a1210 <_ZN15TinyGPSLocation6commitEv+0x54>
 80a120c:	2300      	movs	r3, #0
 80a120e:	7023      	strb	r3, [r4, #0]
 80a1210:	bd10      	pop	{r4, pc}

080a1212 <_ZN11TinyGPSDate6commitEv>:
    double ret = rawLngData.deg + rawLngData.billionths / 1000000000.0;
    return rawLngData.negative ? -ret : ret;
}

void TinyGPSDate::commit()
{
 80a1212:	b510      	push	{r4, lr}
    date = newDate;
 80a1214:	6883      	ldr	r3, [r0, #8]
    double ret = rawLngData.deg + rawLngData.billionths / 1000000000.0;
    return rawLngData.negative ? -ret : ret;
}

void TinyGPSDate::commit()
{
 80a1216:	4604      	mov	r4, r0
    date = newDate;
 80a1218:	6043      	str	r3, [r0, #4]
 80a121a:	f001 ff37 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
    lastCommitTime = millis();
    valid = updated = true;
 80a121e:	2301      	movs	r3, #1
 80a1220:	7063      	strb	r3, [r4, #1]
 80a1222:	7023      	strb	r3, [r4, #0]
    if (date == 0) { valid = false; }
 80a1224:	6863      	ldr	r3, [r4, #4]
}

void TinyGPSDate::commit()
{
    date = newDate;
    lastCommitTime = millis();
 80a1226:	60e0      	str	r0, [r4, #12]
    valid = updated = true;
    if (date == 0) { valid = false; }
 80a1228:	b903      	cbnz	r3, 80a122c <_ZN11TinyGPSDate6commitEv+0x1a>
 80a122a:	7023      	strb	r3, [r4, #0]
 80a122c:	bd10      	pop	{r4, pc}

080a122e <_ZN11TinyGPSTime6commitEv>:
}

void TinyGPSTime::commit()
{
 80a122e:	b510      	push	{r4, lr}
    time = newTime;
 80a1230:	6883      	ldr	r3, [r0, #8]
    valid = updated = true;
    if (date == 0) { valid = false; }
}

void TinyGPSTime::commit()
{
 80a1232:	4604      	mov	r4, r0
    time = newTime;
 80a1234:	6043      	str	r3, [r0, #4]
 80a1236:	f001 ff29 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
    lastCommitTime = millis();
    valid = updated = true;
 80a123a:	2301      	movs	r3, #1
 80a123c:	7063      	strb	r3, [r4, #1]
 80a123e:	7023      	strb	r3, [r4, #0]
    if (time == 0) { valid = false; }
 80a1240:	6863      	ldr	r3, [r4, #4]
}

void TinyGPSTime::commit()
{
    time = newTime;
    lastCommitTime = millis();
 80a1242:	60e0      	str	r0, [r4, #12]
    valid = updated = true;
    if (time == 0) { valid = false; }
 80a1244:	b903      	cbnz	r3, 80a1248 <_ZN11TinyGPSTime6commitEv+0x1a>
 80a1246:	7023      	strb	r3, [r4, #0]
 80a1248:	bd10      	pop	{r4, pc}

080a124a <_ZN11TinyGPSTime7setTimeEPKc>:
}

void TinyGPSTime::setTime(const char *term) { newTime = (uint32_t)TinyGPSPlus::parseDecimal(term); }
 80a124a:	b510      	push	{r4, lr}
 80a124c:	4604      	mov	r4, r0
 80a124e:	4608      	mov	r0, r1
 80a1250:	f7ff ff60 	bl	80a1114 <_ZN11TinyGPSPlus12parseDecimalEPKc>
 80a1254:	60a0      	str	r0, [r4, #8]
 80a1256:	bd10      	pop	{r4, pc}

080a1258 <_ZN11TinyGPSDate7setDateEPKc>:

void TinyGPSDate::setDate(const char *term) { newDate = atol(term); }
 80a1258:	b510      	push	{r4, lr}
 80a125a:	4604      	mov	r4, r0
 80a125c:	4608      	mov	r0, r1
 80a125e:	f003 fd35 	bl	80a4ccc <atol>
 80a1262:	60a0      	str	r0, [r4, #8]
 80a1264:	bd10      	pop	{r4, pc}

080a1266 <_ZN14TinyGPSDecimal6commitEv>:
    updated = false;
    return time % 100;
}

void TinyGPSDecimal::commit()
{
 80a1266:	b510      	push	{r4, lr}
    val = newval;
 80a1268:	68c3      	ldr	r3, [r0, #12]
    updated = false;
    return time % 100;
}

void TinyGPSDecimal::commit()
{
 80a126a:	4604      	mov	r4, r0
    val = newval;
 80a126c:	6083      	str	r3, [r0, #8]
 80a126e:	f001 ff0d 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
    lastCommitTime = millis();
    valid = updated = true;
 80a1272:	2301      	movs	r3, #1
}

void TinyGPSDecimal::commit()
{
    val = newval;
    lastCommitTime = millis();
 80a1274:	6060      	str	r0, [r4, #4]
    valid = updated = true;
 80a1276:	7063      	strb	r3, [r4, #1]
 80a1278:	7023      	strb	r3, [r4, #0]
 80a127a:	bd10      	pop	{r4, pc}

080a127c <_ZN14TinyGPSDecimal3setEPKc>:
}

void TinyGPSDecimal::set(const char *term) { newval = TinyGPSPlus::parseDecimal(term); }
 80a127c:	b510      	push	{r4, lr}
 80a127e:	4604      	mov	r4, r0
 80a1280:	4608      	mov	r0, r1
 80a1282:	f7ff ff47 	bl	80a1114 <_ZN11TinyGPSPlus12parseDecimalEPKc>
 80a1286:	60e0      	str	r0, [r4, #12]
 80a1288:	bd10      	pop	{r4, pc}

080a128a <_ZN14TinyGPSInteger6commitEv>:

void TinyGPSInteger::commit()
{
 80a128a:	b510      	push	{r4, lr}
    val = newval;
 80a128c:	68c3      	ldr	r3, [r0, #12]
}

void TinyGPSDecimal::set(const char *term) { newval = TinyGPSPlus::parseDecimal(term); }

void TinyGPSInteger::commit()
{
 80a128e:	4604      	mov	r4, r0
    val = newval;
 80a1290:	6083      	str	r3, [r0, #8]
 80a1292:	f001 fefb 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
    lastCommitTime = millis();
    valid = updated = true;
 80a1296:	2301      	movs	r3, #1
void TinyGPSDecimal::set(const char *term) { newval = TinyGPSPlus::parseDecimal(term); }

void TinyGPSInteger::commit()
{
    val = newval;
    lastCommitTime = millis();
 80a1298:	6060      	str	r0, [r4, #4]
    valid = updated = true;
 80a129a:	7063      	strb	r3, [r4, #1]
 80a129c:	7023      	strb	r3, [r4, #0]
 80a129e:	bd10      	pop	{r4, pc}

080a12a0 <_ZN14TinyGPSInteger3setEPKc>:
}

void TinyGPSInteger::set(const char *term) { newval = atol(term); }
 80a12a0:	b510      	push	{r4, lr}
 80a12a2:	4604      	mov	r4, r0
 80a12a4:	4608      	mov	r0, r1
 80a12a6:	f003 fd11 	bl	80a4ccc <atol>
 80a12aa:	60e0      	str	r0, [r4, #12]
 80a12ac:	bd10      	pop	{r4, pc}

080a12ae <_ZN13TinyGPSCustom6commitEv>:
    // Insert this item into the GPS tree
    gps.insertCustom(this, _sentenceName, _termNumber);
}

void TinyGPSCustom::commit()
{
 80a12ae:	b510      	push	{r4, lr}
    strcpy(this->buffer, this->stagingBuffer);
 80a12b0:	4601      	mov	r1, r0
    // Insert this item into the GPS tree
    gps.insertCustom(this, _sentenceName, _termNumber);
}

void TinyGPSCustom::commit()
{
 80a12b2:	4604      	mov	r4, r0
    strcpy(this->buffer, this->stagingBuffer);
 80a12b4:	3010      	adds	r0, #16
 80a12b6:	f003 fe75 	bl	80a4fa4 <strcpy>
 80a12ba:	f001 fee7 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
    lastCommitTime = millis();
    valid = updated = true;
 80a12be:	2301      	movs	r3, #1
}

void TinyGPSCustom::commit()
{
    strcpy(this->buffer, this->stagingBuffer);
    lastCommitTime = millis();
 80a12c0:	6220      	str	r0, [r4, #32]
    valid = updated = true;
 80a12c2:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
 80a12c6:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
 80a12ca:	bd10      	pop	{r4, pc}

080a12cc <_ZN13TinyGPSCustom3setEPKc>:
}

void TinyGPSCustom::set(const char *term)
{
    strncpy(this->stagingBuffer, term, sizeof(this->stagingBuffer));
 80a12cc:	2210      	movs	r2, #16
 80a12ce:	f003 be8e 	b.w	80a4fee <strncpy>
	...

080a12d4 <_ZN11TinyGPSPlus16endOfTermHandlerEv>:
#define COMBINE(sentence_type, term_number) (((unsigned)(sentence_type) << 5) | term_number)

// Processes a just-completed term
// Returns true if new sentence has just passed checksum test and is validated
bool TinyGPSPlus::endOfTermHandler()
{
 80a12d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    // If it's the checksum term, and the checksum checks out, commit
    if(isChecksumTerm)
 80a12d6:	f890 50a9 	ldrb.w	r5, [r0, #169]	; 0xa9
#define COMBINE(sentence_type, term_number) (((unsigned)(sentence_type) << 5) | term_number)

// Processes a just-completed term
// Returns true if new sentence has just passed checksum test and is validated
bool TinyGPSPlus::endOfTermHandler()
{
 80a12da:	4604      	mov	r4, r0
    // If it's the checksum term, and the checksum checks out, commit
    if(isChecksumTerm)
 80a12dc:	2d00      	cmp	r5, #0
 80a12de:	d06b      	beq.n	80a13b8 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0xe4>
    {
        byte checksum = 16 * fromHex(term[0]) + fromHex(term[1]);
 80a12e0:	f890 10aa 	ldrb.w	r1, [r0, #170]	; 0xaa
 80a12e4:	f7ff ff06 	bl	80a10f4 <_ZN11TinyGPSPlus7fromHexEc>
 80a12e8:	f894 10ab 	ldrb.w	r1, [r4, #171]	; 0xab
 80a12ec:	4602      	mov	r2, r0
 80a12ee:	4620      	mov	r0, r4
 80a12f0:	f7ff ff00 	bl	80a10f4 <_ZN11TinyGPSPlus7fromHexEc>
        if(checksum == parity)
 80a12f4:	f894 30a8 	ldrb.w	r3, [r4, #168]	; 0xa8
 80a12f8:	eb00 1002 	add.w	r0, r0, r2, lsl #4
 80a12fc:	b2c0      	uxtb	r0, r0
 80a12fe:	4283      	cmp	r3, r0
 80a1300:	d153      	bne.n	80a13aa <_ZN11TinyGPSPlus16endOfTermHandlerEv+0xd6>
        {
            passedChecksumCount++;
 80a1302:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80a1306:	3301      	adds	r3, #1
 80a1308:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
            if(sentenceHasFix)
 80a130c:	f894 30bc 	ldrb.w	r3, [r4, #188]	; 0xbc
 80a1310:	b123      	cbz	r3, 80a131c <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x48>
                ++sentencesWithFixCount;
 80a1312:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 80a1316:	3301      	adds	r3, #1
 80a1318:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc

            switch(curSentenceType)
 80a131c:	f894 30b9 	ldrb.w	r3, [r4, #185]	; 0xb9
 80a1320:	b1c3      	cbz	r3, 80a1354 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x80>
 80a1322:	2b01      	cmp	r3, #1
 80a1324:	d12e      	bne.n	80a1384 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0xb0>
            {
            case GPS_SENTENCE_GPRMC:
                date.commit();
 80a1326:	f104 0038 	add.w	r0, r4, #56	; 0x38
 80a132a:	f7ff ff72 	bl	80a1212 <_ZN11TinyGPSDate6commitEv>
                time.commit();
 80a132e:	f104 0048 	add.w	r0, r4, #72	; 0x48
 80a1332:	f7ff ff7c 	bl	80a122e <_ZN11TinyGPSTime6commitEv>
                fix = sentenceHasFix;
 80a1336:	f894 30bc 	ldrb.w	r3, [r4, #188]	; 0xbc
 80a133a:	f884 30bd 	strb.w	r3, [r4, #189]	; 0xbd
                if(sentenceHasFix)
 80a133e:	b30b      	cbz	r3, 80a1384 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0xb0>
                {
                    location.commit();
 80a1340:	4620      	mov	r0, r4
 80a1342:	f7ff ff3b 	bl	80a11bc <_ZN15TinyGPSLocation6commitEv>
                    speed.commit();
 80a1346:	f104 0058 	add.w	r0, r4, #88	; 0x58
 80a134a:	f7ff ff8c 	bl	80a1266 <_ZN14TinyGPSDecimal6commitEv>
                    course.commit();
 80a134e:	f104 0068 	add.w	r0, r4, #104	; 0x68
 80a1352:	e015      	b.n	80a1380 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0xac>
                }
                break;
            case GPS_SENTENCE_GPGGA:
                time.commit();
 80a1354:	f104 0048 	add.w	r0, r4, #72	; 0x48
 80a1358:	f7ff ff69 	bl	80a122e <_ZN11TinyGPSTime6commitEv>
                fix = sentenceHasFix;
 80a135c:	f894 30bc 	ldrb.w	r3, [r4, #188]	; 0xbc
 80a1360:	f884 30bd 	strb.w	r3, [r4, #189]	; 0xbd
                if(sentenceHasFix)
 80a1364:	b133      	cbz	r3, 80a1374 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0xa0>
                {
                    location.commit();
 80a1366:	4620      	mov	r0, r4
 80a1368:	f7ff ff28 	bl	80a11bc <_ZN15TinyGPSLocation6commitEv>
                    altitude.commit();
 80a136c:	f104 0078 	add.w	r0, r4, #120	; 0x78
 80a1370:	f7ff ff79 	bl	80a1266 <_ZN14TinyGPSDecimal6commitEv>
                }
                satellites.commit();
 80a1374:	f104 0088 	add.w	r0, r4, #136	; 0x88
 80a1378:	f7ff ff87 	bl	80a128a <_ZN14TinyGPSInteger6commitEv>
                hdop.commit();
 80a137c:	f104 0098 	add.w	r0, r4, #152	; 0x98
 80a1380:	f7ff ff71 	bl	80a1266 <_ZN14TinyGPSDecimal6commitEv>
                break;
            }

            // Commit all custom listeners of this sentence type
            for(TinyGPSCustom *p = customCandidates;
 80a1384:	f8d4 60c4 	ldr.w	r6, [r4, #196]	; 0xc4
                p != NULL && strcmp(p->sentenceName, customCandidates->sentenceName) == 0;
 80a1388:	2e00      	cmp	r6, #0
 80a138a:	f000 80ce 	beq.w	80a152a <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x256>
 80a138e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 80a1392:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 80a1394:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80a1396:	f003 fdfb 	bl	80a4f90 <strcmp>
 80a139a:	2800      	cmp	r0, #0
 80a139c:	f040 80c5 	bne.w	80a152a <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x256>
                p = p->next)
                p->commit();
 80a13a0:	4630      	mov	r0, r6
 80a13a2:	f7ff ff84 	bl	80a12ae <_ZN13TinyGPSCustom6commitEv>
                hdop.commit();
                break;
            }

            // Commit all custom listeners of this sentence type
            for(TinyGPSCustom *p = customCandidates;
 80a13a6:	6b36      	ldr	r6, [r6, #48]	; 0x30
 80a13a8:	e7ee      	b.n	80a1388 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0xb4>
            return true;
        }

        else
        {
            ++failedChecksumCount;
 80a13aa:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
        }

        return false;
 80a13ae:	2500      	movs	r5, #0
            return true;
        }

        else
        {
            ++failedChecksumCount;
 80a13b0:	3301      	adds	r3, #1
 80a13b2:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
        }

        return false;
 80a13b6:	e0b8      	b.n	80a152a <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x256>
    }

    // the first term determines the sentence type
    if(curTermNumber == 0)
 80a13b8:	f890 20ba 	ldrb.w	r2, [r0, #186]	; 0xba
 80a13bc:	bb72      	cbnz	r2, 80a141c <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x148>
    {
        if(!strcmp(term, _GPRMCterm) || !strcmp(term, _GNRMCterm))
 80a13be:	f100 06aa 	add.w	r6, r0, #170	; 0xaa
 80a13c2:	495b      	ldr	r1, [pc, #364]	; (80a1530 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x25c>)
 80a13c4:	4630      	mov	r0, r6
 80a13c6:	f003 fde3 	bl	80a4f90 <strcmp>
 80a13ca:	b120      	cbz	r0, 80a13d6 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x102>
 80a13cc:	4959      	ldr	r1, [pc, #356]	; (80a1534 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x260>)
 80a13ce:	4630      	mov	r0, r6
 80a13d0:	f003 fdde 	bl	80a4f90 <strcmp>
 80a13d4:	b908      	cbnz	r0, 80a13da <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x106>
            curSentenceType = GPS_SENTENCE_GPRMC;
 80a13d6:	2301      	movs	r3, #1
 80a13d8:	e00c      	b.n	80a13f4 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x120>
        else if(!strcmp(term, _GPGGAterm) || !strcmp(term, _GNGGAterm))
 80a13da:	4957      	ldr	r1, [pc, #348]	; (80a1538 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x264>)
 80a13dc:	4630      	mov	r0, r6
 80a13de:	f003 fdd7 	bl	80a4f90 <strcmp>
 80a13e2:	b120      	cbz	r0, 80a13ee <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x11a>
 80a13e4:	4955      	ldr	r1, [pc, #340]	; (80a153c <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x268>)
 80a13e6:	4630      	mov	r0, r6
 80a13e8:	f003 fdd2 	bl	80a4f90 <strcmp>
 80a13ec:	b908      	cbnz	r0, 80a13f2 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x11e>
            curSentenceType = GPS_SENTENCE_GPGGA;
 80a13ee:	2300      	movs	r3, #0
 80a13f0:	e000      	b.n	80a13f4 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x120>
        else
            curSentenceType = GPS_SENTENCE_OTHER;
 80a13f2:	2302      	movs	r3, #2
 80a13f4:	f884 30b9 	strb.w	r3, [r4, #185]	; 0xb9

        // Any custom candidates of this sentence type?
        for(customCandidates = customElts;
 80a13f8:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 80a13fc:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
            customCandidates != NULL && strcmp(customCandidates->sentenceName, term) < 0;
 80a1400:	f8d4 70c4 	ldr.w	r7, [r4, #196]	; 0xc4
 80a1404:	2f00      	cmp	r7, #0
 80a1406:	f000 8090 	beq.w	80a152a <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x256>
 80a140a:	4631      	mov	r1, r6
 80a140c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80a140e:	f003 fdbf 	bl	80a4f90 <strcmp>
 80a1412:	2800      	cmp	r0, #0
 80a1414:	f280 8085 	bge.w	80a1522 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x24e>
            customCandidates = customCandidates->next)
 80a1418:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80a141a:	e7ef      	b.n	80a13fc <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x128>
            customCandidates = NULL;

        return false;
    }

    if(curSentenceType != GPS_SENTENCE_OTHER && term[0])
 80a141c:	f890 10b9 	ldrb.w	r1, [r0, #185]	; 0xb9
 80a1420:	2902      	cmp	r1, #2
 80a1422:	d066      	beq.n	80a14f2 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21e>
 80a1424:	f890 30aa 	ldrb.w	r3, [r0, #170]	; 0xaa
 80a1428:	2b00      	cmp	r3, #0
 80a142a:	d062      	beq.n	80a14f2 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21e>
        switch(COMBINE(curSentenceType, curTermNumber))
 80a142c:	ea42 1241 	orr.w	r2, r2, r1, lsl #5
 80a1430:	3a01      	subs	r2, #1
 80a1432:	2a28      	cmp	r2, #40	; 0x28
 80a1434:	d85d      	bhi.n	80a14f2 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21e>
 80a1436:	e8df f002 	tbb	[pc, r2]
 80a143a:	2015      	.short	0x2015
 80a143c:	46312a23 	.word	0x46312a23
 80a1440:	5c57534d 	.word	0x5c57534d
 80a1444:	5c5c5c5c 	.word	0x5c5c5c5c
 80a1448:	5c5c5c5c 	.word	0x5c5c5c5c
 80a144c:	5c5c5c5c 	.word	0x5c5c5c5c
 80a1450:	5c5c5c5c 	.word	0x5c5c5c5c
 80a1454:	5c5c5c5c 	.word	0x5c5c5c5c
 80a1458:	1b155c5c 	.word	0x1b155c5c
 80a145c:	312a2320 	.word	0x312a2320
 80a1460:	3c38      	.short	0x3c38
 80a1462:	40          	.byte	0x40
 80a1463:	00          	.byte	0x00
        {
        case COMBINE(GPS_SENTENCE_GPRMC, 1): // Time in both sentences
        case COMBINE(GPS_SENTENCE_GPGGA, 1):
            time.setTime(term);
 80a1464:	f100 01aa 	add.w	r1, r0, #170	; 0xaa
 80a1468:	3048      	adds	r0, #72	; 0x48
 80a146a:	f7ff feee 	bl	80a124a <_ZN11TinyGPSTime7setTimeEPKc>
            break;
 80a146e:	e040      	b.n	80a14f2 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21e>
        case COMBINE(GPS_SENTENCE_GPRMC, 2): // GPRMC validity
            sentenceHasFix = term[0] == 'A';
 80a1470:	f1a3 0041 	sub.w	r0, r3, #65	; 0x41
 80a1474:	4243      	negs	r3, r0
 80a1476:	4143      	adcs	r3, r0
 80a1478:	e029      	b.n	80a14ce <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x1fa>
    if (rawLngData.deg == 0.0 || rawLatData.deg == 0.0) { valid = false; }
}

void TinyGPSLocation::setLatitude(const char *term)
{
    TinyGPSPlus::parseDegrees(term, rawNewLatData);
 80a147a:	f100 011c 	add.w	r1, r0, #28
 80a147e:	e008      	b.n	80a1492 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x1be>
        case COMBINE(GPS_SENTENCE_GPGGA, 2):
            location.setLatitude(term);
            break;
        case COMBINE(GPS_SENTENCE_GPRMC, 4): // N/S
        case COMBINE(GPS_SENTENCE_GPGGA, 3):
            location.rawNewLatData.negative = term[0] == 'S';
 80a1480:	f1a3 0153 	sub.w	r1, r3, #83	; 0x53
 80a1484:	424b      	negs	r3, r1
 80a1486:	414b      	adcs	r3, r1
 80a1488:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
            break;
 80a148c:	e031      	b.n	80a14f2 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21e>
    TinyGPSPlus::parseDegrees(term, rawNewLatData);
}

void TinyGPSLocation::setLongitude(const char *term)
{
    TinyGPSPlus::parseDegrees(term, rawNewLngData);
 80a148e:	f100 0128 	add.w	r1, r0, #40	; 0x28
 80a1492:	f104 00aa 	add.w	r0, r4, #170	; 0xaa
 80a1496:	f7ff fe61 	bl	80a115c <_ZN11TinyGPSPlus12parseDegreesEPKcR10RawDegrees>
 80a149a:	e02a      	b.n	80a14f2 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21e>
        case COMBINE(GPS_SENTENCE_GPGGA, 4):
            location.setLongitude(term);
            break;
        case COMBINE(GPS_SENTENCE_GPRMC, 6): // E/W
        case COMBINE(GPS_SENTENCE_GPGGA, 5):
            location.rawNewLngData.negative = term[0] == 'W';
 80a149c:	f1a3 0257 	sub.w	r2, r3, #87	; 0x57
 80a14a0:	4253      	negs	r3, r2
 80a14a2:	4153      	adcs	r3, r2
 80a14a4:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
            break;
 80a14a8:	e023      	b.n	80a14f2 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21e>
        case COMBINE(GPS_SENTENCE_GPRMC, 7): // Speed (GPRMC)
            speed.set(term);
 80a14aa:	f100 01aa 	add.w	r1, r0, #170	; 0xaa
 80a14ae:	3058      	adds	r0, #88	; 0x58
 80a14b0:	e01d      	b.n	80a14ee <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21a>
            break;
        case COMBINE(GPS_SENTENCE_GPRMC, 8): // Course (GPRMC)
            course.set(term);
 80a14b2:	f100 01aa 	add.w	r1, r0, #170	; 0xaa
 80a14b6:	3068      	adds	r0, #104	; 0x68
 80a14b8:	e019      	b.n	80a14ee <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21a>
            break;
        case COMBINE(GPS_SENTENCE_GPRMC, 9): // Date (GPRMC)
            date.setDate(term);
 80a14ba:	f100 01aa 	add.w	r1, r0, #170	; 0xaa
 80a14be:	3038      	adds	r0, #56	; 0x38
 80a14c0:	f7ff feca 	bl	80a1258 <_ZN11TinyGPSDate7setDateEPKc>
            break;
 80a14c4:	e015      	b.n	80a14f2 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21e>
        case COMBINE(GPS_SENTENCE_GPGGA, 6): // Fix data (GPGGA)
            sentenceHasFix = term[0] > '0';
 80a14c6:	2b30      	cmp	r3, #48	; 0x30
 80a14c8:	bf94      	ite	ls
 80a14ca:	2300      	movls	r3, #0
 80a14cc:	2301      	movhi	r3, #1
 80a14ce:	f884 30bc 	strb.w	r3, [r4, #188]	; 0xbc
            break;
 80a14d2:	e00e      	b.n	80a14f2 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21e>
        case COMBINE(GPS_SENTENCE_GPGGA, 7): // Satellites used (GPGGA)
            satellites.set(term);
 80a14d4:	f100 01aa 	add.w	r1, r0, #170	; 0xaa
 80a14d8:	3088      	adds	r0, #136	; 0x88
 80a14da:	f7ff fee1 	bl	80a12a0 <_ZN14TinyGPSInteger3setEPKc>
            break;
 80a14de:	e008      	b.n	80a14f2 <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21e>
        case COMBINE(GPS_SENTENCE_GPGGA, 8): // HDOP
            hdop.set(term);
 80a14e0:	f100 01aa 	add.w	r1, r0, #170	; 0xaa
 80a14e4:	3098      	adds	r0, #152	; 0x98
 80a14e6:	e002      	b.n	80a14ee <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x21a>
            break;
        case COMBINE(GPS_SENTENCE_GPGGA, 9): // Altitude (GPGGA)
            altitude.set(term);
 80a14e8:	f100 01aa 	add.w	r1, r0, #170	; 0xaa
 80a14ec:	3078      	adds	r0, #120	; 0x78
 80a14ee:	f7ff fec5 	bl	80a127c <_ZN14TinyGPSDecimal3setEPKc>
            break;
        }

    // Set custom values as needed
    for(TinyGPSCustom *p = customCandidates;
 80a14f2:	f8d4 60c4 	ldr.w	r6, [r4, #196]	; 0xc4
        p != NULL && strcmp(p->sentenceName, customCandidates->sentenceName) == 0 &&
            p->termNumber <= curTermNumber;
        p = p->next)
        if(p->termNumber == curTermNumber)
            p->set(term);
 80a14f6:	f104 07aa 	add.w	r7, r4, #170	; 0xaa
            break;
        }

    // Set custom values as needed
    for(TinyGPSCustom *p = customCandidates;
        p != NULL && strcmp(p->sentenceName, customCandidates->sentenceName) == 0 &&
 80a14fa:	b1b6      	cbz	r6, 80a152a <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x256>
 80a14fc:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 80a1500:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 80a1502:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80a1504:	f003 fd44 	bl	80a4f90 <strcmp>
 80a1508:	b978      	cbnz	r0, 80a152a <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x256>
            p->termNumber <= curTermNumber;
 80a150a:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 80a150c:	f894 30ba 	ldrb.w	r3, [r4, #186]	; 0xba
            break;
        }

    // Set custom values as needed
    for(TinyGPSCustom *p = customCandidates;
        p != NULL && strcmp(p->sentenceName, customCandidates->sentenceName) == 0 &&
 80a1510:	429a      	cmp	r2, r3
 80a1512:	dc0a      	bgt.n	80a152a <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x256>
            p->termNumber <= curTermNumber;
        p = p->next)
        if(p->termNumber == curTermNumber)
 80a1514:	d103      	bne.n	80a151e <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x24a>
            p->set(term);
 80a1516:	4639      	mov	r1, r7
 80a1518:	4630      	mov	r0, r6
 80a151a:	f7ff fed7 	bl	80a12cc <_ZN13TinyGPSCustom3setEPKc>
            altitude.set(term);
            break;
        }

    // Set custom values as needed
    for(TinyGPSCustom *p = customCandidates;
 80a151e:	6b36      	ldr	r6, [r6, #48]	; 0x30
 80a1520:	e7eb      	b.n	80a14fa <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x226>
        // Any custom candidates of this sentence type?
        for(customCandidates = customElts;
            customCandidates != NULL && strcmp(customCandidates->sentenceName, term) < 0;
            customCandidates = customCandidates->next)
            ;
        if(customCandidates != NULL && strcmp(customCandidates->sentenceName, term) > 0)
 80a1522:	d002      	beq.n	80a152a <_ZN11TinyGPSPlus16endOfTermHandlerEv+0x256>
            customCandidates = NULL;
 80a1524:	2300      	movs	r3, #0
 80a1526:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
        p = p->next)
        if(p->termNumber == curTermNumber)
            p->set(term);

    return false;
}
 80a152a:	4628      	mov	r0, r5
 80a152c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a152e:	bf00      	nop
 80a1530:	080a599e 	.word	0x080a599e
 80a1534:	080a59a4 	.word	0x080a59a4
 80a1538:	080a59aa 	.word	0x080a59aa
 80a153c:	080a59b0 	.word	0x080a59b0

080a1540 <_ZN11TinyGPSPlus6encodeEc>:
//
// public methods
//

bool TinyGPSPlus::encode(char c)
{
 80a1540:	b538      	push	{r3, r4, r5, lr}
    ++encodedCharCount;
 80a1542:	f8d0 30c8 	ldr.w	r3, [r0, #200]	; 0xc8

    switch(c)
 80a1546:	2924      	cmp	r1, #36	; 0x24
// public methods
//

bool TinyGPSPlus::encode(char c)
{
    ++encodedCharCount;
 80a1548:	f103 0301 	add.w	r3, r3, #1
//
// public methods
//

bool TinyGPSPlus::encode(char c)
{
 80a154c:	4604      	mov	r4, r0
 80a154e:	460d      	mov	r5, r1
    ++encodedCharCount;
 80a1550:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8

    switch(c)
 80a1554:	d02a      	beq.n	80a15ac <_ZN11TinyGPSPlus6encodeEc+0x6c>
 80a1556:	f890 30bb 	ldrb.w	r3, [r0, #187]	; 0xbb
 80a155a:	d804      	bhi.n	80a1566 <_ZN11TinyGPSPlus6encodeEc+0x26>
 80a155c:	290a      	cmp	r1, #10
 80a155e:	d00c      	beq.n	80a157a <_ZN11TinyGPSPlus6encodeEc+0x3a>
 80a1560:	290d      	cmp	r1, #13
 80a1562:	d132      	bne.n	80a15ca <_ZN11TinyGPSPlus6encodeEc+0x8a>
 80a1564:	e009      	b.n	80a157a <_ZN11TinyGPSPlus6encodeEc+0x3a>
 80a1566:	292a      	cmp	r1, #42	; 0x2a
 80a1568:	d007      	beq.n	80a157a <_ZN11TinyGPSPlus6encodeEc+0x3a>
 80a156a:	292c      	cmp	r1, #44	; 0x2c
 80a156c:	d12d      	bne.n	80a15ca <_ZN11TinyGPSPlus6encodeEc+0x8a>
    {
    case ',': // term terminators
        parity ^= (uint8_t)c;
 80a156e:	f890 20a8 	ldrb.w	r2, [r0, #168]	; 0xa8
 80a1572:	f082 022c 	eor.w	r2, r2, #44	; 0x2c
 80a1576:	f880 20a8 	strb.w	r2, [r0, #168]	; 0xa8
    case '\r':
    case '\n':
    case '*':
    {
        bool isValidSentence = false;
        if(curTermOffset < sizeof(term))
 80a157a:	2b0e      	cmp	r3, #14
 80a157c:	f04f 0000 	mov.w	r0, #0
 80a1580:	d805      	bhi.n	80a158e <_ZN11TinyGPSPlus6encodeEc+0x4e>
        {
            term[curTermOffset] = 0;
 80a1582:	4423      	add	r3, r4
 80a1584:	f883 00aa 	strb.w	r0, [r3, #170]	; 0xaa
            isValidSentence = endOfTermHandler();
 80a1588:	4620      	mov	r0, r4
 80a158a:	f7ff fea3 	bl	80a12d4 <_ZN11TinyGPSPlus16endOfTermHandlerEv>
        }
        ++curTermNumber;
 80a158e:	f894 30ba 	ldrb.w	r3, [r4, #186]	; 0xba
 80a1592:	3301      	adds	r3, #1
 80a1594:	f884 30ba 	strb.w	r3, [r4, #186]	; 0xba
        curTermOffset = 0;
 80a1598:	2300      	movs	r3, #0
 80a159a:	f884 30bb 	strb.w	r3, [r4, #187]	; 0xbb
        isChecksumTerm = c == '*';
 80a159e:	f1a5 032a 	sub.w	r3, r5, #42	; 0x2a
 80a15a2:	425d      	negs	r5, r3
 80a15a4:	415d      	adcs	r5, r3
 80a15a6:	f884 50a9 	strb.w	r5, [r4, #169]	; 0xa9
        return isValidSentence;
 80a15aa:	bd38      	pop	{r3, r4, r5, pc}
    }
    break;

    case '$': // sentence begin
        curTermNumber = curTermOffset = 0;
 80a15ac:	2000      	movs	r0, #0
        parity = 0;
        curSentenceType = GPS_SENTENCE_OTHER;
 80a15ae:	2302      	movs	r3, #2
        return isValidSentence;
    }
    break;

    case '$': // sentence begin
        curTermNumber = curTermOffset = 0;
 80a15b0:	f884 00bb 	strb.w	r0, [r4, #187]	; 0xbb
 80a15b4:	f884 00ba 	strb.w	r0, [r4, #186]	; 0xba
        parity = 0;
 80a15b8:	f884 00a8 	strb.w	r0, [r4, #168]	; 0xa8
        curSentenceType = GPS_SENTENCE_OTHER;
 80a15bc:	f884 30b9 	strb.w	r3, [r4, #185]	; 0xb9
        isChecksumTerm = false;
 80a15c0:	f884 00a9 	strb.w	r0, [r4, #169]	; 0xa9
        sentenceHasFix = false;
 80a15c4:	f884 00bc 	strb.w	r0, [r4, #188]	; 0xbc
        return false;
 80a15c8:	bd38      	pop	{r3, r4, r5, pc}

    default: // ordinary characters
        if(curTermOffset < sizeof(term) - 1)
 80a15ca:	2b0d      	cmp	r3, #13
            term[curTermOffset++] = c;
 80a15cc:	bf9f      	itttt	ls
 80a15ce:	1c5a      	addls	r2, r3, #1
 80a15d0:	191b      	addls	r3, r3, r4
 80a15d2:	f884 20bb 	strbls.w	r2, [r4, #187]	; 0xbb
 80a15d6:	f883 50aa 	strbls.w	r5, [r3, #170]	; 0xaa
        if(!isChecksumTerm)
 80a15da:	f894 00a9 	ldrb.w	r0, [r4, #169]	; 0xa9
 80a15de:	b928      	cbnz	r0, 80a15ec <_ZN11TinyGPSPlus6encodeEc+0xac>
            parity ^= c;
 80a15e0:	f894 10a8 	ldrb.w	r1, [r4, #168]	; 0xa8
 80a15e4:	404d      	eors	r5, r1
 80a15e6:	f884 50a8 	strb.w	r5, [r4, #168]	; 0xa8
 80a15ea:	bd38      	pop	{r3, r4, r5, pc}
        return false;
 80a15ec:	2000      	movs	r0, #0
    }

    return false;
}
 80a15ee:	bd38      	pop	{r3, r4, r5, pc}

080a15f0 <_GLOBAL__sub_I__ZN11TinyGPSPlusC2Ev>:
 80a15f0:	f001 bcc4 	b.w	80a2f7c <HAL_Pin_Map>

080a15f4 <_GLOBAL__sub_I_MinimumSerial.cpp>:
 80a15f4:	f001 bcc2 	b.w	80a2f7c <HAL_Pin_Map>

080a15f8 <_GLOBAL__sub_I__ZN7istream3getEv>:
 80a15f8:	f001 bcc0 	b.w	80a2f7c <HAL_Pin_Map>

080a15fc <_ZN9FatVolume9cacheSyncEv>:
  FatCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t blockNumber, uint8_t options) {
    return m_fatCache.read(blockNumber,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
 80a15fc:	b510      	push	{r4, lr}
 80a15fe:	4604      	mov	r4, r0
    return m_cache.sync() && m_fatCache.sync() && syncBlocks();
 80a1600:	3024      	adds	r0, #36	; 0x24
 80a1602:	f000 feb1 	bl	80a2368 <_ZN8FatCache4syncEv>
 80a1606:	b128      	cbz	r0, 80a1614 <_ZN9FatVolume9cacheSyncEv+0x18>
 80a1608:	f504 700c 	add.w	r0, r4, #560	; 0x230
  }
 80a160c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  cache_t* cacheFetchFat(uint32_t blockNumber, uint8_t options) {
    return m_fatCache.read(blockNumber,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncBlocks();
 80a1610:	f000 beaa 	b.w	80a2368 <_ZN8FatCache4syncEv>
  }
 80a1614:	bd10      	pop	{r4, pc}

080a1616 <_ZN7FatFile11lfnChecksumEPh>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FatFile.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
 80a1616:	1e41      	subs	r1, r0, #1
 80a1618:	f100 020a 	add.w	r2, r0, #10
  uint8_t sum = 0;
 80a161c:	2000      	movs	r0, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
 80a161e:	0843      	lsrs	r3, r0, #1
 80a1620:	ea43 10c0 	orr.w	r0, r3, r0, lsl #7
 80a1624:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80a1628:	4418      	add	r0, r3
#include "FatFile.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
 80a162a:	428a      	cmp	r2, r1
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
 80a162c:	f000 00ff 	and.w	r0, r0, #255	; 0xff
#include "FatFile.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
 80a1630:	d1f5      	bne.n	80a161e <_ZN7FatFile11lfnChecksumEPh+0x8>
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
  }
  return sum;
}
 80a1632:	4770      	bx	lr

080a1634 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_>:
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            fname_t* fname, const char** ptr) {
 80a1634:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  int len = 0;
  int si;
  int dot;

  // Skip leading spaces.
  while (*path == ' ') {
 80a1638:	7803      	ldrb	r3, [r0, #0]
 80a163a:	1c44      	adds	r4, r0, #1
 80a163c:	2b20      	cmp	r3, #32
 80a163e:	d101      	bne.n	80a1644 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x10>
 80a1640:	4620      	mov	r0, r4
 80a1642:	e7f9      	b.n	80a1638 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4>
    path++;
  }
  fname->lfn = path;
 80a1644:	4605      	mov	r5, r0
  name[n - 1] = 0;
  return true;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(char c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
 80a1646:	4f70      	ldr	r7, [pc, #448]	; (80a1808 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1d4>)

  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;
 80a1648:	6088      	str	r0, [r1, #8]
 80a164a:	1a2c      	subs	r4, r5, r0

  for (len = 0; ; len++) {
    c = path[len];
 80a164c:	462e      	mov	r6, r5
 80a164e:	f815 3b01 	ldrb.w	r3, [r5], #1
    if (c == 0 || isDirSeparator(c)) {
 80a1652:	b30b      	cbz	r3, 80a1698 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x64>
 80a1654:	2b2f      	cmp	r3, #47	; 0x2f
 80a1656:	d101      	bne.n	80a165c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x28>
 80a1658:	1903      	adds	r3, r0, r4
 80a165a:	e017      	b.n	80a168c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x58>
  name[n - 1] = 0;
  return true;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(char c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
 80a165c:	2b5c      	cmp	r3, #92	; 0x5c
 80a165e:	d102      	bne.n	80a1666 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x32>
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
 80a1660:	2000      	movs	r0, #0
 80a1662:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  name[n - 1] = 0;
  return true;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(char c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
 80a1666:	f1a3 0422 	sub.w	r4, r3, #34	; 0x22
 80a166a:	b2e4      	uxtb	r4, r4
 80a166c:	2c1d      	cmp	r4, #29
 80a166e:	d803      	bhi.n	80a1678 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x44>
 80a1670:	fa27 f404 	lsr.w	r4, r7, r4
 80a1674:	07e4      	lsls	r4, r4, #31
 80a1676:	d4f3      	bmi.n	80a1660 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2c>
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
 80a1678:	f003 04bf 	and.w	r4, r3, #191	; 0xbf
 80a167c:	2c3c      	cmp	r4, #60	; 0x3c
 80a167e:	d0ef      	beq.n	80a1660 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2c>
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
 80a1680:	3b20      	subs	r3, #32
 80a1682:	2b5e      	cmp	r3, #94	; 0x5e
 80a1684:	d9e1      	bls.n	80a164a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x16>
 80a1686:	e7eb      	b.n	80a1660 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2c>
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
 80a1688:	2d2f      	cmp	r5, #47	; 0x2f
 80a168a:	d105      	bne.n	80a1698 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x64>
 80a168c:	461e      	mov	r6, r3
 80a168e:	f813 5b01 	ldrb.w	r5, [r3], #1
 80a1692:	2d20      	cmp	r5, #32
 80a1694:	d1f8      	bne.n	80a1688 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x54>
 80a1696:	e7f9      	b.n	80a168c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x58>
  *ptr = &path[end];
 80a1698:	6016      	str	r6, [r2, #0]
 80a169a:	1903      	adds	r3, r0, r4

  // Back over spaces and dots.
  while (len) {
 80a169c:	4298      	cmp	r0, r3
 80a169e:	ebc0 0803 	rsb	r8, r0, r3
 80a16a2:	d009      	beq.n	80a16b8 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x84>
    c = path[len - 1];
 80a16a4:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    if (c != '.' && c != ' ') {
 80a16a8:	2a2e      	cmp	r2, #46	; 0x2e
 80a16aa:	d0f7      	beq.n	80a169c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x68>
 80a16ac:	2a20      	cmp	r2, #32
 80a16ae:	d0f5      	beq.n	80a169c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x68>
      break;
    }
    len--;
  }
  // Max length of LFN is 255.
  if (len > 255) {
 80a16b0:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
 80a16b4:	dcd4      	bgt.n	80a1660 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2c>
 80a16b6:	e001      	b.n	80a16bc <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x88>
 80a16b8:	f04f 0800 	mov.w	r8, #0
    return false;
  }
  fname->len = len;
 80a16bc:	f8c1 8004 	str.w	r8, [r1, #4]
 80a16c0:	f101 030c 	add.w	r3, r1, #12
 80a16c4:	f101 0217 	add.w	r2, r1, #23
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
 80a16c8:	2420      	movs	r4, #32
 80a16ca:	f803 4f01 	strb.w	r4, [r3, #1]!
  if (len > 255) {
    return false;
  }
  fname->len = len;
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
 80a16ce:	4293      	cmp	r3, r2
 80a16d0:	d1fb      	bne.n	80a16ca <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x96>
 80a16d2:	4603      	mov	r3, r0
 80a16d4:	1a1a      	subs	r2, r3, r0
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
 80a16d6:	f813 4b01 	ldrb.w	r4, [r3], #1
 80a16da:	2c2e      	cmp	r4, #46	; 0x2e
 80a16dc:	d0fa      	beq.n	80a16d4 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xa0>
 80a16de:	2c20      	cmp	r4, #32
 80a16e0:	d0f8      	beq.n	80a16d4 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xa0>
  // Not 8.3 if leading dot or space.
  is83 = !si;
 80a16e2:	fab2 f482 	clz	r4, r2

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
 80a16e6:	f108 36ff 	add.w	r6, r8, #4294967295
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
  // Not 8.3 if leading dot or space.
  is83 = !si;
 80a16ea:	0964      	lsrs	r4, r4, #5

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
 80a16ec:	1c73      	adds	r3, r6, #1
 80a16ee:	d107      	bne.n	80a1700 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xcc>
 80a16f0:	2700      	movs	r7, #0
 80a16f2:	f04f 0e07 	mov.w	lr, #7
 80a16f6:	463d      	mov	r5, r7
 80a16f8:	46ba      	mov	sl, r7
 80a16fa:	f04f 0908 	mov.w	r9, #8
 80a16fe:	e009      	b.n	80a1714 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xe0>
 80a1700:	5d83      	ldrb	r3, [r0, r6]
 80a1702:	2b2e      	cmp	r3, #46	; 0x2e
 80a1704:	d0f4      	beq.n	80a16f0 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xbc>
 80a1706:	3e01      	subs	r6, #1
 80a1708:	e7f0      	b.n	80a16ec <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xb8>
  for (; si < len; si++) {
    c = path[si];
 80a170a:	5c83      	ldrb	r3, [r0, r2]
    if (c == ' ' || (c == '.' && dot != si)) {
 80a170c:	2b20      	cmp	r3, #32
 80a170e:	d104      	bne.n	80a171a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xe6>
      is83 = false;
 80a1710:	2400      	movs	r4, #0
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
 80a1712:	3201      	adds	r2, #1
 80a1714:	4542      	cmp	r2, r8
 80a1716:	dbf8      	blt.n	80a170a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xd6>
 80a1718:	e04b      	b.n	80a17b2 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x17e>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
 80a171a:	2b2e      	cmp	r3, #46	; 0x2e
 80a171c:	d102      	bne.n	80a1724 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf0>
 80a171e:	42b2      	cmp	r2, r6
 80a1720:	d1f6      	bne.n	80a1710 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xdc>
 80a1722:	e003      	b.n	80a172c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf8>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character else false.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
 80a1724:	2b22      	cmp	r3, #34	; 0x22
 80a1726:	d017      	beq.n	80a1758 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x124>
 80a1728:	2b7c      	cmp	r3, #124	; 0x7c
 80a172a:	d015      	beq.n	80a1758 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x124>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
 80a172c:	f1a3 0c2a 	sub.w	ip, r3, #42	; 0x2a
 80a1730:	f1bc 0f05 	cmp.w	ip, #5
 80a1734:	d801      	bhi.n	80a173a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x106>
 80a1736:	2b2d      	cmp	r3, #45	; 0x2d
 80a1738:	d10e      	bne.n	80a1758 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x124>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
 80a173a:	f1a3 0c3a 	sub.w	ip, r3, #58	; 0x3a
 80a173e:	f1bc 0f05 	cmp.w	ip, #5
 80a1742:	d909      	bls.n	80a1758 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x124>
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
 80a1744:	f1a3 0c5b 	sub.w	ip, r3, #91	; 0x5b
 80a1748:	f1bc 0f02 	cmp.w	ip, #2
 80a174c:	d904      	bls.n	80a1758 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x124>
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
 80a174e:	f1a3 0c21 	sub.w	ip, r3, #33	; 0x21
 80a1752:	f1bc 0f5d 	cmp.w	ip, #93	; 0x5d
 80a1756:	d902      	bls.n	80a175e <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x12a>
 80a1758:	42b2      	cmp	r2, r6
 80a175a:	d10e      	bne.n	80a177a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x146>
 80a175c:	e049      	b.n	80a17f2 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1be>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
 80a175e:	42b2      	cmp	r2, r6
 80a1760:	d047      	beq.n	80a17f2 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1be>
 80a1762:	4575      	cmp	r5, lr
 80a1764:	d821      	bhi.n	80a17aa <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x176>
      si = dot;
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = DIR_NT_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
 80a1766:	f1a3 0c61 	sub.w	ip, r3, #97	; 0x61
 80a176a:	f1bc 0f19 	cmp.w	ip, #25
 80a176e:	d808      	bhi.n	80a1782 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x14e>
        c += 'A' - 'a';
 80a1770:	3b20      	subs	r3, #32
 80a1772:	b2db      	uxtb	r3, r3
        lc |= bit;
 80a1774:	ea49 0707 	orr.w	r7, r9, r7
 80a1778:	e00a      	b.n	80a1790 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x15c>
    }
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
 80a177a:	4575      	cmp	r5, lr
 80a177c:	d815      	bhi.n	80a17aa <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x176>
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
      is83 = false;
 80a177e:	2400      	movs	r4, #0
      c = '_';
 80a1780:	235f      	movs	r3, #95	; 0x5f
      bit = DIR_NT_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
 80a1782:	f1a3 0c41 	sub.w	ip, r3, #65	; 0x41
 80a1786:	f1bc 0f19 	cmp.w	ip, #25
        uc |= bit;
 80a178a:	bf98      	it	ls
 80a178c:	ea49 0a0a 	orrls.w	sl, r9, sl
      }
      fname->sfn[i++] = c;
 80a1790:	f105 0c01 	add.w	ip, r5, #1
 80a1794:	fa5f fc8c 	uxtb.w	ip, ip
 80a1798:	440d      	add	r5, r1
      if (i < 7) {
 80a179a:	f1bc 0f06 	cmp.w	ip, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
 80a179e:	736b      	strb	r3, [r5, #13]
      if (i < 7) {
 80a17a0:	d801      	bhi.n	80a17a6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x172>
        fname->seqPos = i;
 80a17a2:	f881 c00c 	strb.w	ip, [r1, #12]
 80a17a6:	4665      	mov	r5, ip
 80a17a8:	e7b3      	b.n	80a1712 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xde>
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
 80a17aa:	f1be 0f0a 	cmp.w	lr, #10
 80a17ae:	d117      	bne.n	80a17e0 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1ac>
        // Done - extension longer than three characters.
        is83 = false;
        break;
      }
      if (si != dot) {
        is83 = false;
 80a17b0:	2400      	movs	r4, #0
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
 80a17b2:	7b4b      	ldrb	r3, [r1, #13]
 80a17b4:	2b20      	cmp	r3, #32
 80a17b6:	f43f af53 	beq.w	80a1660 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2c>
    return false;
  }

  if (is83) {
 80a17ba:	b13c      	cbz	r4, 80a17cc <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x198>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
 80a17bc:	ea1a 0f07 	tst.w	sl, r7
 80a17c0:	bf18      	it	ne
 80a17c2:	2702      	movne	r7, #2
 80a17c4:	700f      	strb	r7, [r1, #0]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
 80a17c6:	2001      	movs	r0, #1
 80a17c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
 80a17cc:	7b0b      	ldrb	r3, [r1, #12]
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
 80a17ce:	2001      	movs	r0, #1
 80a17d0:	7008      	strb	r0, [r1, #0]
    fname->sfn[fname->seqPos] = '~';
 80a17d2:	4419      	add	r1, r3
 80a17d4:	237e      	movs	r3, #126	; 0x7e
 80a17d6:	734b      	strb	r3, [r1, #13]
    fname->sfn[fname->seqPos + 1] = '1';
 80a17d8:	2331      	movs	r3, #49	; 0x31
 80a17da:	738b      	strb	r3, [r1, #14]
 80a17dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      }
      if (si != dot) {
        is83 = false;
      }
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
 80a17e0:	42b2      	cmp	r2, r6
 80a17e2:	dce5      	bgt.n	80a17b0 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x17c>
 80a17e4:	4632      	mov	r2, r6
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
 80a17e6:	f04f 0e0a 	mov.w	lr, #10
      i = 8;    // Place for extension.
 80a17ea:	2508      	movs	r5, #8
      bit = DIR_NT_LC_EXT;  // bit for extension.
 80a17ec:	f04f 0910 	mov.w	r9, #16
 80a17f0:	e78e      	b.n	80a1710 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xdc>
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
 80a17f2:	f1be 0f0a 	cmp.w	lr, #10
 80a17f6:	d0db      	beq.n	80a17b0 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x17c>
 80a17f8:	4632      	mov	r2, r6
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
 80a17fa:	f04f 0e0a 	mov.w	lr, #10
      i = 8;    // Place for extension.
 80a17fe:	2508      	movs	r5, #8
      bit = DIR_NT_LC_EXT;  // bit for extension.
 80a1800:	f04f 0910 	mov.w	r9, #16
 80a1804:	e785      	b.n	80a1712 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xde>
 80a1806:	bf00      	nop
 80a1808:	31000101 	.word	0x31000101

080a180c <_ZN7FatFile12lfnUniqueSfnEP7fname_t>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
 80a180c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80a1810:	4606      	mov	r6, r0
 80a1812:	460d      	mov	r5, r1
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
 80a1814:	f891 900c 	ldrb.w	r9, [r1, #12]
 80a1818:	2402      	movs	r4, #2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
 80a181a:	277e      	movs	r7, #126	; 0x7e
        goto fail;
      }
      if (dir->name[0] == DIR_NAME_FREE) {
        goto done;
      }
      if (DIR_IS_FILE_OR_SUBDIR(dir) && !memcmp(fname->sfn, dir->name, 11)) {
 80a181c:	f101 080d 	add.w	r8, r1, #13
  for (uint8_t seq = 2; seq < 100; seq++) {
    if (seq < FIRST_HASH_SEQ) {
      fname->sfn[pos + 1] = '0' + seq;
    } else {
      DBG_PRINT_IF(seq > FIRST_HASH_SEQ);
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
 80a1820:	6869      	ldr	r1, [r5, #4]
 80a1822:	68aa      	ldr	r2, [r5, #8]
 80a1824:	1863      	adds	r3, r4, r1
 80a1826:	b29b      	uxth	r3, r3
 80a1828:	4411      	add	r1, r2
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
 80a182a:	4291      	cmp	r1, r2
 80a182c:	d006      	beq.n	80a183c <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x30>
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
 80a182e:	f812 0b01 	ldrb.w	r0, [r2], #1
 80a1832:	eb03 1343 	add.w	r3, r3, r3, lsl #5
 80a1836:	4043      	eors	r3, r0
 80a1838:	b29b      	uxth	r3, r3
 80a183a:	e7f6      	b.n	80a182a <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x1e>
 80a183c:	f1b9 0f03 	cmp.w	r9, #3
 80a1840:	bf28      	it	cs
 80a1842:	f04f 0903 	movcs.w	r9, #3
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
 80a1846:	f109 0204 	add.w	r2, r9, #4
 80a184a:	b2d2      	uxtb	r2, r2
        uint8_t h = hex & 0XF;
 80a184c:	f003 010f 	and.w	r1, r3, #15
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
 80a1850:	18a8      	adds	r0, r5, r2
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
 80a1852:	3a01      	subs	r2, #1
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
 80a1854:	2909      	cmp	r1, #9
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
 80a1856:	b2d2      	uxtb	r2, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
 80a1858:	bf94      	ite	ls
 80a185a:	3130      	addls	r1, #48	; 0x30
 80a185c:	3137      	addhi	r1, #55	; 0x37
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
 80a185e:	4591      	cmp	r9, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
 80a1860:	7341      	strb	r1, [r0, #13]
        hex >>= 4;
 80a1862:	ea4f 1313 	mov.w	r3, r3, lsr #4
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
 80a1866:	d3f1      	bcc.n	80a184c <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x40>
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
 80a1868:	eb05 0309 	add.w	r3, r5, r9
 80a186c:	735f      	strb	r7, [r3, #13]
   * the value false is returned for failure.
   */
  static bool remove(FatFile* dirFile, const char* path);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
 80a186e:	2100      	movs	r1, #0
 80a1870:	4630      	mov	r0, r6
 80a1872:	f000 fb56 	bl	80a1f22 <_ZN7FatFile7seekSetEm>
    rewind();
    while (1) {
      dir = readDirCache(true);
 80a1876:	2101      	movs	r1, #1
 80a1878:	4630      	mov	r0, r6
 80a187a:	f000 fb35 	bl	80a1ee8 <_ZN7FatFile12readDirCacheEb>
      if (!dir) {
 80a187e:	4601      	mov	r1, r0
 80a1880:	b928      	cbnz	r0, 80a188e <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x82>
        if (!getError()) {
 80a1882:	7870      	ldrb	r0, [r6, #1]
 80a1884:	fab0 f080 	clz	r0, r0
 80a1888:	0940      	lsrs	r0, r0, #5
 80a188a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == DIR_NAME_FREE) {
 80a188e:	7803      	ldrb	r3, [r0, #0]
 80a1890:	b14b      	cbz	r3, 80a18a6 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x9a>
        goto done;
      }
      if (DIR_IS_FILE_OR_SUBDIR(dir) && !memcmp(fname->sfn, dir->name, 11)) {
 80a1892:	7ac3      	ldrb	r3, [r0, #11]
 80a1894:	071b      	lsls	r3, r3, #28
 80a1896:	d4ee      	bmi.n	80a1876 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x6a>
 80a1898:	220b      	movs	r2, #11
 80a189a:	4640      	mov	r0, r8
 80a189c:	f003 fb20 	bl	80a4ee0 <memcmp>
 80a18a0:	2800      	cmp	r0, #0
 80a18a2:	d1e8      	bne.n	80a1876 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x6a>
 80a18a4:	e002      	b.n	80a18ac <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0xa0>

fail:
  return false;

done:
  return true;
 80a18a6:	2001      	movs	r0, #1
 80a18a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a18ac:	3401      	adds	r4, #1
 80a18ae:	b2a4      	uxth	r4, r4
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = 2; seq < 100; seq++) {
 80a18b0:	2c64      	cmp	r4, #100	; 0x64
 80a18b2:	d1b5      	bne.n	80a1820 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x14>
fail:
  return false;

done:
  return true;
}
 80a18b4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080a18b8 <_ZN7FatFile4openEPS_P7fname_ti>:
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
 80a18b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a18bc:	469b      	mov	fp, r3
  uint16_t curIndex;
  dir_t* dir;
  ldir_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
 80a18be:	780b      	ldrb	r3, [r1, #0]
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
 80a18c0:	b089      	sub	sp, #36	; 0x24
  uint16_t curIndex;
  dir_t* dir;
  ldir_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
 80a18c2:	f013 0f70 	tst.w	r3, #112	; 0x70
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
 80a18c6:	9005      	str	r0, [sp, #20]
 80a18c8:	460e      	mov	r6, r1
 80a18ca:	4691      	mov	r9, r2
  uint16_t curIndex;
  dir_t* dir;
  ldir_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
 80a18cc:	d101      	bne.n	80a18d2 <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
    goto fail;
  }
  return true;

fail:
  return false;
 80a18ce:	2000      	movs	r0, #0
 80a18d0:	e1a0      	b.n	80a1c14 <_ZN7FatFile4openEPS_P7fname_ti+0x35c>
  uint16_t curIndex;
  dir_t* dir;
  ldir_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
 80a18d2:	9b05      	ldr	r3, [sp, #20]
 80a18d4:	781b      	ldrb	r3, [r3, #0]
 80a18d6:	2b00      	cmp	r3, #0
 80a18d8:	d1f9      	bne.n	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
  uint8_t chksum = 0;
  uint16_t freeIndex = 0;
  uint16_t curIndex;
  dir_t* dir;
  ldir_t* ldir;
  size_t len = fname->len;
 80a18da:	6853      	ldr	r3, [r2, #4]
 80a18dc:	9302      	str	r3, [sp, #8]
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
 80a18de:	7813      	ldrb	r3, [r2, #0]
 80a18e0:	079b      	lsls	r3, r3, #30
 80a18e2:	f000 818d 	beq.w	80a1c00 <_ZN7FatFile4openEPS_P7fname_ti+0x348>
 80a18e6:	9b02      	ldr	r3, [sp, #8]
 80a18e8:	270d      	movs	r7, #13
 80a18ea:	330c      	adds	r3, #12
 80a18ec:	fbb3 f7f7 	udiv	r7, r3, r7
 80a18f0:	3701      	adds	r7, #1
 80a18f2:	b2ff      	uxtb	r7, r7
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t ord = 0;
  uint8_t chksum = 0;
  uint16_t freeIndex = 0;
 80a18f4:	f04f 0800 	mov.w	r8, #0
 80a18f8:	2100      	movs	r1, #0
 80a18fa:	4630      	mov	r0, r6
 80a18fc:	f000 fb11 	bl	80a1f22 <_ZN7FatFile7seekSetEm>
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
 80a1900:	4644      	mov	r4, r8
  uint8_t ord = 0;
 80a1902:	4643      	mov	r3, r8
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
 80a1904:	4645      	mov	r5, r8
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
 80a1906:	f109 020d 	add.w	r2, r9, #13
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t ord = 0;
  uint8_t chksum = 0;
 80a190a:	f8cd 800c 	str.w	r8, [sp, #12]
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
 80a190e:	f8cd 8010 	str.w	r8, [sp, #16]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
 80a1912:	9206      	str	r2, [sp, #24]
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
 80a1914:	6972      	ldr	r2, [r6, #20]
    dir = dirFile->readDirCache(true);
 80a1916:	2101      	movs	r1, #1
 80a1918:	4630      	mov	r0, r6
 80a191a:	9307      	str	r3, [sp, #28]
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
 80a191c:	f3c2 1a4f 	ubfx	sl, r2, #5, #16
    dir = dirFile->readDirCache(true);
 80a1920:	f000 fae2 	bl	80a1ee8 <_ZN7FatFile12readDirCacheEb>
    if (!dir) {
 80a1924:	9b07      	ldr	r3, [sp, #28]
 80a1926:	b920      	cbnz	r0, 80a1932 <_ZN7FatFile4openEPS_P7fname_ti+0x7a>
      if (dirFile->getError()) {
 80a1928:	7873      	ldrb	r3, [r6, #1]
 80a192a:	2b00      	cmp	r3, #0
 80a192c:	f000 8090 	beq.w	80a1a50 <_ZN7FatFile4openEPS_P7fname_ti+0x198>
 80a1930:	e7cd      	b.n	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == DIR_NAME_FREE) {
 80a1932:	7802      	ldrb	r2, [r0, #0]
 80a1934:	2ae5      	cmp	r2, #229	; 0xe5
 80a1936:	d000      	beq.n	80a193a <_ZN7FatFile4openEPS_P7fname_ti+0x82>
 80a1938:	b942      	cbnz	r2, 80a194c <_ZN7FatFile4openEPS_P7fname_ti+0x94>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
 80a193a:	2c00      	cmp	r4, #0
 80a193c:	bf08      	it	eq
 80a193e:	46d0      	moveq	r8, sl
    }
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == DIR_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
 80a1940:	42bc      	cmp	r4, r7
        freeFound++;
 80a1942:	bf3c      	itt	cc
 80a1944:	3401      	addcc	r4, #1
 80a1946:	b2e4      	uxtbcc	r4, r4
      }
      if (dir->name[0] == DIR_NAME_FREE) {
 80a1948:	b922      	cbnz	r2, 80a1954 <_ZN7FatFile4openEPS_P7fname_ti+0x9c>
 80a194a:	e081      	b.n	80a1a50 <_ZN7FatFile4openEPS_P7fname_ti+0x198>
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
 80a194c:	42bc      	cmp	r4, r7
 80a194e:	bf38      	it	cc
 80a1950:	2400      	movcc	r4, #0
 80a1952:	e003      	b.n	80a195c <_ZN7FatFile4openEPS_P7fname_ti+0xa4>
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
 80a1954:	2ae5      	cmp	r2, #229	; 0xe5
 80a1956:	d101      	bne.n	80a195c <_ZN7FatFile4openEPS_P7fname_ti+0xa4>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
 80a1958:	2500      	movs	r5, #0
 80a195a:	e7db      	b.n	80a1914 <_ZN7FatFile4openEPS_P7fname_ti+0x5c>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
 80a195c:	2a2e      	cmp	r2, #46	; 0x2e
 80a195e:	d0fb      	beq.n	80a1958 <_ZN7FatFile4openEPS_P7fname_ti+0xa0>
 80a1960:	7ac1      	ldrb	r1, [r0, #11]
      lfnOrd = 0;
    } else if (DIR_IS_LONG_NAME(dir)) {
 80a1962:	290f      	cmp	r1, #15
 80a1964:	d152      	bne.n	80a1a0c <_ZN7FatFile4openEPS_P7fname_ti+0x154>
      ldir_t *ldir = reinterpret_cast<ldir_t*>(dir);
      if (!lfnOrd) {
 80a1966:	b93d      	cbnz	r5, 80a1978 <_ZN7FatFile4openEPS_P7fname_ti+0xc0>
        if ((ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) == 0) {
 80a1968:	0651      	lsls	r1, r2, #25
 80a196a:	d5d3      	bpl.n	80a1914 <_ZN7FatFile4openEPS_P7fname_ti+0x5c>
          continue;
        }
        lfnOrd = ord = ldir->ord & 0X1F;
        chksum = ldir->chksum;
 80a196c:	7b43      	ldrb	r3, [r0, #13]
      ldir_t *ldir = reinterpret_cast<ldir_t*>(dir);
      if (!lfnOrd) {
        if ((ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = ord = ldir->ord & 0X1F;
 80a196e:	f002 051f 	and.w	r5, r2, #31
        chksum = ldir->chksum;
 80a1972:	9303      	str	r3, [sp, #12]
      ldir_t *ldir = reinterpret_cast<ldir_t*>(dir);
      if (!lfnOrd) {
        if ((ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = ord = ldir->ord & 0X1F;
 80a1974:	462b      	mov	r3, r5
 80a1976:	e007      	b.n	80a1988 <_ZN7FatFile4openEPS_P7fname_ti+0xd0>
        chksum = ldir->chksum;
      } else if (ldir->ord != --ord || chksum != ldir->chksum) {
 80a1978:	3b01      	subs	r3, #1
 80a197a:	b2db      	uxtb	r3, r3
 80a197c:	429a      	cmp	r2, r3
 80a197e:	d1eb      	bne.n	80a1958 <_ZN7FatFile4openEPS_P7fname_ti+0xa0>
 80a1980:	7b42      	ldrb	r2, [r0, #13]
 80a1982:	9903      	ldr	r1, [sp, #12]
 80a1984:	4291      	cmp	r1, r2
 80a1986:	d1e7      	bne.n	80a1958 <_ZN7FatFile4openEPS_P7fname_ti+0xa0>
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(ord - 1);
 80a1988:	1e5a      	subs	r2, r3, #1
 80a198a:	f04f 0c0d 	mov.w	ip, #13
 80a198e:	fb0c fc02 	mul.w	ip, ip, r2
      if (k >= len) {
 80a1992:	9a02      	ldr	r2, [sp, #8]
 80a1994:	4562      	cmp	r2, ip
 80a1996:	d9df      	bls.n	80a1958 <_ZN7FatFile4openEPS_P7fname_ti+0xa0>
 80a1998:	f04f 0e00 	mov.w	lr, #0
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(ldir_t *ldir, uint8_t i) {
  if (i < LDIR_NAME1_DIM) {
 80a199c:	f1be 0f04 	cmp.w	lr, #4
 80a19a0:	fa5f f28e 	uxtb.w	r2, lr
 80a19a4:	d804      	bhi.n	80a19b0 <_ZN7FatFile4openEPS_P7fname_ti+0xf8>
    return ldir->name1[i];
 80a19a6:	eb00 024e 	add.w	r2, r0, lr, lsl #1
 80a19aa:	f8b2 2001 	ldrh.w	r2, [r2, #1]
 80a19ae:	e00c      	b.n	80a19ca <_ZN7FatFile4openEPS_P7fname_ti+0x112>
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
 80a19b0:	2a0a      	cmp	r2, #10
    return ldir->name2[i - LDIR_NAME1_DIM];
 80a19b2:	bf95      	itete	ls
 80a19b4:	f10e 32ff 	addls.w	r2, lr, #4294967295
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM + LDIR_NAME2_DIM)) {
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
 80a19b8:	f10e 0201 	addhi.w	r2, lr, #1
 */
static uint16_t lfnGetChar(ldir_t *ldir, uint8_t i) {
  if (i < LDIR_NAME1_DIM) {
    return ldir->name1[i];
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
    return ldir->name2[i - LDIR_NAME1_DIM];
 80a19bc:	eb00 0242 	addls.w	r2, r0, r2, lsl #1
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM + LDIR_NAME2_DIM)) {
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
 80a19c0:	eb00 0242 	addhi.w	r2, r0, r2, lsl #1
 */
static uint16_t lfnGetChar(ldir_t *ldir, uint8_t i) {
  if (i < LDIR_NAME1_DIM) {
    return ldir->name1[i];
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
    return ldir->name2[i - LDIR_NAME1_DIM];
 80a19c4:	bf94      	ite	ls
 80a19c6:	88d2      	ldrhls	r2, [r2, #6]
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM + LDIR_NAME2_DIM)) {
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
 80a19c8:	8892      	ldrhhi	r2, [r2, #4]
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
 80a19ca:	9902      	ldr	r1, [sp, #8]
 80a19cc:	4561      	cmp	r1, ip
 80a19ce:	d103      	bne.n	80a19d8 <_ZN7FatFile4openEPS_P7fname_ti+0x120>
          if (u != 0) {
            // Not found.
            lfnOrd = 0;
 80a19d0:	2a00      	cmp	r2, #0
 80a19d2:	bf18      	it	ne
 80a19d4:	2500      	movne	r5, #0
 80a19d6:	e79d      	b.n	80a1914 <_ZN7FatFile4openEPS_P7fname_ti+0x5c>
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
 80a19d8:	2aff      	cmp	r2, #255	; 0xff
 80a19da:	d8bd      	bhi.n	80a1958 <_ZN7FatFile4openEPS_P7fname_ti+0xa0>
 80a19dc:	b2d2      	uxtb	r2, r2
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
 80a19de:	f1a2 0141 	sub.w	r1, r2, #65	; 0x41
 80a19e2:	2919      	cmp	r1, #25
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
 80a19e4:	f8d9 1008 	ldr.w	r1, [r9, #8]
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
 80a19e8:	bf98      	it	ls
 80a19ea:	3220      	addls	r2, #32
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
 80a19ec:	f811 100c 	ldrb.w	r1, [r1, ip]
 80a19f0:	f10c 0a01 	add.w	sl, ip, #1
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
 80a19f4:	f1a1 0c41 	sub.w	ip, r1, #65	; 0x41
 80a19f8:	bf98      	it	ls
 80a19fa:	b2d2      	uxtbls	r2, r2
 80a19fc:	f1bc 0f19 	cmp.w	ip, #25
 80a1a00:	bf9c      	itt	ls
 80a1a02:	3120      	addls	r1, #32
 80a1a04:	b2c9      	uxtbls	r1, r1
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
 80a1a06:	4291      	cmp	r1, r2
 80a1a08:	d1a6      	bne.n	80a1958 <_ZN7FatFile4openEPS_P7fname_ti+0xa0>
 80a1a0a:	e0fb      	b.n	80a1c04 <_ZN7FatFile4openEPS_P7fname_ti+0x34c>
          // Not found.
          lfnOrd = 0;
          break;
        }
      }
    } else if (DIR_IS_FILE_OR_SUBDIR(dir)) {
 80a1a0c:	0709      	lsls	r1, r1, #28
 80a1a0e:	d4a3      	bmi.n	80a1958 <_ZN7FatFile4openEPS_P7fname_ti+0xa0>
      if (lfnOrd) {
 80a1a10:	b14d      	cbz	r5, 80a1a26 <_ZN7FatFile4openEPS_P7fname_ti+0x16e>
        if (1 == ord && lfnChecksum(dir->name) == chksum) {
 80a1a12:	2b01      	cmp	r3, #1
 80a1a14:	f47f af5b 	bne.w	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
 80a1a18:	f7ff fdfd 	bl	80a1616 <_ZN7FatFile11lfnChecksumEPh>
 80a1a1c:	9b03      	ldr	r3, [sp, #12]
 80a1a1e:	4283      	cmp	r3, r0
 80a1a20:	f47f af55 	bne.w	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
 80a1a24:	e00f      	b.n	80a1a46 <_ZN7FatFile4openEPS_P7fname_ti+0x18e>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
 80a1a26:	220b      	movs	r2, #11
 80a1a28:	9906      	ldr	r1, [sp, #24]
 80a1a2a:	9307      	str	r3, [sp, #28]
 80a1a2c:	f003 fa58 	bl	80a4ee0 <memcmp>
 80a1a30:	9b07      	ldr	r3, [sp, #28]
 80a1a32:	2800      	cmp	r0, #0
 80a1a34:	f47f af6e 	bne.w	80a1914 <_ZN7FatFile4openEPS_P7fname_ti+0x5c>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
 80a1a38:	f899 2000 	ldrb.w	r2, [r9]
 80a1a3c:	07d2      	lsls	r2, r2, #31
 80a1a3e:	d502      	bpl.n	80a1a46 <_ZN7FatFile4openEPS_P7fname_ti+0x18e>
          goto found;
        }
        fnameFound = true;
 80a1a40:	2201      	movs	r2, #1
 80a1a42:	9204      	str	r2, [sp, #16]
 80a1a44:	e766      	b.n	80a1914 <_ZN7FatFile4openEPS_P7fname_ti+0x5c>
    }
  }

found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
 80a1a46:	f41b 6f00 	tst.w	fp, #2048	; 0x800
 80a1a4a:	f000 80d1 	beq.w	80a1bf0 <_ZN7FatFile4openEPS_P7fname_ti+0x338>
 80a1a4e:	e73e      	b.n	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
  }
  goto open;

create:
  // don't create unless O_CREAT and write mode.
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
 80a1a50:	f41b 7f00 	tst.w	fp, #512	; 0x200
 80a1a54:	f43f af3b 	beq.w	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
 80a1a58:	f00b 0303 	and.w	r3, fp, #3
 80a1a5c:	3b01      	subs	r3, #1
 80a1a5e:	2b01      	cmp	r3, #1
 80a1a60:	f63f af35 	bhi.w	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // If at EOF start in next cluster.
  if (freeFound == 0) {
 80a1a64:	2c00      	cmp	r4, #0
 80a1a66:	bf08      	it	eq
 80a1a68:	46d0      	moveq	r8, sl
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
 80a1a6a:	42bc      	cmp	r4, r7
 80a1a6c:	d302      	bcc.n	80a1a74 <_ZN7FatFile4openEPS_P7fname_ti+0x1bc>
    if (dirFile->m_vol->blocksPerCluster() > 1) {
      break;
    }
    freeFound += 16;
  }
  if (fnameFound) {
 80a1a6e:	9b04      	ldr	r3, [sp, #16]
 80a1a70:	b9cb      	cbnz	r3, 80a1aa6 <_ZN7FatFile4openEPS_P7fname_ti+0x1ee>
 80a1a72:	e01f      	b.n	80a1ab4 <_ZN7FatFile4openEPS_P7fname_ti+0x1fc>
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
 80a1a74:	2100      	movs	r1, #0
 80a1a76:	4630      	mov	r0, r6
 80a1a78:	f000 fa36 	bl	80a1ee8 <_ZN7FatFile12readDirCacheEb>
    if (!dir) {
 80a1a7c:	b910      	cbnz	r0, 80a1a84 <_ZN7FatFile4openEPS_P7fname_ti+0x1cc>
      if (dirFile->getError()) {
 80a1a7e:	7873      	ldrb	r3, [r6, #1]
 80a1a80:	b15b      	cbz	r3, 80a1a9a <_ZN7FatFile4openEPS_P7fname_ti+0x1e2>
 80a1a82:	e724      	b.n	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
 80a1a84:	3401      	adds	r4, #1
 80a1a86:	b2e4      	uxtb	r4, r4
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
 80a1a88:	e7ef      	b.n	80a1a6a <_ZN7FatFile4openEPS_P7fname_ti+0x1b2>
 80a1a8a:	68b3      	ldr	r3, [r6, #8]
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Done if more than one block per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->blocksPerCluster() > 1) {
 80a1a8c:	791b      	ldrb	r3, [r3, #4]
 80a1a8e:	2b01      	cmp	r3, #1
 80a1a90:	d8ed      	bhi.n	80a1a6e <_ZN7FatFile4openEPS_P7fname_ti+0x1b6>
      break;
    }
    freeFound += 16;
 80a1a92:	3410      	adds	r4, #16
 80a1a94:	b2e4      	uxtb	r4, r4
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
 80a1a96:	42a7      	cmp	r7, r4
 80a1a98:	d9e9      	bls.n	80a1a6e <_ZN7FatFile4openEPS_P7fname_ti+0x1b6>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
 80a1a9a:	4630      	mov	r0, r6
 80a1a9c:	f000 f8d2 	bl	80a1c44 <_ZN7FatFile13addDirClusterEv>
 80a1aa0:	2800      	cmp	r0, #0
 80a1aa2:	d1f2      	bne.n	80a1a8a <_ZN7FatFile4openEPS_P7fname_ti+0x1d2>
 80a1aa4:	e713      	b.n	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
      break;
    }
    freeFound += 16;
  }
  if (fnameFound) {
    if (!dirFile->lfnUniqueSfn(fname)) {
 80a1aa6:	4649      	mov	r1, r9
 80a1aa8:	4630      	mov	r0, r6
 80a1aaa:	f7ff feaf 	bl	80a180c <_ZN7FatFile12lfnUniqueSfnEP7fname_t>
 80a1aae:	2800      	cmp	r0, #0
 80a1ab0:	f43f af0d 	beq.w	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
      goto fail;
    }
  }
  if (!dirFile->seekSet(32UL*freeIndex)) {
 80a1ab4:	ea4f 1148 	mov.w	r1, r8, lsl #5
 80a1ab8:	4630      	mov	r0, r6
 80a1aba:	f000 fa32 	bl	80a1f22 <_ZN7FatFile7seekSetEm>
 80a1abe:	2800      	cmp	r0, #0
 80a1ac0:	f43f af05 	beq.w	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
 80a1ac4:	1e7d      	subs	r5, r7, #1
 80a1ac6:	b2ed      	uxtb	r5, r5
  for (uint8_t ord = lfnOrd ; ord ; ord--) {
 80a1ac8:	462c      	mov	r4, r5
    ldir = reinterpret_cast<ldir_t*>(dirFile->readDirCache());
 80a1aca:	f04f 0a00 	mov.w	sl, #0
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
    ldir->attr = DIR_ATT_LONG_NAME;
 80a1ace:	f04f 080f 	mov.w	r8, #15
 80a1ad2:	e041      	b.n	80a1b58 <_ZN7FatFile4openEPS_P7fname_ti+0x2a0>
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (uint8_t ord = lfnOrd ; ord ; ord--) {
    ldir = reinterpret_cast<ldir_t*>(dirFile->readDirCache());
 80a1ad4:	2100      	movs	r1, #0
 80a1ad6:	4630      	mov	r0, r6
 80a1ad8:	f000 fa06 	bl	80a1ee8 <_ZN7FatFile12readDirCacheEb>
    if (!ldir) {
 80a1adc:	4607      	mov	r7, r0
 80a1ade:	2800      	cmp	r0, #0
 80a1ae0:	f43f aef5 	beq.w	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
 80a1ae4:	68b2      	ldr	r2, [r6, #8]
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
 80a1ae6:	42ac      	cmp	r4, r5
  cache_t* block() {
    return &m_block;
  }
  /** Set current block dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
 80a1ae8:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 80a1aec:	f043 0301 	orr.w	r3, r3, #1
 80a1af0:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
 80a1af4:	bf14      	ite	ne
 80a1af6:	4622      	movne	r2, r4
 80a1af8:	f044 0240 	orreq.w	r2, r4, #64	; 0x40
 80a1afc:	7002      	strb	r2, [r0, #0]
    ldir->attr = DIR_ATT_LONG_NAME;
 80a1afe:	f880 800b 	strb.w	r8, [r0, #11]
    ldir->type = 0;
 80a1b02:	f880 a00c 	strb.w	sl, [r0, #12]
    ldir->chksum = lfnChecksum(fname->sfn);
 80a1b06:	f109 000d 	add.w	r0, r9, #13
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
 80a1b0a:	9203      	str	r2, [sp, #12]
    ldir->attr = DIR_ATT_LONG_NAME;
    ldir->type = 0;
    ldir->chksum = lfnChecksum(fname->sfn);
 80a1b0c:	f7ff fd83 	bl	80a1616 <_ZN7FatFile11lfnChecksumEPh>
    ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM] = c;
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(ldir_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->ord & 0X1F) - 1);
 80a1b10:	9a03      	ldr	r2, [sp, #12]
    }
    dirFile->m_vol->cacheDirty();
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
    ldir->attr = DIR_ATT_LONG_NAME;
    ldir->type = 0;
    ldir->chksum = lfnChecksum(fname->sfn);
 80a1b12:	7378      	strb	r0, [r7, #13]
    ldir->mustBeZero = 0;
 80a1b14:	f887 a01a 	strb.w	sl, [r7, #26]
 80a1b18:	f887 a01b 	strb.w	sl, [r7, #27]
    ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM] = c;
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(ldir_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->ord & 0X1F) - 1);
 80a1b1c:	f002 021f 	and.w	r2, r2, #31
 80a1b20:	230d      	movs	r3, #13
 80a1b22:	3a01      	subs	r2, #1
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
    ldir->attr = DIR_ATT_LONG_NAME;
    ldir->type = 0;
    ldir->chksum = lfnChecksum(fname->sfn);
    ldir->mustBeZero = 0;
    lfnPutName(ldir, fname->lfn, len);
 80a1b24:	f8d9 e008 	ldr.w	lr, [r9, #8]
    ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM] = c;
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(ldir_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->ord & 0X1F) - 1);
 80a1b28:	435a      	muls	r2, r3
 80a1b2a:	2300      	movs	r3, #0
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
 80a1b2c:	9902      	ldr	r1, [sp, #8]
 80a1b2e:	4291      	cmp	r1, r2
 80a1b30:	d915      	bls.n	80a1b5e <_ZN7FatFile4openEPS_P7fname_ti+0x2a6>
 80a1b32:	f81e 1002 	ldrb.w	r1, [lr, r2]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(ldir_t *ldir, uint8_t i, uint16_t c) {
  if (i < LDIR_NAME1_DIM) {
 80a1b36:	2b04      	cmp	r3, #4
 80a1b38:	fa5f fc83 	uxtb.w	ip, r3
 80a1b3c:	f103 0001 	add.w	r0, r3, #1
 80a1b40:	d813      	bhi.n	80a1b6a <_ZN7FatFile4openEPS_P7fname_ti+0x2b2>
    ldir->name1[i] = c;
 80a1b42:	eb07 0343 	add.w	r3, r7, r3, lsl #1
 80a1b46:	f8a3 1001 	strh.w	r1, [r3, #1]
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(ldir_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->ord & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
 80a1b4a:	280d      	cmp	r0, #13
 80a1b4c:	f102 0201 	add.w	r2, r2, #1
 80a1b50:	4603      	mov	r3, r0
 80a1b52:	d1eb      	bne.n	80a1b2c <_ZN7FatFile4openEPS_P7fname_ti+0x274>
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (uint8_t ord = lfnOrd ; ord ; ord--) {
 80a1b54:	3c01      	subs	r4, #1
 80a1b56:	b2e4      	uxtb	r4, r4
 80a1b58:	2c00      	cmp	r4, #0
 80a1b5a:	d1bb      	bne.n	80a1ad4 <_ZN7FatFile4openEPS_P7fname_ti+0x21c>
 80a1b5c:	e00e      	b.n	80a1b7c <_ZN7FatFile4openEPS_P7fname_ti+0x2c4>
}
//------------------------------------------------------------------------------
static void lfnPutName(ldir_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->ord & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
 80a1b5e:	bf14      	ite	ne
 80a1b60:	f04f 31ff 	movne.w	r1, #4294967295
 80a1b64:	2100      	moveq	r1, #0
 80a1b66:	b289      	uxth	r1, r1
 80a1b68:	e7e5      	b.n	80a1b36 <_ZN7FatFile4openEPS_P7fname_ti+0x27e>
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(ldir_t *ldir, uint8_t i, uint16_t c) {
  if (i < LDIR_NAME1_DIM) {
    ldir->name1[i] = c;
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
 80a1b6a:	f1bc 0f0a 	cmp.w	ip, #10
    ldir->name2[i - LDIR_NAME1_DIM] = c;
 80a1b6e:	bf94      	ite	ls
 80a1b70:	eb07 0343 	addls.w	r3, r7, r3, lsl #1
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM + LDIR_NAME2_DIM)) {
    ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM] = c;
 80a1b74:	eb07 0340 	addhi.w	r3, r7, r0, lsl #1
 80a1b78:	8099      	strh	r1, [r3, #4]
 80a1b7a:	e7e6      	b.n	80a1b4a <_ZN7FatFile4openEPS_P7fname_ti+0x292>
    ldir->type = 0;
    ldir->chksum = lfnChecksum(fname->sfn);
    ldir->mustBeZero = 0;
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
 80a1b7c:	6973      	ldr	r3, [r6, #20]
  dir = dirFile->readDirCache();
 80a1b7e:	4621      	mov	r1, r4
 80a1b80:	4630      	mov	r0, r6
    ldir->type = 0;
    ldir->chksum = lfnChecksum(fname->sfn);
    ldir->mustBeZero = 0;
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
 80a1b82:	f3c3 1a4f 	ubfx	sl, r3, #5, #16
  dir = dirFile->readDirCache();
 80a1b86:	f000 f9af 	bl	80a1ee8 <_ZN7FatFile12readDirCacheEb>
  if (!dir) {
 80a1b8a:	4607      	mov	r7, r0
 80a1b8c:	2800      	cmp	r0, #0
 80a1b8e:	f43f ae9e 	beq.w	80a18ce <_ZN7FatFile4openEPS_P7fname_ti+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(dir_t));
 80a1b92:	2220      	movs	r2, #32
 80a1b94:	4621      	mov	r1, r4
 80a1b96:	f003 f9bd 	bl	80a4f14 <memset>
  memcpy(dir->name, fname->sfn, 11);
 80a1b9a:	464b      	mov	r3, r9
 80a1b9c:	f853 2f0d 	ldr.w	r2, [r3, #13]!
 80a1ba0:	603a      	str	r2, [r7, #0]
 80a1ba2:	685a      	ldr	r2, [r3, #4]
 80a1ba4:	607a      	str	r2, [r7, #4]
 80a1ba6:	891a      	ldrh	r2, [r3, #8]
 80a1ba8:	813a      	strh	r2, [r7, #8]
 80a1baa:	7a9b      	ldrb	r3, [r3, #10]
 80a1bac:	72bb      	strb	r3, [r7, #10]

  // Set base-name and extension lower case bits.
  dir->reservedNT =  (DIR_NT_LC_BASE | DIR_NT_LC_EXT) & fname->flags;
 80a1bae:	f899 3000 	ldrb.w	r3, [r9]
 80a1bb2:	f003 0318 	and.w	r3, r3, #24
 80a1bb6:	733b      	strb	r3, [r7, #12]

  // set timestamps
  if (m_dateTime) {
 80a1bb8:	4b18      	ldr	r3, [pc, #96]	; (80a1c1c <_ZN7FatFile4openEPS_P7fname_ti+0x364>)
 80a1bba:	681b      	ldr	r3, [r3, #0]
 80a1bbc:	b12b      	cbz	r3, 80a1bca <_ZN7FatFile4openEPS_P7fname_ti+0x312>
    // call user date/time function
    m_dateTime(&dir->creationDate, &dir->creationTime);
 80a1bbe:	f107 010e 	add.w	r1, r7, #14
 80a1bc2:	f107 0010 	add.w	r0, r7, #16
 80a1bc6:	4798      	blx	r3
 80a1bc8:	e006      	b.n	80a1bd8 <_ZN7FatFile4openEPS_P7fname_ti+0x320>
  } else {
    // use default date/time
    dir->creationDate = FAT_DEFAULT_DATE;
 80a1bca:	2321      	movs	r3, #33	; 0x21
 80a1bcc:	743b      	strb	r3, [r7, #16]
 80a1bce:	2328      	movs	r3, #40	; 0x28
 80a1bd0:	747b      	strb	r3, [r7, #17]
    dir->creationTime = FAT_DEFAULT_TIME;
 80a1bd2:	2308      	movs	r3, #8
 80a1bd4:	73bc      	strb	r4, [r7, #14]
 80a1bd6:	73fb      	strb	r3, [r7, #15]
  }
  dir->lastAccessDate = dir->creationDate;
 80a1bd8:	8a3b      	ldrh	r3, [r7, #16]
 80a1bda:	827b      	strh	r3, [r7, #18]
  dir->lastWriteDate = dir->creationDate;
 80a1bdc:	833b      	strh	r3, [r7, #24]
  dir->lastWriteTime = dir->creationTime;
 80a1bde:	89fb      	ldrh	r3, [r7, #14]
 80a1be0:	82fb      	strh	r3, [r7, #22]

  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
 80a1be2:	68b2      	ldr	r2, [r6, #8]
 80a1be4:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 80a1be8:	f043 0301 	orr.w	r3, r3, #1
 80a1bec:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24

open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
 80a1bf0:	9500      	str	r5, [sp, #0]
 80a1bf2:	465b      	mov	r3, fp
 80a1bf4:	4652      	mov	r2, sl
 80a1bf6:	4631      	mov	r1, r6
 80a1bf8:	9805      	ldr	r0, [sp, #20]
 80a1bfa:	f000 f9db 	bl	80a1fb4 <_ZN7FatFile15openCachedEntryEPS_tih>
 80a1bfe:	e009      	b.n	80a1c14 <_ZN7FatFile4openEPS_P7fname_ti+0x35c>
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
 80a1c00:	2701      	movs	r7, #1
 80a1c02:	e677      	b.n	80a18f4 <_ZN7FatFile4openEPS_P7fname_ti+0x3c>
 80a1c04:	f10e 0e01 	add.w	lr, lr, #1
      if (k >= len) {
        // Not found.
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
 80a1c08:	f1be 0f0d 	cmp.w	lr, #13
 80a1c0c:	f43f ae82 	beq.w	80a1914 <_ZN7FatFile4openEPS_P7fname_ti+0x5c>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
 80a1c10:	46d4      	mov	ip, sl
 80a1c12:	e6c3      	b.n	80a199c <_ZN7FatFile4openEPS_P7fname_ti+0xe4>
  }
  return true;

fail:
  return false;
}
 80a1c14:	b009      	add	sp, #36	; 0x24
 80a1c16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a1c1a:	bf00      	nop
 80a1c1c:	20000af8 	.word	0x20000af8

080a1c20 <_GLOBAL__sub_I__ZN7FatFile11lfnChecksumEPh>:
 80a1c20:	f001 b9ac 	b.w	80a2f7c <HAL_Pin_Map>

080a1c24 <_GLOBAL__sub_I__ZN11StdioStream6fcloseEv>:
 80a1c24:	f001 b9aa 	b.w	80a2f7c <HAL_Pin_Map>

080a1c28 <_GLOBAL__sub_I__ZN7ostream7do_fillEj>:
 80a1c28:	f001 b9a8 	b.w	80a2f7c <HAL_Pin_Map>

080a1c2c <_GLOBAL__sub_I__ZN7FatFile6getSFNEPc>:
 80a1c2c:	f001 b9a6 	b.w	80a2f7c <HAL_Pin_Map>

080a1c30 <_ZN7FatFile10addClusterEv>:
// Callback function for date/time.
void (*FatFile::m_dateTime)(uint16_t* date, uint16_t* time) = 0;
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
  m_flags |= F_FILE_DIR_DIRTY;
 80a1c30:	7883      	ldrb	r3, [r0, #2]
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
 80a1c32:	f100 0210 	add.w	r2, r0, #16
// Callback function for date/time.
void (*FatFile::m_dateTime)(uint16_t* date, uint16_t* time) = 0;
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
  m_flags |= F_FILE_DIR_DIRTY;
 80a1c36:	f043 0304 	orr.w	r3, r3, #4
 80a1c3a:	7083      	strb	r3, [r0, #2]
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
 80a1c3c:	6901      	ldr	r1, [r0, #16]
 80a1c3e:	6880      	ldr	r0, [r0, #8]
 80a1c40:	f000 bc48 	b.w	80a24d4 <_ZN9FatVolume15allocateClusterEmPm>

080a1c44 <_ZN7FatFile13addDirClusterEv>:
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first block of cluster in the cache.
bool FatFile::addDirCluster() {
 80a1c44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t block;
  cache_t* pc;

  if (isRootFixed()) {
 80a1c48:	7803      	ldrb	r3, [r0, #0]
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first block of cluster in the cache.
bool FatFile::addDirCluster() {
 80a1c4a:	4604      	mov	r4, r0
  uint32_t block;
  cache_t* pc;

  if (isRootFixed()) {
 80a1c4c:	f003 0320 	and.w	r3, r3, #32
 80a1c50:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 80a1c54:	b10b      	cbz	r3, 80a1c5a <_ZN7FatFile13addDirClusterEv+0x16>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += 512UL*m_vol->blocksPerCluster();
  return true;

fail:
  return false;
 80a1c56:	2600      	movs	r6, #0
 80a1c58:	e02e      	b.n	80a1cb8 <_ZN7FatFile13addDirClusterEv+0x74>
  if (isRootFixed()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
 80a1c5a:	6942      	ldr	r2, [r0, #20]
 80a1c5c:	4b18      	ldr	r3, [pc, #96]	; (80a1cc0 <_ZN7FatFile13addDirClusterEv+0x7c>)
 80a1c5e:	429a      	cmp	r2, r3
 80a1c60:	d8f9      	bhi.n	80a1c56 <_ZN7FatFile13addDirClusterEv+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
 80a1c62:	f7ff ffe5 	bl	80a1c30 <_ZN7FatFile10addClusterEv>
 80a1c66:	4606      	mov	r6, r0
 80a1c68:	2800      	cmp	r0, #0
 80a1c6a:	d0f4      	beq.n	80a1c56 <_ZN7FatFile13addDirClusterEv+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  block = m_vol->clusterFirstBlock(m_curCluster);
 80a1c6c:	6921      	ldr	r1, [r4, #16]
 80a1c6e:	68a0      	ldr	r0, [r4, #8]
 80a1c70:	f000 fbc5 	bl	80a23fe <_ZNK9FatVolume17clusterFirstBlockEm>
 80a1c74:	4607      	mov	r7, r0
  bool cacheSync() {
    return m_cache.sync() && syncBlocks();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t blockNumber, uint8_t options) {
    return m_cache.read(blockNumber, options);
 80a1c76:	68a0      	ldr	r0, [r4, #8]
 80a1c78:	2205      	movs	r2, #5
 80a1c7a:	4639      	mov	r1, r7
 80a1c7c:	3024      	adds	r0, #36	; 0x24
 80a1c7e:	f000 fb9a 	bl	80a23b6 <_ZN8FatCache4readEmh>
  pc = m_vol->cacheFetchData(block, FatCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
 80a1c82:	4680      	mov	r8, r0
 80a1c84:	2800      	cmp	r0, #0
 80a1c86:	d0e6      	beq.n	80a1c56 <_ZN7FatFile13addDirClusterEv+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, 512);
 80a1c88:	4629      	mov	r1, r5
 80a1c8a:	f44f 7200 	mov.w	r2, #512	; 0x200
 80a1c8e:	f003 f941 	bl	80a4f14 <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->blocksPerCluster(); i++) {
 80a1c92:	2501      	movs	r5, #1
 80a1c94:	68a3      	ldr	r3, [r4, #8]
 80a1c96:	791a      	ldrb	r2, [r3, #4]
 80a1c98:	42aa      	cmp	r2, r5
 80a1c9a:	d909      	bls.n	80a1cb0 <_ZN7FatFile13addDirClusterEv+0x6c>
  }
  bool syncBlocks() {
    return m_blockDev->syncBlocks();
  }
  bool writeBlock(uint32_t block, const uint8_t* src) {
    return m_blockDev->writeBlock(block, src);
 80a1c9c:	4642      	mov	r2, r8
 80a1c9e:	19e9      	adds	r1, r5, r7
 80a1ca0:	6818      	ldr	r0, [r3, #0]
 80a1ca2:	f000 ff05 	bl	80a2ab0 <_ZN9SdSpiCard10writeBlockEmPKh>
    if (!m_vol->writeBlock(block + i, pc->data)) {
 80a1ca6:	2800      	cmp	r0, #0
 80a1ca8:	d0d5      	beq.n	80a1c56 <_ZN7FatFile13addDirClusterEv+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, 512);
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->blocksPerCluster(); i++) {
 80a1caa:	3501      	adds	r5, #1
 80a1cac:	b2ed      	uxtb	r5, r5
 80a1cae:	e7f1      	b.n	80a1c94 <_ZN7FatFile13addDirClusterEv+0x50>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += 512UL*m_vol->blocksPerCluster();
 80a1cb0:	6963      	ldr	r3, [r4, #20]
 80a1cb2:	eb03 2342 	add.w	r3, r3, r2, lsl #9
 80a1cb6:	6163      	str	r3, [r4, #20]
  return true;

fail:
  return false;
}
 80a1cb8:	4630      	mov	r0, r6
 80a1cba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a1cbe:	bf00      	nop
 80a1cc0:	001ffdff 	.word	0x001ffdff

080a1cc4 <_ZN7FatFile13cacheDirEntryEh>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* FatFile::cacheDirEntry(uint8_t action) {
 80a1cc4:	b510      	push	{r4, lr}
 80a1cc6:	4604      	mov	r4, r0
  bool cacheSync() {
    return m_cache.sync() && syncBlocks();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t blockNumber, uint8_t options) {
    return m_cache.read(blockNumber, options);
 80a1cc8:	6880      	ldr	r0, [r0, #8]
 80a1cca:	460a      	mov	r2, r1
 80a1ccc:	3024      	adds	r0, #36	; 0x24
 80a1cce:	69a1      	ldr	r1, [r4, #24]
 80a1cd0:	f000 fb71 	bl	80a23b6 <_ZN8FatCache4readEmh>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirBlock, action);
  if (!pc) {
 80a1cd4:	b120      	cbz	r0, 80a1ce0 <_ZN7FatFile13cacheDirEntryEh+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
 80a1cd6:	88a3      	ldrh	r3, [r4, #4]
 80a1cd8:	f003 030f 	and.w	r3, r3, #15
 80a1cdc:	eb00 1043 	add.w	r0, r0, r3, lsl #5

fail:
  return 0;
}
 80a1ce0:	bd10      	pop	{r4, pc}

080a1ce2 <_ZN7FatFile8openRootEP9FatVolume>:
fail:
  return false;
}
#endif  // DOXYGEN_SHOULD_SKIP_THIS
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
 80a1ce2:	b570      	push	{r4, r5, r6, lr}
  // error if file is already open
  if (isOpen()) {
 80a1ce4:	7804      	ldrb	r4, [r0, #0]
fail:
  return false;
}
#endif  // DOXYGEN_SHOULD_SKIP_THIS
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
 80a1ce6:	4605      	mov	r5, r0
 80a1ce8:	460e      	mov	r6, r1
  // error if file is already open
  if (isOpen()) {
 80a1cea:	b984      	cbnz	r4, 80a1d0e <_ZN7FatFile8openRootEP9FatVolume+0x2c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
 80a1cec:	2224      	movs	r2, #36	; 0x24
 80a1cee:	4621      	mov	r1, r4
 80a1cf0:	f003 f910 	bl	80a4f14 <memset>

  m_vol = vol;
 80a1cf4:	60ae      	str	r6, [r5, #8]
  switch (vol->fatType()) {
 80a1cf6:	79f3      	ldrb	r3, [r6, #7]
 80a1cf8:	2b10      	cmp	r3, #16
 80a1cfa:	d003      	beq.n	80a1d04 <_ZN7FatFile8openRootEP9FatVolume+0x22>
 80a1cfc:	2b20      	cmp	r3, #32
 80a1cfe:	d106      	bne.n	80a1d0e <_ZN7FatFile8openRootEP9FatVolume+0x2c>
  case 16:
    m_attr = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attr = FILE_ATTR_ROOT32;
 80a1d00:	2340      	movs	r3, #64	; 0x40
 80a1d02:	e000      	b.n	80a1d06 <_ZN7FatFile8openRootEP9FatVolume+0x24>
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attr = FILE_ATTR_ROOT_FIXED;
 80a1d04:	2320      	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = F_READ;
 80a1d06:	2001      	movs	r0, #1
  case 16:
    m_attr = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attr = FILE_ATTR_ROOT32;
 80a1d08:	702b      	strb	r3, [r5, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = F_READ;
 80a1d0a:	70a8      	strb	r0, [r5, #2]
 80a1d0c:	bd70      	pop	{r4, r5, r6, pc}
  return true;

fail:
  return false;
 80a1d0e:	2000      	movs	r0, #0
 80a1d10:	bd70      	pop	{r4, r5, r6, pc}

080a1d12 <_ZN7FatFile4readEPvj>:
    setpos(&pos);
  }
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
 80a1d12:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a1d16:	7803      	ldrb	r3, [r0, #0]
 80a1d18:	4604      	mov	r4, r0
 80a1d1a:	4689      	mov	r9, r1
 80a1d1c:	4615      	mov	r5, r2
  size_t toRead;
  uint32_t block;  // raw device block number
  cache_t* pc;

  // error if not open for read
  if (!isOpen() || !(m_flags & F_READ)) {
 80a1d1e:	b14b      	cbz	r3, 80a1d34 <_ZN7FatFile4readEPvj+0x22>
 80a1d20:	7882      	ldrb	r2, [r0, #2]
 80a1d22:	07d1      	lsls	r1, r2, #31
 80a1d24:	d506      	bpl.n	80a1d34 <_ZN7FatFile4readEPvj+0x22>
 80a1d26:	e00c      	b.n	80a1d42 <_ZN7FatFile4readEPvj+0x30>
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
 80a1d28:	465a      	mov	r2, fp
 80a1d2a:	6921      	ldr	r1, [r4, #16]
 80a1d2c:	f000 fb6d 	bl	80a240a <_ZN9FatVolume6fatGetEmPm>
          if (fg < 0) {
 80a1d30:	2800      	cmp	r0, #0
 80a1d32:	da3d      	bge.n	80a1db0 <_ZN7FatFile4readEPvj+0x9e>
    toRead -= n;
  }
  return nbyte - toRead;

fail:
  m_error |= READ_ERROR;
 80a1d34:	7863      	ldrb	r3, [r4, #1]
  return -1;
 80a1d36:	f04f 30ff 	mov.w	r0, #4294967295
    toRead -= n;
  }
  return nbyte - toRead;

fail:
  m_error |= READ_ERROR;
 80a1d3a:	f043 0302 	orr.w	r3, r3, #2
 80a1d3e:	7063      	strb	r3, [r4, #1]
  return -1;
 80a1d40:	e097      	b.n	80a1e72 <_ZN7FatFile4readEPvj+0x160>
  if (!isOpen() || !(m_flags & F_READ)) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
 80a1d42:	071a      	lsls	r2, r3, #28
 80a1d44:	d503      	bpl.n	80a1d4e <_ZN7FatFile4readEPvj+0x3c>
    uint32_t tmp32 = m_fileSize - m_curPosition;
 80a1d46:	69e3      	ldr	r3, [r4, #28]
 80a1d48:	6962      	ldr	r2, [r4, #20]
 80a1d4a:	1a9b      	subs	r3, r3, r2
 80a1d4c:	e007      	b.n	80a1d5e <_ZN7FatFile4readEPvj+0x4c>
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
 80a1d4e:	069a      	lsls	r2, r3, #26
 80a1d50:	d508      	bpl.n	80a1d64 <_ZN7FatFile4readEPvj+0x52>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
 80a1d52:	68a3      	ldr	r3, [r4, #8]
    if (nbyte > tmp16) {
 80a1d54:	891a      	ldrh	r2, [r3, #8]
 80a1d56:	6963      	ldr	r3, [r4, #20]
 80a1d58:	ebc3 1342 	rsb	r3, r3, r2, lsl #5
 80a1d5c:	b29b      	uxth	r3, r3
 80a1d5e:	429d      	cmp	r5, r3
 80a1d60:	bf28      	it	cs
 80a1d62:	461d      	movcs	r5, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
 80a1d64:	462e      	mov	r6, r5
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
  int8_t fg;
  uint8_t blockOfCluster = 0;
 80a1d66:	f04f 0800 	mov.w	r8, #0
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
 80a1d6a:	f104 0b10 	add.w	fp, r4, #16
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
 80a1d6e:	2e00      	cmp	r6, #0
 80a1d70:	d035      	beq.n	80a1dde <_ZN7FatFile4readEPvj+0xcc>
 80a1d72:	7822      	ldrb	r2, [r4, #0]
    size_t n;
    offset = m_curPosition & 0X1FF;  // offset in block
 80a1d74:	6963      	ldr	r3, [r4, #20]
    if (isRootFixed()) {
 80a1d76:	f012 0f20 	tst.w	r2, #32
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & 0X1FF;  // offset in block
 80a1d7a:	f3c3 0a08 	ubfx	sl, r3, #0, #9
 80a1d7e:	68a0      	ldr	r0, [r4, #8]
 80a1d80:	ea4f 2153 	mov.w	r1, r3, lsr #9
    if (isRootFixed()) {
 80a1d84:	d002      	beq.n	80a1d8c <_ZN7FatFile4readEPvj+0x7a>
      block = m_vol->rootDirStart() + (m_curPosition >> 9);
 80a1d86:	6a03      	ldr	r3, [r0, #32]
 80a1d88:	4419      	add	r1, r3
 80a1d8a:	e01d      	b.n	80a1dc8 <_ZN7FatFile4readEPvj+0xb6>
  }
//------------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t blockOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterBlockMask;
 80a1d8c:	f890 8005 	ldrb.w	r8, [r0, #5]
 80a1d90:	ea01 0808 	and.w	r8, r1, r8
    } else {
      blockOfCluster = m_vol->blockOfCluster(m_curPosition);
      if (offset == 0 && blockOfCluster == 0) {
 80a1d94:	f1ba 0f00 	cmp.w	sl, #0
 80a1d98:	d110      	bne.n	80a1dbc <_ZN7FatFile4readEPvj+0xaa>
 80a1d9a:	f1b8 0f00 	cmp.w	r8, #0
 80a1d9e:	d10d      	bne.n	80a1dbc <_ZN7FatFile4readEPvj+0xaa>
        // start of new cluster
        if (m_curPosition == 0) {
 80a1da0:	2b00      	cmp	r3, #0
 80a1da2:	d1c1      	bne.n	80a1d28 <_ZN7FatFile4readEPvj+0x16>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
 80a1da4:	0653      	lsls	r3, r2, #25
 80a1da6:	bf4c      	ite	mi
 80a1da8:	6a03      	ldrmi	r3, [r0, #32]
 80a1daa:	6a23      	ldrpl	r3, [r4, #32]
 80a1dac:	6123      	str	r3, [r4, #16]
 80a1dae:	e005      	b.n	80a1dbc <_ZN7FatFile4readEPvj+0xaa>
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
 80a1db0:	d104      	bne.n	80a1dbc <_ZN7FatFile4readEPvj+0xaa>
            if (isDir()) {
 80a1db2:	7823      	ldrb	r3, [r4, #0]
 80a1db4:	f013 0f70 	tst.w	r3, #112	; 0x70
 80a1db8:	d111      	bne.n	80a1dde <_ZN7FatFile4readEPvj+0xcc>
 80a1dba:	e7bb      	b.n	80a1d34 <_ZN7FatFile4readEPvj+0x22>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      block = m_vol->clusterFirstBlock(m_curCluster) + blockOfCluster;
 80a1dbc:	6921      	ldr	r1, [r4, #16]
 80a1dbe:	68a0      	ldr	r0, [r4, #8]
 80a1dc0:	f000 fb1d 	bl	80a23fe <_ZNK9FatVolume17clusterFirstBlockEm>
 80a1dc4:	eb08 0100 	add.w	r1, r8, r0
 80a1dc8:	68a0      	ldr	r0, [r4, #8]
    }
    if (offset != 0 || toRead < 512 || block == m_vol->cacheBlockNumber()) {
 80a1dca:	f1ba 0f00 	cmp.w	sl, #0
 80a1dce:	d135      	bne.n	80a1e3c <_ZN7FatFile4readEPvj+0x12a>
 80a1dd0:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80a1dd4:	d332      	bcc.n	80a1e3c <_ZN7FatFile4readEPvj+0x12a>
 80a1dd6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80a1dd8:	4299      	cmp	r1, r3
 80a1dda:	d102      	bne.n	80a1de2 <_ZN7FatFile4readEPvj+0xd0>
 80a1ddc:	e02e      	b.n	80a1e3c <_ZN7FatFile4readEPvj+0x12a>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
 80a1dde:	1ba8      	subs	r0, r5, r6
 80a1de0:	e047      	b.n	80a1e72 <_ZN7FatFile4readEPvj+0x160>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_BLOCK_IO
    } else if (toRead >= 1024) {
 80a1de2:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 80a1de6:	d31b      	bcc.n	80a1e20 <_ZN7FatFile4readEPvj+0x10e>
      size_t nb = toRead >> 9;
      if (!isRootFixed()) {
 80a1de8:	7822      	ldrb	r2, [r4, #0]
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_BLOCK_IO
    } else if (toRead >= 1024) {
      size_t nb = toRead >> 9;
 80a1dea:	ea4f 2a56 	mov.w	sl, r6, lsr #9
      if (!isRootFixed()) {
 80a1dee:	0697      	lsls	r7, r2, #26
 80a1df0:	d406      	bmi.n	80a1e00 <_ZN7FatFile4readEPvj+0xee>
        uint8_t mb = m_vol->blocksPerCluster() - blockOfCluster;
        if (mb < nb) {
 80a1df2:	7902      	ldrb	r2, [r0, #4]
 80a1df4:	ebc8 0202 	rsb	r2, r8, r2
 80a1df8:	b2d2      	uxtb	r2, r2
 80a1dfa:	4592      	cmp	sl, r2
 80a1dfc:	bf28      	it	cs
 80a1dfe:	4692      	movcs	sl, r2
          nb = mb;
        }
      }
      n = 512*nb;
      if (m_vol->cacheBlockNumber() <= block
          && block < (m_vol->cacheBlockNumber() + nb)) {
 80a1e00:	4299      	cmp	r1, r3
        uint8_t mb = m_vol->blocksPerCluster() - blockOfCluster;
        if (mb < nb) {
          nb = mb;
        }
      }
      n = 512*nb;
 80a1e02:	ea4f 274a 	mov.w	r7, sl, lsl #9
      if (m_vol->cacheBlockNumber() <= block
          && block < (m_vol->cacheBlockNumber() + nb)) {
 80a1e06:	d207      	bcs.n	80a1e18 <_ZN7FatFile4readEPvj+0x106>
 80a1e08:	68a0      	ldr	r0, [r4, #8]
  bool writeBlock(uint32_t block, const uint8_t* src) {
    return m_blockDev->writeBlock(block, src);
  }
#if USE_MULTI_BLOCK_IO
  bool readBlocks(uint32_t block, uint8_t* dst, size_t nb) {
    return m_blockDev->readBlocks(block, dst, nb);
 80a1e0a:	4653      	mov	r3, sl
 80a1e0c:	464a      	mov	r2, r9
 80a1e0e:	6800      	ldr	r0, [r0, #0]
 80a1e10:	f000 fe0c 	bl	80a2a2c <_ZN9SdSpiCard10readBlocksEmPhj>
        if (!m_vol->cacheSyncData()) {
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
      if (!m_vol->readBlocks(block, dst, nb)) {
 80a1e14:	b960      	cbnz	r0, 80a1e30 <_ZN7FatFile4readEPvj+0x11e>
 80a1e16:	e78d      	b.n	80a1d34 <_ZN7FatFile4readEPvj+0x22>
          nb = mb;
        }
      }
      n = 512*nb;
      if (m_vol->cacheBlockNumber() <= block
          && block < (m_vol->cacheBlockNumber() + nb)) {
 80a1e18:	4453      	add	r3, sl
 80a1e1a:	4299      	cmp	r1, r3
 80a1e1c:	d321      	bcc.n	80a1e62 <_ZN7FatFile4readEPvj+0x150>
 80a1e1e:	e7f3      	b.n	80a1e08 <_ZN7FatFile4readEPvj+0xf6>
  uint32_t m_lastCluster;          // Last cluster number in FAT.
  uint32_t m_rootDirStart;         // Start block for FAT16, cluster for FAT32.
//------------------------------------------------------------------------------
  // block I/O functions.
  bool readBlock(uint32_t block, uint8_t* dst) {
    return m_blockDev->readBlock(block, dst);
 80a1e20:	464a      	mov	r2, r9
 80a1e22:	6800      	ldr	r0, [r0, #0]
 80a1e24:	f000 fdba 	bl	80a299c <_ZN9SdSpiCard9readBlockEmPh>
      }
#endif  // USE_MULTI_BLOCK_IO
    } else {
      // read single block
      n = 512;
      if (!m_vol->readBlock(block, dst)) {
 80a1e28:	2800      	cmp	r0, #0
 80a1e2a:	d083      	beq.n	80a1d34 <_ZN7FatFile4readEPvj+0x22>
        goto fail;
      }
#endif  // USE_MULTI_BLOCK_IO
    } else {
      // read single block
      n = 512;
 80a1e2c:	f44f 7700 	mov.w	r7, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
 80a1e30:	6963      	ldr	r3, [r4, #20]
      if (!m_vol->readBlock(block, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
 80a1e32:	44b9      	add	r9, r7
    m_curPosition += n;
 80a1e34:	443b      	add	r3, r7
 80a1e36:	6163      	str	r3, [r4, #20]
    toRead -= n;
 80a1e38:	1bf6      	subs	r6, r6, r7
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
 80a1e3a:	e798      	b.n	80a1d6e <_ZN7FatFile4readEPvj+0x5c>
  bool cacheSync() {
    return m_cache.sync() && syncBlocks();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t blockNumber, uint8_t options) {
    return m_cache.read(blockNumber, options);
 80a1e3c:	2200      	movs	r2, #0
 80a1e3e:	3024      	adds	r0, #36	; 0x24
 80a1e40:	f000 fab9 	bl	80a23b6 <_ZN8FatCache4readEmh>
      if (n > toRead) {
        n = toRead;
      }
      // read block to cache and copy data to caller
      pc = m_vol->cacheFetchData(block, FatCache::CACHE_FOR_READ);
      if (!pc) {
 80a1e44:	2800      	cmp	r0, #0
 80a1e46:	f43f af75 	beq.w	80a1d34 <_ZN7FatFile4readEPvj+0x22>
      }
      block = m_vol->clusterFirstBlock(m_curCluster) + blockOfCluster;
    }
    if (offset != 0 || toRead < 512 || block == m_vol->cacheBlockNumber()) {
      // amount to be read from current block
      n = 512 - offset;
 80a1e4a:	f5ca 7700 	rsb	r7, sl, #512	; 0x200
 80a1e4e:	42b7      	cmp	r7, r6
 80a1e50:	bf28      	it	cs
 80a1e52:	4637      	movcs	r7, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
 80a1e54:	eb00 010a 	add.w	r1, r0, sl
 80a1e58:	463a      	mov	r2, r7
 80a1e5a:	4648      	mov	r0, r9
 80a1e5c:	f003 f84f 	bl	80a4efe <memcpy>
 80a1e60:	e7e6      	b.n	80a1e30 <_ZN7FatFile4readEPvj+0x11e>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
 80a1e62:	3024      	adds	r0, #36	; 0x24
 80a1e64:	9101      	str	r1, [sp, #4]
 80a1e66:	f000 fa7f 	bl	80a2368 <_ZN8FatCache4syncEv>
      }
      n = 512*nb;
      if (m_vol->cacheBlockNumber() <= block
          && block < (m_vol->cacheBlockNumber() + nb)) {
        // flush cache if a block is in the cache
        if (!m_vol->cacheSyncData()) {
 80a1e6a:	9901      	ldr	r1, [sp, #4]
 80a1e6c:	2800      	cmp	r0, #0
 80a1e6e:	d1cb      	bne.n	80a1e08 <_ZN7FatFile4readEPvj+0xf6>
 80a1e70:	e760      	b.n	80a1d34 <_ZN7FatFile4readEPvj+0x22>
  return nbyte - toRead;

fail:
  m_error |= READ_ERROR;
  return -1;
}
 80a1e72:	b003      	add	sp, #12
 80a1e74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a1e78 <_ZN7FatFile5fgetsEPcsS0_>:
    n += m_vol->blocksPerCluster();
  } while (fg);
  return 512UL*n;
}
//------------------------------------------------------------------------------
int16_t FatFile::fgets(char* str, int16_t num, char* delim) {
 80a1e78:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a1e7c:	4680      	mov	r8, r0
 80a1e7e:	460e      	mov	r6, r1
 80a1e80:	4691      	mov	r9, r2
 80a1e82:	461f      	mov	r7, r3
  char ch;
  int16_t n = 0;
  int16_t r = -1;
 80a1e84:	f04f 3aff 	mov.w	sl, #4294967295
  return 512UL*n;
}
//------------------------------------------------------------------------------
int16_t FatFile::fgets(char* str, int16_t num, char* delim) {
  char ch;
  int16_t n = 0;
 80a1e88:	2500      	movs	r5, #0
  int16_t r = -1;
  while ((n + 1) < num && (r = read(&ch, 1)) == 1) {
 80a1e8a:	1c6c      	adds	r4, r5, #1
 80a1e8c:	454c      	cmp	r4, r9
 80a1e8e:	da20      	bge.n	80a1ed2 <_ZN7FatFile5fgetsEPcsS0_+0x5a>
 80a1e90:	2201      	movs	r2, #1
 80a1e92:	f10d 0107 	add.w	r1, sp, #7
 80a1e96:	4640      	mov	r0, r8
 80a1e98:	f7ff ff3b 	bl	80a1d12 <_ZN7FatFile4readEPvj>
 80a1e9c:	fa0f fa80 	sxth.w	sl, r0
 80a1ea0:	f1ba 0f01 	cmp.w	sl, #1
 80a1ea4:	d115      	bne.n	80a1ed2 <_ZN7FatFile5fgetsEPcsS0_+0x5a>
    // delete CR
    if (ch == '\r') {
 80a1ea6:	f89d 1007 	ldrb.w	r1, [sp, #7]
 80a1eaa:	290d      	cmp	r1, #13
 80a1eac:	d102      	bne.n	80a1eb4 <_ZN7FatFile5fgetsEPcsS0_+0x3c>
 80a1eae:	462c      	mov	r4, r5
 80a1eb0:	4625      	mov	r5, r4
 80a1eb2:	e7ea      	b.n	80a1e8a <_ZN7FatFile5fgetsEPcsS0_+0x12>
      continue;
    }
    str[n++] = ch;
 80a1eb4:	b224      	sxth	r4, r4
 80a1eb6:	5571      	strb	r1, [r6, r5]
    if (!delim) {
 80a1eb8:	b917      	cbnz	r7, 80a1ec0 <_ZN7FatFile5fgetsEPcsS0_+0x48>
      if (ch == '\n') {
 80a1eba:	290a      	cmp	r1, #10
 80a1ebc:	d1f8      	bne.n	80a1eb0 <_ZN7FatFile5fgetsEPcsS0_+0x38>
 80a1ebe:	e004      	b.n	80a1eca <_ZN7FatFile5fgetsEPcsS0_+0x52>
        break;
      }
    } else {
      if (strchr(delim, ch)) {
 80a1ec0:	4638      	mov	r0, r7
 80a1ec2:	f003 f857 	bl	80a4f74 <strchr>
 80a1ec6:	2800      	cmp	r0, #0
 80a1ec8:	d0f2      	beq.n	80a1eb0 <_ZN7FatFile5fgetsEPcsS0_+0x38>
  }
  if (r < 0) {
    // read error
    return -1;
  }
  str[n] = '\0';
 80a1eca:	2300      	movs	r3, #0
 80a1ecc:	5533      	strb	r3, [r6, r4]
  return n;
 80a1ece:	4620      	mov	r0, r4
 80a1ed0:	e007      	b.n	80a1ee2 <_ZN7FatFile5fgetsEPcsS0_+0x6a>
      if (strchr(delim, ch)) {
        break;
      }
    }
  }
  if (r < 0) {
 80a1ed2:	f1ba 0f00 	cmp.w	sl, #0
 80a1ed6:	da02      	bge.n	80a1ede <_ZN7FatFile5fgetsEPcsS0_+0x66>
    // read error
    return -1;
 80a1ed8:	f04f 30ff 	mov.w	r0, #4294967295
 80a1edc:	e001      	b.n	80a1ee2 <_ZN7FatFile5fgetsEPcsS0_+0x6a>
 80a1ede:	462c      	mov	r4, r5
 80a1ee0:	e7f3      	b.n	80a1eca <_ZN7FatFile5fgetsEPcsS0_+0x52>
  }
  str[n] = '\0';
  return n;
}
 80a1ee2:	b002      	add	sp, #8
 80a1ee4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080a1ee8 <_ZN7FatFile12readDirCacheEb>:
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* FatFile::readDirCache(bool skipReadOk) {
 80a1ee8:	b537      	push	{r0, r1, r2, r4, r5, lr}
//  uint8_t b;
  uint8_t i = (m_curPosition >> 5) & 0XF;
 80a1eea:	6943      	ldr	r3, [r0, #20]
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* FatFile::readDirCache(bool skipReadOk) {
 80a1eec:	4604      	mov	r4, r0
//  uint8_t b;
  uint8_t i = (m_curPosition >> 5) & 0XF;
 80a1eee:	f3c3 1543 	ubfx	r5, r3, #5, #4

  if (i == 0 || !skipReadOk) {
 80a1ef2:	b105      	cbz	r5, 80a1ef6 <_ZN7FatFile12readDirCacheEb+0xe>
 80a1ef4:	b969      	cbnz	r1, 80a1f12 <_ZN7FatFile12readDirCacheEb+0x2a>
    int8_t n = read(&n, 1);
 80a1ef6:	2201      	movs	r2, #1
 80a1ef8:	f10d 0107 	add.w	r1, sp, #7
 80a1efc:	4620      	mov	r0, r4
 80a1efe:	f7ff ff08 	bl	80a1d12 <_ZN7FatFile4readEPvj>
 80a1f02:	b240      	sxtb	r0, r0
    if  (n != 1) {
 80a1f04:	2801      	cmp	r0, #1
 80a1f06:	d001      	beq.n	80a1f0c <_ZN7FatFile12readDirCacheEb+0x24>
  }
  // return pointer to entry
  return m_vol->cacheAddress()->dir + i;

fail:
  return 0;
 80a1f08:	2000      	movs	r0, #0
 80a1f0a:	e008      	b.n	80a1f1e <_ZN7FatFile12readDirCacheEb+0x36>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
 80a1f0c:	6963      	ldr	r3, [r4, #20]
 80a1f0e:	331f      	adds	r3, #31
 80a1f10:	e000      	b.n	80a1f14 <_ZN7FatFile12readDirCacheEb+0x2c>
  } else {
    m_curPosition += 32;
 80a1f12:	3320      	adds	r3, #32
  }
  // return pointer to entry
  return m_vol->cacheAddress()->dir + i;
 80a1f14:	68a0      	ldr	r0, [r4, #8]
      }
      goto fail;
    }
    m_curPosition += 31;
  } else {
    m_curPosition += 32;
 80a1f16:	6163      	str	r3, [r4, #20]
  }
  // return pointer to entry
  return m_vol->cacheAddress()->dir + i;
 80a1f18:	3030      	adds	r0, #48	; 0x30
 80a1f1a:	eb00 1045 	add.w	r0, r0, r5, lsl #5

fail:
  return 0;
}
 80a1f1e:	b003      	add	sp, #12
 80a1f20:	bd30      	pop	{r4, r5, pc}

080a1f22 <_ZN7FatFile7seekSetEm>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
 80a1f22:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a1f26:	460e      	mov	r6, r1
 80a1f28:	7801      	ldrb	r1, [r0, #0]
 80a1f2a:	4604      	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
 80a1f2c:	6907      	ldr	r7, [r0, #16]
  // error if file not open
  if (!isOpen()) {
 80a1f2e:	2900      	cmp	r1, #0
 80a1f30:	d039      	beq.n	80a1fa6 <_ZN7FatFile7seekSetEm+0x84>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
 80a1f32:	6945      	ldr	r5, [r0, #20]
 80a1f34:	42b5      	cmp	r5, r6
 80a1f36:	d03a      	beq.n	80a1fae <_ZN7FatFile7seekSetEm+0x8c>
    return true;
  }
  if (pos == 0) {
 80a1f38:	b90e      	cbnz	r6, 80a1f3e <_ZN7FatFile7seekSetEm+0x1c>
    // set position to start of file
    m_curCluster = 0;
 80a1f3a:	6106      	str	r6, [r0, #16]
    goto done;
 80a1f3c:	e031      	b.n	80a1fa2 <_ZN7FatFile7seekSetEm+0x80>
  }
  if (isFile()) {
 80a1f3e:	070b      	lsls	r3, r1, #28
 80a1f40:	d503      	bpl.n	80a1f4a <_ZN7FatFile7seekSetEm+0x28>
    if (pos > m_fileSize) {
 80a1f42:	69c3      	ldr	r3, [r0, #28]
 80a1f44:	429e      	cmp	r6, r3
 80a1f46:	d82e      	bhi.n	80a1fa6 <_ZN7FatFile7seekSetEm+0x84>
 80a1f48:	e007      	b.n	80a1f5a <_ZN7FatFile7seekSetEm+0x38>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
 80a1f4a:	0688      	lsls	r0, r1, #26
 80a1f4c:	d505      	bpl.n	80a1f5a <_ZN7FatFile7seekSetEm+0x38>
 80a1f4e:	68a3      	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
 80a1f50:	891b      	ldrh	r3, [r3, #8]
 80a1f52:	ebb6 1f43 	cmp.w	r6, r3, lsl #5
 80a1f56:	d826      	bhi.n	80a1fa6 <_ZN7FatFile7seekSetEm+0x84>
 80a1f58:	e023      	b.n	80a1fa2 <_ZN7FatFile7seekSetEm+0x80>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for cur and new position
  nCur = (m_curPosition - 1) >> (m_vol->clusterSizeShift() + 9);
 80a1f5a:	f8d4 e008 	ldr.w	lr, [r4, #8]
 80a1f5e:	1e6a      	subs	r2, r5, #1
 80a1f60:	f89e 3006 	ldrb.w	r3, [lr, #6]
 80a1f64:	f103 0009 	add.w	r0, r3, #9
  nNew = (pos - 1) >> (m_vol->clusterSizeShift() + 9);
 80a1f68:	1e73      	subs	r3, r6, #1
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for cur and new position
  nCur = (m_curPosition - 1) >> (m_vol->clusterSizeShift() + 9);
 80a1f6a:	40c2      	lsrs	r2, r0
  nNew = (pos - 1) >> (m_vol->clusterSizeShift() + 9);
 80a1f6c:	40c3      	lsrs	r3, r0

  if (nNew < nCur || m_curPosition == 0) {
 80a1f6e:	429a      	cmp	r2, r3
 80a1f70:	d800      	bhi.n	80a1f74 <_ZN7FatFile7seekSetEm+0x52>
 80a1f72:	b94d      	cbnz	r5, 80a1f88 <_ZN7FatFile7seekSetEm+0x66>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
 80a1f74:	064a      	lsls	r2, r1, #25
 80a1f76:	bf4c      	ite	mi
 80a1f78:	f8de 2020 	ldrmi.w	r2, [lr, #32]
 80a1f7c:	6a22      	ldrpl	r2, [r4, #32]
 80a1f7e:	6122      	str	r2, [r4, #16]
 80a1f80:	461d      	mov	r5, r3
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
 80a1f82:	f104 0810 	add.w	r8, r4, #16
 80a1f86:	e00a      	b.n	80a1f9e <_ZN7FatFile7seekSetEm+0x7c>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
 80a1f88:	1a9b      	subs	r3, r3, r2
 80a1f8a:	e7f9      	b.n	80a1f80 <_ZN7FatFile7seekSetEm+0x5e>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
 80a1f8c:	4642      	mov	r2, r8
 80a1f8e:	6921      	ldr	r1, [r4, #16]
 80a1f90:	68a0      	ldr	r0, [r4, #8]
 80a1f92:	f000 fa3a 	bl	80a240a <_ZN9FatVolume6fatGetEmPm>
 80a1f96:	2800      	cmp	r0, #0
 80a1f98:	f105 35ff 	add.w	r5, r5, #4294967295
 80a1f9c:	dd03      	ble.n	80a1fa6 <_ZN7FatFile7seekSetEm+0x84>
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
 80a1f9e:	2d00      	cmp	r5, #0
 80a1fa0:	d1f4      	bne.n	80a1f8c <_ZN7FatFile7seekSetEm+0x6a>
      goto fail;
    }
  }

done:
  m_curPosition = pos;
 80a1fa2:	6166      	str	r6, [r4, #20]
 80a1fa4:	e003      	b.n	80a1fae <_ZN7FatFile7seekSetEm+0x8c>
  return true;

fail:
  m_curCluster = tmp;
 80a1fa6:	6127      	str	r7, [r4, #16]
  return false;
 80a1fa8:	2000      	movs	r0, #0
 80a1faa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
 80a1fae:	2001      	movs	r0, #1
  return true;

fail:
  m_curCluster = tmp;
  return false;
}
 80a1fb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a1fb4 <_ZN7FatFile15openCachedEntryEPS_tih>:
}
//------------------------------------------------------------------------------
// open a cached directory entry.

bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
 80a1fb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1fb6:	460f      	mov	r7, r1
 80a1fb8:	4604      	mov	r4, r0
 80a1fba:	4615      	mov	r5, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
 80a1fbc:	2100      	movs	r1, #0
 80a1fbe:	2224      	movs	r2, #36	; 0x24
}
//------------------------------------------------------------------------------
// open a cached directory entry.

bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
 80a1fc0:	461e      	mov	r6, r3
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
 80a1fc2:	f002 ffa7 	bl	80a4f14 <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
 80a1fc6:	68b8      	ldr	r0, [r7, #8]
  m_dirIndex = dirIndex;
 80a1fc8:	80a5      	strh	r5, [r4, #4]
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
 80a1fca:	60a0      	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
 80a1fcc:	6a3b      	ldr	r3, [r7, #32]
  dir_t* dir = &m_vol->cacheAddress()->dir[0XF & dirIndex];
 80a1fce:	f005 020f 	and.w	r2, r5, #15
 80a1fd2:	f100 0130 	add.w	r1, r0, #48	; 0x30
 80a1fd6:	0152      	lsls	r2, r2, #5
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
 80a1fd8:	60e3      	str	r3, [r4, #12]
  dir_t* dir = &m_vol->cacheAddress()->dir[0XF & dirIndex];
 80a1fda:	4411      	add	r1, r2

  // Must be file or subdirectory.
  if (!DIR_IS_FILE_OR_SUBDIR(dir)) {
 80a1fdc:	7acb      	ldrb	r3, [r1, #11]
 80a1fde:	071d      	lsls	r5, r3, #28
 80a1fe0:	d44c      	bmi.n	80a207c <_ZN7FatFile15openCachedEntryEPS_tih+0xc8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attr = dir->attributes & FILE_ATTR_COPY;
 80a1fe2:	1883      	adds	r3, r0, r2
 80a1fe4:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
 80a1fe8:	f003 0317 	and.w	r3, r3, #23
 80a1fec:	7023      	strb	r3, [r4, #0]
  if (DIR_IS_FILE(dir)) {
 80a1fee:	7ac9      	ldrb	r1, [r1, #11]
 80a1ff0:	f011 0f18 	tst.w	r1, #24
    m_attr |= FILE_ATTR_FILE;
 80a1ff4:	bf04      	itt	eq
 80a1ff6:	f043 0308 	orreq.w	r3, r3, #8
 80a1ffa:	7023      	strbeq	r3, [r4, #0]
  }
  m_lfnOrd = lfnOrd;
 80a1ffc:	f89d 3018 	ldrb.w	r3, [sp, #24]
 80a2000:	70e3      	strb	r3, [r4, #3]

  switch (oflag & O_ACCMODE) {
 80a2002:	f006 0303 	and.w	r3, r6, #3
 80a2006:	2b01      	cmp	r3, #1
 80a2008:	d009      	beq.n	80a201e <_ZN7FatFile15openCachedEntryEPS_tih+0x6a>
 80a200a:	2b02      	cmp	r3, #2
 80a200c:	d005      	beq.n	80a201a <_ZN7FatFile15openCachedEntryEPS_tih+0x66>
 80a200e:	2b00      	cmp	r3, #0
 80a2010:	d134      	bne.n	80a207c <_ZN7FatFile15openCachedEntryEPS_tih+0xc8>
    case O_RDONLY:
      if (oflag & O_TRUNC) {
 80a2012:	0571      	lsls	r1, r6, #21
 80a2014:	d432      	bmi.n	80a207c <_ZN7FatFile15openCachedEntryEPS_tih+0xc8>
        DBG_FAIL_MACRO;
        goto fail;
      }
      m_flags = F_READ;
 80a2016:	2301      	movs	r3, #1
 80a2018:	e002      	b.n	80a2020 <_ZN7FatFile15openCachedEntryEPS_tih+0x6c>
      break;

    case O_RDWR:
      m_flags = F_READ | F_WRITE;
 80a201a:	2303      	movs	r3, #3
 80a201c:	e000      	b.n	80a2020 <_ZN7FatFile15openCachedEntryEPS_tih+0x6c>
      break;

    case O_WRONLY:
      m_flags = F_WRITE;
 80a201e:	2302      	movs	r3, #2
 80a2020:	70a3      	strb	r3, [r4, #2]
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & F_WRITE) {
 80a2022:	78a1      	ldrb	r1, [r4, #2]
 80a2024:	078b      	lsls	r3, r1, #30
 80a2026:	d503      	bpl.n	80a2030 <_ZN7FatFile15openCachedEntryEPS_tih+0x7c>
    if (isSubDir() || isReadOnly()) {
 80a2028:	7823      	ldrb	r3, [r4, #0]
 80a202a:	f013 0f11 	tst.w	r3, #17
 80a202e:	d125      	bne.n	80a207c <_ZN7FatFile15openCachedEntryEPS_tih+0xc8>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }

  m_flags |= (oflag & O_APPEND ? F_APPEND : 0) | (oflag & O_SYNC ? F_SYNC : 0);
 80a2030:	b24b      	sxtb	r3, r1
 80a2032:	f416 5f00 	tst.w	r6, #8192	; 0x2000
 80a2036:	f006 0108 	and.w	r1, r6, #8
 80a203a:	bf14      	ite	ne
 80a203c:	f06f 077f 	mvnne.w	r7, #127	; 0x7f
 80a2040:	2700      	moveq	r7, #0
 80a2042:	4319      	orrs	r1, r3
 80a2044:	4339      	orrs	r1, r7
 80a2046:	70a1      	strb	r1, [r4, #2]
 80a2048:	6ac3      	ldr	r3, [r0, #44]	; 0x2c

  m_dirBlock = m_vol->cacheBlockNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)dir->firstClusterHigh << 16)
 80a204a:	4402      	add	r2, r0
    }
  }

  m_flags |= (oflag & O_APPEND ? F_APPEND : 0) | (oflag & O_SYNC ? F_SYNC : 0);

  m_dirBlock = m_vol->cacheBlockNumber();
 80a204c:	61a3      	str	r3, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)dir->firstClusterHigh << 16)
                 | dir->firstClusterLow;
 80a204e:	f8b2 1044 	ldrh.w	r1, [r2, #68]	; 0x44
 80a2052:	f8b2 304a 	ldrh.w	r3, [r2, #74]	; 0x4a

  if (oflag & O_TRUNC) {
 80a2056:	0575      	lsls	r5, r6, #21

  m_dirBlock = m_vol->cacheBlockNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)dir->firstClusterHigh << 16)
                 | dir->firstClusterLow;
 80a2058:	ea43 4101 	orr.w	r1, r3, r1, lsl #16

  if (oflag & O_TRUNC) {
 80a205c:	d504      	bpl.n	80a2068 <_ZN7FatFile15openCachedEntryEPS_tih+0xb4>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
 80a205e:	b181      	cbz	r1, 80a2082 <_ZN7FatFile15openCachedEntryEPS_tih+0xce>
 80a2060:	f000 fa73 	bl	80a254a <_ZN9FatVolume9freeChainEm>
 80a2064:	b968      	cbnz	r0, 80a2082 <_ZN7FatFile15openCachedEntryEPS_tih+0xce>
 80a2066:	e009      	b.n	80a207c <_ZN7FatFile15openCachedEntryEPS_tih+0xc8>
      goto fail;
    }
    // need to update directory entry
    m_flags |= F_FILE_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
 80a2068:	6221      	str	r1, [r4, #32]
    m_fileSize = dir->fileSize;
 80a206a:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 80a206c:	61e3      	str	r3, [r4, #28]
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
 80a206e:	0473      	lsls	r3, r6, #17
 80a2070:	d50c      	bpl.n	80a208c <_ZN7FatFile15openCachedEntryEPS_tih+0xd8>
 80a2072:	69e1      	ldr	r1, [r4, #28]
 80a2074:	4620      	mov	r0, r4
 80a2076:	f7ff ff54 	bl	80a1f22 <_ZN7FatFile7seekSetEm>
 80a207a:	b938      	cbnz	r0, 80a208c <_ZN7FatFile15openCachedEntryEPS_tih+0xd8>
    goto fail;
  }
  return true;

fail:
  m_attr = FILE_ATTR_CLOSED;
 80a207c:	2000      	movs	r0, #0
 80a207e:	7020      	strb	r0, [r4, #0]
  return false;
 80a2080:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // need to update directory entry
    m_flags |= F_FILE_DIR_DIRTY;
 80a2082:	78a3      	ldrb	r3, [r4, #2]
 80a2084:	f043 0304 	orr.w	r3, r3, #4
 80a2088:	70a3      	strb	r3, [r4, #2]
 80a208a:	e7f0      	b.n	80a206e <_ZN7FatFile15openCachedEntryEPS_tih+0xba>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
 80a208c:	2001      	movs	r0, #1

fail:
  m_attr = FILE_ATTR_CLOSED;
  return false;
}
 80a208e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2090 <_ZN7FatFile4syncEv>:
void FatFile::setpos(FatPos_t* pos) {
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
 80a2090:	b538      	push	{r3, r4, r5, lr}
  if (!isOpen()) {
 80a2092:	7803      	ldrb	r3, [r0, #0]
void FatFile::setpos(FatPos_t* pos) {
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
 80a2094:	4604      	mov	r4, r0
  if (!isOpen()) {
 80a2096:	b90b      	cbnz	r3, 80a209c <_ZN7FatFile4syncEv+0xc>
    return true;
 80a2098:	2001      	movs	r0, #1
 80a209a:	bd38      	pop	{r3, r4, r5, pc}
  }
  if (m_flags & F_FILE_DIR_DIRTY) {
 80a209c:	7883      	ldrb	r3, [r0, #2]
 80a209e:	075a      	lsls	r2, r3, #29
 80a20a0:	d523      	bpl.n	80a20ea <_ZN7FatFile4syncEv+0x5a>
    dir_t* dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
 80a20a2:	2101      	movs	r1, #1
 80a20a4:	f7ff fe0e 	bl	80a1cc4 <_ZN7FatFile13cacheDirEntryEh>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == DIR_NAME_DELETED) {
 80a20a8:	4605      	mov	r5, r0
 80a20aa:	b928      	cbnz	r0, 80a20b8 <_ZN7FatFile4syncEv+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

fail:
  m_error |= WRITE_ERROR;
 80a20ac:	7863      	ldrb	r3, [r4, #1]
  return false;
 80a20ae:	2000      	movs	r0, #0
    return true;
  }
  DBG_FAIL_MACRO;

fail:
  m_error |= WRITE_ERROR;
 80a20b0:	f043 0301 	orr.w	r3, r3, #1
 80a20b4:	7063      	strb	r3, [r4, #1]
 80a20b6:	bd38      	pop	{r3, r4, r5, pc}
    return true;
  }
  if (m_flags & F_FILE_DIR_DIRTY) {
    dir_t* dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
    // check for deleted by another open file object
    if (!dir || dir->name[0] == DIR_NAME_DELETED) {
 80a20b8:	7803      	ldrb	r3, [r0, #0]
 80a20ba:	2be5      	cmp	r3, #229	; 0xe5
 80a20bc:	d0f6      	beq.n	80a20ac <_ZN7FatFile4syncEv+0x1c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
 80a20be:	7823      	ldrb	r3, [r4, #0]
 80a20c0:	071b      	lsls	r3, r3, #28
      dir->fileSize = m_fileSize;
 80a20c2:	bf44      	itt	mi
 80a20c4:	69e3      	ldrmi	r3, [r4, #28]
 80a20c6:	61c3      	strmi	r3, [r0, #28]
    }

    // update first cluster fields
    dir->firstClusterLow = m_firstCluster & 0XFFFF;
 80a20c8:	8c23      	ldrh	r3, [r4, #32]
 80a20ca:	8343      	strh	r3, [r0, #26]
    dir->firstClusterHigh = m_firstCluster >> 16;
 80a20cc:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 80a20ce:	8283      	strh	r3, [r0, #20]

    // set modify time if user supplied a callback date/time function
    if (m_dateTime) {
 80a20d0:	4b09      	ldr	r3, [pc, #36]	; (80a20f8 <_ZN7FatFile4syncEv+0x68>)
 80a20d2:	681b      	ldr	r3, [r3, #0]
 80a20d4:	b12b      	cbz	r3, 80a20e2 <_ZN7FatFile4syncEv+0x52>
      m_dateTime(&dir->lastWriteDate, &dir->lastWriteTime);
 80a20d6:	f100 0116 	add.w	r1, r0, #22
 80a20da:	3018      	adds	r0, #24
 80a20dc:	4798      	blx	r3
      dir->lastAccessDate = dir->lastWriteDate;
 80a20de:	8b2b      	ldrh	r3, [r5, #24]
 80a20e0:	826b      	strh	r3, [r5, #18]
    }
    // clear directory dirty
    m_flags &= ~F_FILE_DIR_DIRTY;
 80a20e2:	78a3      	ldrb	r3, [r4, #2]
 80a20e4:	f023 0304 	bic.w	r3, r3, #4
 80a20e8:	70a3      	strb	r3, [r4, #2]
  }
  if (m_vol->cacheSync()) {
 80a20ea:	68a0      	ldr	r0, [r4, #8]
 80a20ec:	f7ff fa86 	bl	80a15fc <_ZN9FatVolume9cacheSyncEv>
 80a20f0:	2800      	cmp	r0, #0
 80a20f2:	d0db      	beq.n	80a20ac <_ZN7FatFile4syncEv+0x1c>
 80a20f4:	e7d0      	b.n	80a2098 <_ZN7FatFile4syncEv+0x8>
 80a20f6:	bf00      	nop
 80a20f8:	20000af8 	.word	0x20000af8

080a20fc <_ZN7FatFile5closeEv>:

fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
 80a20fc:	b510      	push	{r4, lr}
 80a20fe:	4604      	mov	r4, r0
  bool rtn = sync();
 80a2100:	f7ff ffc6 	bl	80a2090 <_ZN7FatFile4syncEv>
  m_attr = FILE_ATTR_CLOSED;
 80a2104:	2300      	movs	r3, #0
 80a2106:	7023      	strb	r3, [r4, #0]
  return rtn;
}
 80a2108:	bd10      	pop	{r4, pc}

080a210a <_ZN7FatFile4openEPS_PKci>:
//------------------------------------------------------------------------------
bool FatFile::open(FatFileSystem* fs, const char* path, oflag_t oflag) {
  return open(fs->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
 80a210a:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a210c:	461f      	mov	r7, r3
 80a210e:	b093      	sub	sp, #76	; 0x4c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
 80a2110:	2300      	movs	r3, #0
 80a2112:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 80a2116:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
 80a211a:	7803      	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatFileSystem* fs, const char* path, oflag_t oflag) {
  return open(fs->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
 80a211c:	4606      	mov	r6, r0
 80a211e:	460c      	mov	r4, r1
 80a2120:	9201      	str	r2, [sp, #4]
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
 80a2122:	b10b      	cbz	r3, 80a2128 <_ZN7FatFile4openEPS_PKci+0x1e>
    close();
  }
  return open(dirFile, &fname, oflag);

fail:
  return false;
 80a2124:	2000      	movs	r0, #0
 80a2126:	e03d      	b.n	80a21a4 <_ZN7FatFile4openEPS_PKci+0x9a>
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
 80a2128:	780b      	ldrb	r3, [r1, #0]
 80a212a:	f013 0f70 	tst.w	r3, #112	; 0x70
 80a212e:	d0f9      	beq.n	80a2124 <_ZN7FatFile4openEPS_PKci+0x1a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
 80a2130:	7813      	ldrb	r3, [r2, #0]
 80a2132:	2b2f      	cmp	r3, #47	; 0x2f
 80a2134:	d112      	bne.n	80a215c <_ZN7FatFile4openEPS_PKci+0x52>
    while (isDirSeparator(*path)) {
 80a2136:	9b01      	ldr	r3, [sp, #4]
 80a2138:	781a      	ldrb	r2, [r3, #0]
 80a213a:	2a2f      	cmp	r2, #47	; 0x2f
 80a213c:	d102      	bne.n	80a2144 <_ZN7FatFile4openEPS_PKci+0x3a>
      path++;
 80a213e:	3301      	adds	r3, #1
 80a2140:	9301      	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
 80a2142:	e7f8      	b.n	80a2136 <_ZN7FatFile4openEPS_PKci+0x2c>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
 80a2144:	68a1      	ldr	r1, [r4, #8]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
 80a2146:	b91a      	cbnz	r2, 80a2150 <_ZN7FatFile4openEPS_PKci+0x46>
      return openRoot(dirFile->m_vol);
 80a2148:	4630      	mov	r0, r6
 80a214a:	f7ff fdca 	bl	80a1ce2 <_ZN7FatFile8openRootEP9FatVolume>
 80a214e:	e029      	b.n	80a21a4 <_ZN7FatFile4openEPS_PKci+0x9a>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
 80a2150:	a809      	add	r0, sp, #36	; 0x24
 80a2152:	f7ff fdc6 	bl	80a1ce2 <_ZN7FatFile8openRootEP9FatVolume>
 80a2156:	2800      	cmp	r0, #0
 80a2158:	d0e4      	beq.n	80a2124 <_ZN7FatFile4openEPS_PKci+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
 80a215a:	ac09      	add	r4, sp, #36	; 0x24
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
 80a215c:	aa01      	add	r2, sp, #4
 80a215e:	a903      	add	r1, sp, #12
 80a2160:	9801      	ldr	r0, [sp, #4]
 80a2162:	f7ff fa67 	bl	80a1634 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_>
 80a2166:	2800      	cmp	r0, #0
 80a2168:	d0dc      	beq.n	80a2124 <_ZN7FatFile4openEPS_PKci+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
 80a216a:	9b01      	ldr	r3, [sp, #4]
 80a216c:	781b      	ldrb	r3, [r3, #0]
 80a216e:	b19b      	cbz	r3, 80a2198 <_ZN7FatFile4openEPS_PKci+0x8e>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
 80a2170:	2300      	movs	r3, #0
 80a2172:	aa03      	add	r2, sp, #12
 80a2174:	4621      	mov	r1, r4
 80a2176:	4630      	mov	r0, r6
 80a2178:	f7ff fb9e 	bl	80a18b8 <_ZN7FatFile4openEPS_P7fname_ti>
 80a217c:	2800      	cmp	r0, #0
 80a217e:	d0d1      	beq.n	80a2124 <_ZN7FatFile4openEPS_PKci+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
 80a2180:	4635      	mov	r5, r6
 80a2182:	ac09      	add	r4, sp, #36	; 0x24
 80a2184:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a2186:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a2188:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a218a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a218c:	682b      	ldr	r3, [r5, #0]
    dirFile = &tmpDir;
    close();
 80a218e:	4630      	mov	r0, r6
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
 80a2190:	6023      	str	r3, [r4, #0]
    dirFile = &tmpDir;
    close();
 80a2192:	f7ff ffb3 	bl	80a20fc <_ZN7FatFile5closeEv>
 80a2196:	e7e0      	b.n	80a215a <_ZN7FatFile4openEPS_PKci+0x50>
  }
  return open(dirFile, &fname, oflag);
 80a2198:	463b      	mov	r3, r7
 80a219a:	aa03      	add	r2, sp, #12
 80a219c:	4621      	mov	r1, r4
 80a219e:	4630      	mov	r0, r6
 80a21a0:	f7ff fb8a 	bl	80a18b8 <_ZN7FatFile4openEPS_P7fname_ti>

fail:
  return false;
}
 80a21a4:	b013      	add	sp, #76	; 0x4c
 80a21a6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a21a8 <_ZN7FatFile5writeEPKvj>:

fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::write(const void* buf, size_t nbyte) {
 80a21a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isFile() || !(m_flags & F_WRITE)) {
 80a21ac:	7803      	ldrb	r3, [r0, #0]

fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::write(const void* buf, size_t nbyte) {
 80a21ae:	4689      	mov	r9, r1
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isFile() || !(m_flags & F_WRITE)) {
 80a21b0:	0719      	lsls	r1, r3, #28

fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::write(const void* buf, size_t nbyte) {
 80a21b2:	4604      	mov	r4, r0
 80a21b4:	4690      	mov	r8, r2
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isFile() || !(m_flags & F_WRITE)) {
 80a21b6:	d508      	bpl.n	80a21ca <_ZN7FatFile5writeEPKvj+0x22>
 80a21b8:	7883      	ldrb	r3, [r0, #2]
 80a21ba:	079a      	lsls	r2, r3, #30
 80a21bc:	d505      	bpl.n	80a21ca <_ZN7FatFile5writeEPKvj+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & F_APPEND)) {
 80a21be:	071b      	lsls	r3, r3, #28
 80a21c0:	d50b      	bpl.n	80a21da <_ZN7FatFile5writeEPKvj+0x32>
    if (!seekSet(m_fileSize)) {
 80a21c2:	69e1      	ldr	r1, [r4, #28]
 80a21c4:	f7ff fead 	bl	80a1f22 <_ZN7FatFile7seekSetEm>
 80a21c8:	b938      	cbnz	r0, 80a21da <_ZN7FatFile5writeEPKvj+0x32>
  }
  return nbyte;

fail:
  // return for write error
  m_error |= WRITE_ERROR;
 80a21ca:	7863      	ldrb	r3, [r4, #1]
  return -1;
 80a21cc:	f04f 30ff 	mov.w	r0, #4294967295
  }
  return nbyte;

fail:
  // return for write error
  m_error |= WRITE_ERROR;
 80a21d0:	f043 0301 	orr.w	r3, r3, #1
 80a21d4:	7063      	strb	r3, [r4, #1]
  return -1;
 80a21d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
 80a21da:	6963      	ldr	r3, [r4, #20]
 80a21dc:	43db      	mvns	r3, r3
 80a21de:	4598      	cmp	r8, r3
 80a21e0:	d8f3      	bhi.n	80a21ca <_ZN7FatFile5writeEPKvj+0x22>
 80a21e2:	4646      	mov	r6, r8
    m_vol = vol;
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
 80a21e4:	f04f 0a00 	mov.w	sl, #0
 80a21e8:	6963      	ldr	r3, [r4, #20]
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
 80a21ea:	2e00      	cmp	r6, #0
 80a21ec:	d07f      	beq.n	80a22ee <_ZN7FatFile5writeEPKvj+0x146>
    uint8_t blockOfCluster = m_vol->blockOfCluster(m_curPosition);
 80a21ee:	68a0      	ldr	r0, [r4, #8]
    uint16_t blockOffset = m_curPosition & 0X1FF;
 80a21f0:	f3c3 0708 	ubfx	r7, r3, #0, #9
  }
//------------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t blockOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterBlockMask;
 80a21f4:	7942      	ldrb	r2, [r0, #5]
    if (blockOfCluster == 0 && blockOffset == 0) {
 80a21f6:	ea12 2553 	ands.w	r5, r2, r3, lsr #9
 80a21fa:	d11c      	bne.n	80a2236 <_ZN7FatFile5writeEPKvj+0x8e>
 80a21fc:	b9df      	cbnz	r7, 80a2236 <_ZN7FatFile5writeEPKvj+0x8e>
      // start of new cluster
      if (m_curCluster != 0) {
 80a21fe:	6921      	ldr	r1, [r4, #16]
 80a2200:	b171      	cbz	r1, 80a2220 <_ZN7FatFile5writeEPKvj+0x78>
        int8_t fg = m_vol->fatGet(m_curCluster, &m_curCluster);
 80a2202:	f104 0210 	add.w	r2, r4, #16
 80a2206:	f000 f900 	bl	80a240a <_ZN9FatVolume6fatGetEmPm>
        if (fg < 0) {
 80a220a:	2800      	cmp	r0, #0
 80a220c:	dbdd      	blt.n	80a21ca <_ZN7FatFile5writeEPKvj+0x22>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
 80a220e:	f040 808d 	bne.w	80a232c <_ZN7FatFile5writeEPKvj+0x184>
          // add cluster if at end of chain
          if (!addCluster()) {
 80a2212:	4620      	mov	r0, r4
 80a2214:	f7ff fd0c 	bl	80a1c30 <_ZN7FatFile10addClusterEv>
 80a2218:	2800      	cmp	r0, #0
 80a221a:	f040 8087 	bne.w	80a232c <_ZN7FatFile5writeEPKvj+0x184>
 80a221e:	e7d4      	b.n	80a21ca <_ZN7FatFile5writeEPKvj+0x22>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
 80a2220:	6a23      	ldr	r3, [r4, #32]
 80a2222:	b93b      	cbnz	r3, 80a2234 <_ZN7FatFile5writeEPKvj+0x8c>
          // allocate first cluster of file
          if (!addCluster()) {
 80a2224:	4620      	mov	r0, r4
 80a2226:	f7ff fd03 	bl	80a1c30 <_ZN7FatFile10addClusterEv>
 80a222a:	2800      	cmp	r0, #0
 80a222c:	d0cd      	beq.n	80a21ca <_ZN7FatFile5writeEPKvj+0x22>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
 80a222e:	6923      	ldr	r3, [r4, #16]
 80a2230:	6223      	str	r3, [r4, #32]
 80a2232:	e000      	b.n	80a2236 <_ZN7FatFile5writeEPKvj+0x8e>
        } else {
          m_curCluster = m_firstCluster;
 80a2234:	6123      	str	r3, [r4, #16]
        }
      }
    }
    // block for data write
    uint32_t block = m_vol->clusterFirstBlock(m_curCluster) + blockOfCluster;
 80a2236:	6921      	ldr	r1, [r4, #16]
 80a2238:	68a0      	ldr	r0, [r4, #8]
 80a223a:	f000 f8e0 	bl	80a23fe <_ZNK9FatVolume17clusterFirstBlockEm>
 80a223e:	1829      	adds	r1, r5, r0

    if (blockOffset != 0 || nToWrite < 512) {
 80a2240:	b917      	cbnz	r7, 80a2248 <_ZN7FatFile5writeEPKvj+0xa0>
 80a2242:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80a2246:	d221      	bcs.n	80a228c <_ZN7FatFile5writeEPKvj+0xe4>
      // partial block - must use cache
      // max space in block
      n = 512 - blockOffset;
 80a2248:	f5c7 7500 	rsb	r5, r7, #512	; 0x200
 80a224c:	42b5      	cmp	r5, r6
 80a224e:	bf28      	it	cs
 80a2250:	4635      	movcs	r5, r6
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (blockOffset == 0 && m_curPosition >= m_fileSize) {
 80a2252:	b937      	cbnz	r7, 80a2262 <_ZN7FatFile5writeEPKvj+0xba>
 80a2254:	6963      	ldr	r3, [r4, #20]
 80a2256:	69e2      	ldr	r2, [r4, #28]
        // start of new block don't need to read into cache
        cacheOption = FatCache::CACHE_RESERVE_FOR_WRITE;
 80a2258:	4293      	cmp	r3, r2
 80a225a:	bf34      	ite	cc
 80a225c:	2201      	movcc	r2, #1
 80a225e:	2205      	movcs	r2, #5
 80a2260:	e000      	b.n	80a2264 <_ZN7FatFile5writeEPKvj+0xbc>
      } else {
        // rewrite part of block
        cacheOption = FatCache::CACHE_FOR_WRITE;
 80a2262:	2201      	movs	r2, #1
  bool cacheSync() {
    return m_cache.sync() && syncBlocks();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t blockNumber, uint8_t options) {
    return m_cache.read(blockNumber, options);
 80a2264:	68a0      	ldr	r0, [r4, #8]
 80a2266:	3024      	adds	r0, #36	; 0x24
 80a2268:	f000 f8a5 	bl	80a23b6 <_ZN8FatCache4readEmh>
      }
      pc = m_vol->cacheFetchData(block, cacheOption);
      if (!pc) {
 80a226c:	2800      	cmp	r0, #0
 80a226e:	d0ac      	beq.n	80a21ca <_ZN7FatFile5writeEPKvj+0x22>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + blockOffset;
      memcpy(dst, src, n);
 80a2270:	4438      	add	r0, r7
 80a2272:	462a      	mov	r2, r5
 80a2274:	4649      	mov	r1, r9
      if (512 == (n + blockOffset)) {
 80a2276:	442f      	add	r7, r5
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + blockOffset;
      memcpy(dst, src, n);
 80a2278:	f002 fe41 	bl	80a4efe <memcpy>
      if (512 == (n + blockOffset)) {
 80a227c:	f5b7 7f00 	cmp.w	r7, #512	; 0x200
 80a2280:	d12f      	bne.n	80a22e2 <_ZN7FatFile5writeEPKvj+0x13a>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
 80a2282:	68a0      	ldr	r0, [r4, #8]
 80a2284:	3024      	adds	r0, #36	; 0x24
 80a2286:	f000 f86f 	bl	80a2368 <_ZN8FatCache4syncEv>
 80a228a:	e016      	b.n	80a22ba <_ZN7FatFile5writeEPKvj+0x112>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_BLOCK_IO
    } else if (nToWrite >= 1024) {
 80a228c:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 80a2290:	68a0      	ldr	r0, [r4, #8]
 80a2292:	d314      	bcc.n	80a22be <_ZN7FatFile5writeEPKvj+0x116>
      // use multiple block write command
      uint8_t maxBlocks = m_vol->blocksPerCluster() - blockOfCluster;
      size_t nb = nToWrite >> 9;
      if (nb > maxBlocks) {
 80a2294:	7902      	ldrb	r2, [r0, #4]
      }
#if USE_MULTI_BLOCK_IO
    } else if (nToWrite >= 1024) {
      // use multiple block write command
      uint8_t maxBlocks = m_vol->blocksPerCluster() - blockOfCluster;
      size_t nb = nToWrite >> 9;
 80a2296:	0a73      	lsrs	r3, r6, #9
      if (nb > maxBlocks) {
 80a2298:	1b52      	subs	r2, r2, r5
 80a229a:	b2d2      	uxtb	r2, r2
 80a229c:	4293      	cmp	r3, r2
 80a229e:	bf28      	it	cs
 80a22a0:	4613      	movcs	r3, r2
 80a22a2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
        nb = maxBlocks;
      }
      n = 512*nb;
 80a22a4:	025d      	lsls	r5, r3, #9
      if (m_vol->cacheBlockNumber() <= block
          && block < (m_vol->cacheBlockNumber() + nb)) {
 80a22a6:	4291      	cmp	r1, r2
 80a22a8:	d302      	bcc.n	80a22b0 <_ZN7FatFile5writeEPKvj+0x108>
 80a22aa:	441a      	add	r2, r3
 80a22ac:	4291      	cmp	r1, r2
 80a22ae:	d337      	bcc.n	80a2320 <_ZN7FatFile5writeEPKvj+0x178>
 80a22b0:	68a7      	ldr	r7, [r4, #8]
#if USE_MULTI_BLOCK_IO
  bool readBlocks(uint32_t block, uint8_t* dst, size_t nb) {
    return m_blockDev->readBlocks(block, dst, nb);
  }
  bool writeBlocks(uint32_t block, const uint8_t* src, size_t nb) {
    return m_blockDev->writeBlocks(block, src, nb);
 80a22b2:	464a      	mov	r2, r9
 80a22b4:	6838      	ldr	r0, [r7, #0]
 80a22b6:	f000 fc6d 	bl	80a2b94 <_ZN9SdSpiCard11writeBlocksEmPKhj>
        // invalidate cache if block is in cache
        m_vol->cacheInvalidate();
      }
      if (!m_vol->writeBlocks(block, src, nb)) {
 80a22ba:	b990      	cbnz	r0, 80a22e2 <_ZN7FatFile5writeEPKvj+0x13a>
 80a22bc:	e785      	b.n	80a21ca <_ZN7FatFile5writeEPKvj+0x22>
      }
#endif  // USE_MULTI_BLOCK_IO
    } else {
      // use single block write command
      n = 512;
      if (m_vol->cacheBlockNumber() == block) {
 80a22be:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  }
  bool syncBlocks() {
    return m_blockDev->syncBlocks();
  }
  bool writeBlock(uint32_t block, const uint8_t* src) {
    return m_blockDev->writeBlock(block, src);
 80a22c0:	464a      	mov	r2, r9
 80a22c2:	4299      	cmp	r1, r3
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
    m_lbn = 0XFFFFFFFF;
 80a22c4:	bf02      	ittt	eq
 80a22c6:	f04f 33ff 	moveq.w	r3, #4294967295
    m_vol = vol;
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
 80a22ca:	f880 a024 	strbeq.w	sl, [r0, #36]	; 0x24
    m_lbn = 0XFFFFFFFF;
 80a22ce:	62c3      	streq	r3, [r0, #44]	; 0x2c
 80a22d0:	68a3      	ldr	r3, [r4, #8]
  }
  bool syncBlocks() {
    return m_blockDev->syncBlocks();
  }
  bool writeBlock(uint32_t block, const uint8_t* src) {
    return m_blockDev->writeBlock(block, src);
 80a22d2:	6818      	ldr	r0, [r3, #0]
 80a22d4:	f000 fbec 	bl	80a2ab0 <_ZN9SdSpiCard10writeBlockEmPKh>
        m_vol->cacheInvalidate();
      }
      if (!m_vol->writeBlock(block, src)) {
 80a22d8:	2800      	cmp	r0, #0
 80a22da:	f43f af76 	beq.w	80a21ca <_ZN7FatFile5writeEPKvj+0x22>
        goto fail;
      }
#endif  // USE_MULTI_BLOCK_IO
    } else {
      // use single block write command
      n = 512;
 80a22de:	f44f 7500 	mov.w	r5, #512	; 0x200
      if (!m_vol->writeBlock(block, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
 80a22e2:	6963      	ldr	r3, [r4, #20]
    src += n;
 80a22e4:	44a9      	add	r9, r5
      if (!m_vol->writeBlock(block, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
 80a22e6:	442b      	add	r3, r5
 80a22e8:	6163      	str	r3, [r4, #20]
    src += n;
    nToWrite -= n;
 80a22ea:	1b76      	subs	r6, r6, r5
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
 80a22ec:	e77c      	b.n	80a21e8 <_ZN7FatFile5writeEPKvj+0x40>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
 80a22ee:	69e2      	ldr	r2, [r4, #28]
 80a22f0:	4293      	cmp	r3, r2
 80a22f2:	d901      	bls.n	80a22f8 <_ZN7FatFile5writeEPKvj+0x150>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
 80a22f4:	61e3      	str	r3, [r4, #28]
 80a22f6:	e002      	b.n	80a22fe <_ZN7FatFile5writeEPKvj+0x156>
    m_flags |= F_FILE_DIR_DIRTY;
  } else if (m_dateTime) {
 80a22f8:	4b0f      	ldr	r3, [pc, #60]	; (80a2338 <_ZN7FatFile5writeEPKvj+0x190>)
 80a22fa:	681b      	ldr	r3, [r3, #0]
 80a22fc:	b11b      	cbz	r3, 80a2306 <_ZN7FatFile5writeEPKvj+0x15e>
    // insure sync will update modified date and time
    m_flags |= F_FILE_DIR_DIRTY;
 80a22fe:	78a3      	ldrb	r3, [r4, #2]
 80a2300:	f043 0304 	orr.w	r3, r3, #4
 80a2304:	70a3      	strb	r3, [r4, #2]
  }

  if (m_flags & F_SYNC) {
 80a2306:	f994 3002 	ldrsb.w	r3, [r4, #2]
 80a230a:	2b00      	cmp	r3, #0
 80a230c:	db02      	blt.n	80a2314 <_ZN7FatFile5writeEPKvj+0x16c>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  return nbyte;
 80a230e:	4640      	mov	r0, r8
 80a2310:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    // insure sync will update modified date and time
    m_flags |= F_FILE_DIR_DIRTY;
  }

  if (m_flags & F_SYNC) {
    if (!sync()) {
 80a2314:	4620      	mov	r0, r4
 80a2316:	f7ff febb 	bl	80a2090 <_ZN7FatFile4syncEv>
 80a231a:	2800      	cmp	r0, #0
 80a231c:	d1f7      	bne.n	80a230e <_ZN7FatFile5writeEPKvj+0x166>
 80a231e:	e754      	b.n	80a21ca <_ZN7FatFile5writeEPKvj+0x22>
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
    m_lbn = 0XFFFFFFFF;
 80a2320:	f04f 32ff 	mov.w	r2, #4294967295
    m_vol = vol;
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
 80a2324:	f880 a024 	strb.w	sl, [r0, #36]	; 0x24
    m_lbn = 0XFFFFFFFF;
 80a2328:	62c2      	str	r2, [r0, #44]	; 0x2c
 80a232a:	e7c1      	b.n	80a22b0 <_ZN7FatFile5writeEPKvj+0x108>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // block for data write
    uint32_t block = m_vol->clusterFirstBlock(m_curCluster) + blockOfCluster;
 80a232c:	6921      	ldr	r1, [r4, #16]
 80a232e:	68a0      	ldr	r0, [r4, #8]
 80a2330:	f000 f865 	bl	80a23fe <_ZNK9FatVolume17clusterFirstBlockEm>
 80a2334:	4601      	mov	r1, r0
 80a2336:	e784      	b.n	80a2242 <_ZN7FatFile5writeEPKvj+0x9a>
 80a2338:	20000af8 	.word	0x20000af8

080a233c <_GLOBAL__sub_I__ZN7FatFile5m_cwdE>:
 80a233c:	f000 be1e 	b.w	80a2f7c <HAL_Pin_Map>

080a2340 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a2340:	b570      	push	{r4, r5, r6, lr}
 80a2342:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a2344:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a2346:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a2348:	b149      	cbz	r1, 80a235e <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a234a:	f002 fe33 	bl	80a4fb4 <strlen>
 80a234e:	682b      	ldr	r3, [r5, #0]
 80a2350:	4602      	mov	r2, r0
 80a2352:	4621      	mov	r1, r4
 80a2354:	4628      	mov	r0, r5
    }
 80a2356:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a235a:	68db      	ldr	r3, [r3, #12]
 80a235c:	4718      	bx	r3
    }
 80a235e:	bd70      	pop	{r4, r5, r6, pc}

080a2360 <_GLOBAL__sub_I__ZN7FatFile7dmpFileEP5Printmj>:
 80a2360:	f000 be0c 	b.w	80a2f7c <HAL_Pin_Map>

080a2364 <_GLOBAL__sub_I__ZN13FatStreamBase5getchEv>:
 80a2364:	f000 be0a 	b.w	80a2f7c <HAL_Pin_Map>

080a2368 <_ZN8FatCache4syncEv>:
fail:

  return 0;
}
//------------------------------------------------------------------------------
bool FatCache::sync() {
 80a2368:	b570      	push	{r4, r5, r6, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
 80a236a:	7803      	ldrb	r3, [r0, #0]
fail:

  return 0;
}
//------------------------------------------------------------------------------
bool FatCache::sync() {
 80a236c:	4604      	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
 80a236e:	07da      	lsls	r2, r3, #31
 80a2370:	d51e      	bpl.n	80a23b0 <_ZN8FatCache4syncEv+0x48>
 80a2372:	6843      	ldr	r3, [r0, #4]
    if (!m_vol->writeBlock(m_lbn, m_block.data)) {
 80a2374:	f100 060c 	add.w	r6, r0, #12
  }
  bool syncBlocks() {
    return m_blockDev->syncBlocks();
  }
  bool writeBlock(uint32_t block, const uint8_t* src) {
    return m_blockDev->writeBlock(block, src);
 80a2378:	6881      	ldr	r1, [r0, #8]
 80a237a:	4632      	mov	r2, r6
 80a237c:	6818      	ldr	r0, [r3, #0]
 80a237e:	f000 fb97 	bl	80a2ab0 <_ZN9SdSpiCard10writeBlockEmPKh>
 80a2382:	4605      	mov	r5, r0
 80a2384:	b908      	cbnz	r0, 80a238a <_ZN8FatCache4syncEv+0x22>
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

fail:
  return false;
 80a2386:	2500      	movs	r5, #0
 80a2388:	e013      	b.n	80a23b2 <_ZN8FatCache4syncEv+0x4a>
    if (!m_vol->writeBlock(m_lbn, m_block.data)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
 80a238a:	7823      	ldrb	r3, [r4, #0]
 80a238c:	079b      	lsls	r3, r3, #30
 80a238e:	d404      	bmi.n	80a239a <_ZN8FatCache4syncEv+0x32>
      if (!m_vol->writeBlock(lbn, m_block.data)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
 80a2390:	7823      	ldrb	r3, [r4, #0]
 80a2392:	f023 0301 	bic.w	r3, r3, #1
 80a2396:	7023      	strb	r3, [r4, #0]
 80a2398:	e00b      	b.n	80a23b2 <_ZN8FatCache4syncEv+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t lbn = m_lbn + m_vol->blocksPerFat();
 80a239a:	6863      	ldr	r3, [r4, #4]
 80a239c:	68a0      	ldr	r0, [r4, #8]
 80a239e:	6919      	ldr	r1, [r3, #16]
 80a23a0:	4632      	mov	r2, r6
 80a23a2:	4401      	add	r1, r0
 80a23a4:	6818      	ldr	r0, [r3, #0]
 80a23a6:	f000 fb83 	bl	80a2ab0 <_ZN9SdSpiCard10writeBlockEmPKh>
      if (!m_vol->writeBlock(lbn, m_block.data)) {
 80a23aa:	2800      	cmp	r0, #0
 80a23ac:	d1f0      	bne.n	80a2390 <_ZN8FatCache4syncEv+0x28>
 80a23ae:	e7ea      	b.n	80a2386 <_ZN8FatCache4syncEv+0x1e>
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;
 80a23b0:	2501      	movs	r5, #1

fail:
  return false;
}
 80a23b2:	4628      	mov	r0, r5
 80a23b4:	bd70      	pop	{r4, r5, r6, pc}

080a23b6 <_ZN8FatCache4readEmh>:
 * DEALINGS IN THE SOFTWARE.
 */
#include <string.h>
#include "FatVolume.h"
//------------------------------------------------------------------------------
cache_t* FatCache::read(uint32_t lbn, uint8_t option) {
 80a23b6:	b570      	push	{r4, r5, r6, lr}
  if (m_lbn != lbn) {
 80a23b8:	6883      	ldr	r3, [r0, #8]
 * DEALINGS IN THE SOFTWARE.
 */
#include <string.h>
#include "FatVolume.h"
//------------------------------------------------------------------------------
cache_t* FatCache::read(uint32_t lbn, uint8_t option) {
 80a23ba:	4604      	mov	r4, r0
  if (m_lbn != lbn) {
 80a23bc:	428b      	cmp	r3, r1
 * DEALINGS IN THE SOFTWARE.
 */
#include <string.h>
#include "FatVolume.h"
//------------------------------------------------------------------------------
cache_t* FatCache::read(uint32_t lbn, uint8_t option) {
 80a23be:	460e      	mov	r6, r1
 80a23c0:	4615      	mov	r5, r2
  if (m_lbn != lbn) {
 80a23c2:	d014      	beq.n	80a23ee <_ZN8FatCache4readEmh+0x38>
    if (!sync()) {
 80a23c4:	f7ff ffd0 	bl	80a2368 <_ZN8FatCache4syncEv>
 80a23c8:	b908      	cbnz	r0, 80a23ce <_ZN8FatCache4readEmh+0x18>
  m_status |= option & CACHE_STATUS_MASK;
  return &m_block;

fail:

  return 0;
 80a23ca:	2000      	movs	r0, #0
 80a23cc:	bd70      	pop	{r4, r5, r6, pc}
  if (m_lbn != lbn) {
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
 80a23ce:	076b      	lsls	r3, r5, #29
 80a23d0:	d503      	bpl.n	80a23da <_ZN8FatCache4readEmh+0x24>
      if (!m_vol->readBlock(lbn, m_block.data)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
 80a23d2:	2300      	movs	r3, #0
 80a23d4:	7023      	strb	r3, [r4, #0]
    m_lbn = lbn;
 80a23d6:	60a6      	str	r6, [r4, #8]
 80a23d8:	e009      	b.n	80a23ee <_ZN8FatCache4readEmh+0x38>
 80a23da:	6863      	ldr	r3, [r4, #4]
  uint32_t m_lastCluster;          // Last cluster number in FAT.
  uint32_t m_rootDirStart;         // Start block for FAT16, cluster for FAT32.
//------------------------------------------------------------------------------
  // block I/O functions.
  bool readBlock(uint32_t block, uint8_t* dst) {
    return m_blockDev->readBlock(block, dst);
 80a23dc:	f104 020c 	add.w	r2, r4, #12
 80a23e0:	4631      	mov	r1, r6
 80a23e2:	6818      	ldr	r0, [r3, #0]
 80a23e4:	f000 fada 	bl	80a299c <_ZN9SdSpiCard9readBlockEmPh>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_vol->readBlock(lbn, m_block.data)) {
 80a23e8:	2800      	cmp	r0, #0
 80a23ea:	d1f2      	bne.n	80a23d2 <_ZN8FatCache4readEmh+0x1c>
 80a23ec:	e7ed      	b.n	80a23ca <_ZN8FatCache4readEmh+0x14>
      }
    }
    m_status = 0;
    m_lbn = lbn;
  }
  m_status |= option & CACHE_STATUS_MASK;
 80a23ee:	4620      	mov	r0, r4
 80a23f0:	7823      	ldrb	r3, [r4, #0]
 80a23f2:	f005 0503 	and.w	r5, r5, #3
 80a23f6:	431d      	orrs	r5, r3
 80a23f8:	f800 5b0c 	strb.w	r5, [r0], #12
  return &m_block;

fail:

  return 0;
}
 80a23fc:	bd70      	pop	{r4, r5, r6, pc}

080a23fe <_ZNK9FatVolume17clusterFirstBlockEm>:
fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t FatVolume::clusterFirstBlock(uint32_t cluster) const {
  return m_dataStartBlock + ((cluster - 2) << m_clusterSizeShift);
 80a23fe:	7983      	ldrb	r3, [r0, #6]
 80a2400:	3902      	subs	r1, #2
 80a2402:	6940      	ldr	r0, [r0, #20]
 80a2404:	4099      	lsls	r1, r3
}
 80a2406:	4408      	add	r0, r1
 80a2408:	4770      	bx	lr

080a240a <_ZN9FatVolume6fatGetEmPm>:
  uint32_t lba;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
 80a240a:	2901      	cmp	r1, #1
uint32_t FatVolume::clusterFirstBlock(uint32_t cluster) const {
  return m_dataStartBlock + ((cluster - 2) << m_clusterSizeShift);
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatVolume::fatGet(uint32_t cluster, uint32_t* value) {
 80a240c:	b570      	push	{r4, r5, r6, lr}
 80a240e:	4605      	mov	r5, r0
 80a2410:	460c      	mov	r4, r1
 80a2412:	4616      	mov	r6, r2
  uint32_t lba;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
 80a2414:	d802      	bhi.n	80a241c <_ZN9FatVolume6fatGetEmPm+0x12>
  }
  *value = next;
  return 1;

fail:
  return -1;
 80a2416:	f04f 30ff 	mov.w	r0, #4294967295
 80a241a:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t lba;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
 80a241c:	69c3      	ldr	r3, [r0, #28]
 80a241e:	4299      	cmp	r1, r3
 80a2420:	d8f9      	bhi.n	80a2416 <_ZN9FatVolume6fatGetEmPm+0xc>
 80a2422:	79c3      	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
 80a2424:	2b20      	cmp	r3, #32
 80a2426:	d110      	bne.n	80a244a <_ZN9FatVolume6fatGetEmPm+0x40>
  FatCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FatCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t blockNumber, uint8_t options) {
    return m_fatCache.read(blockNumber,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
 80a2428:	6981      	ldr	r1, [r0, #24]
 80a242a:	2202      	movs	r2, #2
 80a242c:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 80a2430:	f500 700c 	add.w	r0, r0, #560	; 0x230
 80a2434:	f7ff ffbf 	bl	80a23b6 <_ZN8FatCache4readEmh>
    lba = m_fatStartBlock + (cluster >> 7);
    pc = cacheFetchFat(lba, FatCache::CACHE_FOR_READ);
    if (!pc) {
 80a2438:	2800      	cmp	r0, #0
 80a243a:	d0ec      	beq.n	80a2416 <_ZN9FatVolume6fatGetEmPm+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = pc->fat32[cluster & 0X7F] & FAT32MASK;
 80a243c:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 80a2440:	f850 3024 	ldr.w	r3, [r0, r4, lsl #2]
 80a2444:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    goto done;
 80a2448:	e00f      	b.n	80a246a <_ZN9FatVolume6fatGetEmPm+0x60>
  }
  if (fatType() == 16) {
 80a244a:	2b10      	cmp	r3, #16
 80a244c:	d1e3      	bne.n	80a2416 <_ZN9FatVolume6fatGetEmPm+0xc>
 80a244e:	6983      	ldr	r3, [r0, #24]
 80a2450:	f3c1 2107 	ubfx	r1, r1, #8, #8
 80a2454:	2202      	movs	r2, #2
 80a2456:	4419      	add	r1, r3
 80a2458:	f500 700c 	add.w	r0, r0, #560	; 0x230
 80a245c:	f7ff ffab 	bl	80a23b6 <_ZN8FatCache4readEmh>
    lba = m_fatStartBlock + ((cluster >> 8) & 0XFF);
    pc = cacheFetchFat(lba, FatCache::CACHE_FOR_READ);
    if (!pc) {
 80a2460:	2800      	cmp	r0, #0
 80a2462:	d0d8      	beq.n	80a2416 <_ZN9FatVolume6fatGetEmPm+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = pc->fat16[cluster & 0XFF];
 80a2464:	b2e4      	uxtb	r4, r4
 80a2466:	f830 3014 	ldrh.w	r3, [r0, r4, lsl #1]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
done:
  if (isEOC(next)) {
 80a246a:	69ea      	ldr	r2, [r5, #28]
 80a246c:	4293      	cmp	r3, r2
    return 0;
  }
  *value = next;
 80a246e:	bf9a      	itte	ls
 80a2470:	6033      	strls	r3, [r6, #0]
  return 1;
 80a2472:	2001      	movls	r0, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
done:
  if (isEOC(next)) {
    return 0;
 80a2474:	2000      	movhi	r0, #0
  *value = next;
  return 1;

fail:
  return -1;
}
 80a2476:	bd70      	pop	{r4, r5, r6, pc}

080a2478 <_ZN9FatVolume6fatPutEmm>:
bool FatVolume::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t lba;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
 80a2478:	2901      	cmp	r1, #1
fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatVolume::fatPut(uint32_t cluster, uint32_t value) {
 80a247a:	b538      	push	{r3, r4, r5, lr}
 80a247c:	460c      	mov	r4, r1
 80a247e:	4615      	mov	r5, r2
  uint32_t lba;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
 80a2480:	d801      	bhi.n	80a2486 <_ZN9FatVolume6fatPutEmm+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }

fail:
  return false;
 80a2482:	2000      	movs	r0, #0
 80a2484:	bd38      	pop	{r3, r4, r5, pc}
bool FatVolume::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t lba;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
 80a2486:	69c3      	ldr	r3, [r0, #28]
 80a2488:	4299      	cmp	r1, r3
 80a248a:	d8fa      	bhi.n	80a2482 <_ZN9FatVolume6fatPutEmm+0xa>
 80a248c:	79c3      	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
 80a248e:	2b20      	cmp	r3, #32
 80a2490:	d10e      	bne.n	80a24b0 <_ZN9FatVolume6fatPutEmm+0x38>
 80a2492:	6981      	ldr	r1, [r0, #24]
 80a2494:	2203      	movs	r2, #3
 80a2496:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 80a249a:	f500 700c 	add.w	r0, r0, #560	; 0x230
 80a249e:	f7ff ff8a 	bl	80a23b6 <_ZN8FatCache4readEmh>
    lba = m_fatStartBlock + (cluster >> 7);
    pc = cacheFetchFat(lba, FatCache::CACHE_FOR_WRITE);
    if (!pc) {
 80a24a2:	2800      	cmp	r0, #0
 80a24a4:	d0ed      	beq.n	80a2482 <_ZN9FatVolume6fatPutEmm+0xa>
      DBG_FAIL_MACRO;
      goto fail;
    }
    pc->fat32[cluster & 0X7F] = value;
 80a24a6:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 80a24aa:	f840 5024 	str.w	r5, [r0, r4, lsl #2]
 80a24ae:	e00f      	b.n	80a24d0 <_ZN9FatVolume6fatPutEmm+0x58>
    return true;
  }

  if (fatType() == 16) {
 80a24b0:	2b10      	cmp	r3, #16
 80a24b2:	d1e6      	bne.n	80a2482 <_ZN9FatVolume6fatPutEmm+0xa>
 80a24b4:	6983      	ldr	r3, [r0, #24]
 80a24b6:	f3c1 2107 	ubfx	r1, r1, #8, #8
 80a24ba:	2203      	movs	r2, #3
 80a24bc:	4419      	add	r1, r3
 80a24be:	f500 700c 	add.w	r0, r0, #560	; 0x230
 80a24c2:	f7ff ff78 	bl	80a23b6 <_ZN8FatCache4readEmh>
    lba = m_fatStartBlock + ((cluster >> 8) & 0XFF);
    pc = cacheFetchFat(lba, FatCache::CACHE_FOR_WRITE);
    if (!pc) {
 80a24c6:	2800      	cmp	r0, #0
 80a24c8:	d0db      	beq.n	80a2482 <_ZN9FatVolume6fatPutEmm+0xa>
      DBG_FAIL_MACRO;
      goto fail;
    }
    pc->fat16[cluster & 0XFF] = value;
 80a24ca:	b2e4      	uxtb	r4, r4
 80a24cc:	f820 5014 	strh.w	r5, [r0, r4, lsl #1]
    return true;
 80a24d0:	2001      	movs	r0, #1
    goto fail;
  }

fail:
  return false;
}
 80a24d2:	bd38      	pop	{r3, r4, r5, pc}

080a24d4 <_ZN9FatVolume15allocateClusterEmPm>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatVolume::allocateCluster(uint32_t current, uint32_t* next) {
 80a24d4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
 80a24d8:	68c4      	ldr	r4, [r0, #12]

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatVolume::allocateCluster(uint32_t current, uint32_t* next) {
 80a24da:	4605      	mov	r5, r0
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
 80a24dc:	428c      	cmp	r4, r1

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatVolume::allocateCluster(uint32_t current, uint32_t* next) {
 80a24de:	460e      	mov	r6, r1
 80a24e0:	4690      	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
 80a24e2:	d207      	bcs.n	80a24f4 <_ZN9FatVolume15allocateClusterEmPm+0x20>
 80a24e4:	460c      	mov	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
 80a24e6:	2700      	movs	r7, #0
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
 80a24e8:	69eb      	ldr	r3, [r5, #28]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
 80a24ea:	3401      	adds	r4, #1
    if (find > m_lastCluster) {
 80a24ec:	429c      	cmp	r4, r3
 80a24ee:	d903      	bls.n	80a24f8 <_ZN9FatVolume15allocateClusterEmPm+0x24>
      if (setStart) {
 80a24f0:	b9cf      	cbnz	r7, 80a2526 <_ZN9FatVolume15allocateClusterEmPm+0x52>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
 80a24f2:	68ec      	ldr	r4, [r5, #12]
      setStart = true;
 80a24f4:	2701      	movs	r7, #1
 80a24f6:	e7f7      	b.n	80a24e8 <_ZN9FatVolume15allocateClusterEmPm+0x14>
      continue;
    }
    if (find == current) {
 80a24f8:	42a6      	cmp	r6, r4
 80a24fa:	d014      	beq.n	80a2526 <_ZN9FatVolume15allocateClusterEmPm+0x52>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
 80a24fc:	aa01      	add	r2, sp, #4
 80a24fe:	4621      	mov	r1, r4
 80a2500:	4628      	mov	r0, r5
 80a2502:	f7ff ff82 	bl	80a240a <_ZN9FatVolume6fatGetEmPm>
    if (fg < 0) {
 80a2506:	2800      	cmp	r0, #0
 80a2508:	db0d      	blt.n	80a2526 <_ZN9FatVolume15allocateClusterEmPm+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
 80a250a:	d0ed      	beq.n	80a24e8 <_ZN9FatVolume15allocateClusterEmPm+0x14>
 80a250c:	9b01      	ldr	r3, [sp, #4]
 80a250e:	2b00      	cmp	r3, #0
 80a2510:	d1ea      	bne.n	80a24e8 <_ZN9FatVolume15allocateClusterEmPm+0x14>
      break;
    }
  }
  if (setStart) {
 80a2512:	b107      	cbz	r7, 80a2516 <_ZN9FatVolume15allocateClusterEmPm+0x42>
    m_allocSearchStart = find;
 80a2514:	60ec      	str	r4, [r5, #12]
  }
  uint32_t clusterFirstBlock(uint32_t cluster) const;
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
 80a2516:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 80a251a:	4621      	mov	r1, r4
 80a251c:	4628      	mov	r0, r5
 80a251e:	f7ff ffab 	bl	80a2478 <_ZN9FatVolume6fatPutEmm>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
 80a2522:	4607      	mov	r7, r0
 80a2524:	b908      	cbnz	r0, 80a252a <_ZN9FatVolume15allocateClusterEmPm+0x56>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

fail:
  return false;
 80a2526:	2700      	movs	r7, #0
 80a2528:	e00b      	b.n	80a2542 <_ZN9FatVolume15allocateClusterEmPm+0x6e>
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
 80a252a:	b916      	cbnz	r6, 80a2532 <_ZN9FatVolume15allocateClusterEmPm+0x5e>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
 80a252c:	f8c8 4000 	str.w	r4, [r8]
  return true;
 80a2530:	e007      	b.n	80a2542 <_ZN9FatVolume15allocateClusterEmPm+0x6e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    // Link clusters.
    if (!fatPut(current, find)) {
 80a2532:	4622      	mov	r2, r4
 80a2534:	4631      	mov	r1, r6
 80a2536:	4628      	mov	r0, r5
 80a2538:	f7ff ff9e 	bl	80a2478 <_ZN9FatVolume6fatPutEmm>
 80a253c:	2800      	cmp	r0, #0
 80a253e:	d1f5      	bne.n	80a252c <_ZN9FatVolume15allocateClusterEmPm+0x58>
 80a2540:	e7f1      	b.n	80a2526 <_ZN9FatVolume15allocateClusterEmPm+0x52>
  *next = find;
  return true;

fail:
  return false;
}
 80a2542:	4638      	mov	r0, r7
 80a2544:	b002      	add	sp, #8
 80a2546:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a254a <_ZN9FatVolume9freeChainEm>:
fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatVolume::freeChain(uint32_t cluster) {
 80a254a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a254c:	4605      	mov	r5, r0
 80a254e:	460c      	mov	r4, r1
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
 80a2550:	aa01      	add	r2, sp, #4
 80a2552:	4621      	mov	r1, r4
 80a2554:	4628      	mov	r0, r5
 80a2556:	f7ff ff58 	bl	80a240a <_ZN9FatVolume6fatGetEmPm>
    if (fg < 0) {
 80a255a:	1e06      	subs	r6, r0, #0
 80a255c:	da01      	bge.n	80a2562 <_ZN9FatVolume9freeChainEm+0x18>
  } while (fg);

  return true;

fail:
  return false;
 80a255e:	2000      	movs	r0, #0
 80a2560:	e00f      	b.n	80a2582 <_ZN9FatVolume9freeChainEm+0x38>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
 80a2562:	2200      	movs	r2, #0
 80a2564:	4621      	mov	r1, r4
 80a2566:	4628      	mov	r0, r5
 80a2568:	f7ff ff86 	bl	80a2478 <_ZN9FatVolume6fatPutEmm>
 80a256c:	2800      	cmp	r0, #0
 80a256e:	d0f6      	beq.n	80a255e <_ZN9FatVolume9freeChainEm+0x14>
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);

    if (cluster <= m_allocSearchStart) {
 80a2570:	68eb      	ldr	r3, [r5, #12]
 80a2572:	429c      	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
 80a2574:	bf9c      	itt	ls
 80a2576:	f104 34ff 	addls.w	r4, r4, #4294967295
 80a257a:	60ec      	strls	r4, [r5, #12]
    }
    cluster = next;
 80a257c:	9c01      	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatVolume::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
 80a257e:	2e00      	cmp	r6, #0
 80a2580:	d1e6      	bne.n	80a2550 <_ZN9FatVolume9freeChainEm+0x6>

  return true;

fail:
  return false;
}
 80a2582:	b002      	add	sp, #8
 80a2584:	bd70      	pop	{r4, r5, r6, pc}

080a2586 <_ZN9FatVolume4initEh>:

fail:
  return -1;
}
//------------------------------------------------------------------------------
bool FatVolume::init(uint8_t part) {
 80a2586:	b570      	push	{r4, r5, r6, lr}
 80a2588:	4604      	mov	r4, r0
  uint32_t volumeStartBlock = 0;
  fat32_boot_t* fbs;
  cache_t* pc;
  uint8_t tmp;
  m_fatType = 0;
  m_allocSearchStart = 1;
 80a258a:	2301      	movs	r3, #1
  uint32_t totalBlocks;
  uint32_t volumeStartBlock = 0;
  fat32_boot_t* fbs;
  cache_t* pc;
  uint8_t tmp;
  m_fatType = 0;
 80a258c:	2200      	movs	r2, #0
  m_allocSearchStart = 1;
 80a258e:	60c3      	str	r3, [r0, #12]
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
    m_lbn = 0XFFFFFFFF;
 80a2590:	f04f 33ff 	mov.w	r3, #4294967295
  uint32_t totalBlocks;
  uint32_t volumeStartBlock = 0;
  fat32_boot_t* fbs;
  cache_t* pc;
  uint8_t tmp;
  m_fatType = 0;
 80a2594:	71c2      	strb	r2, [r0, #7]
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(this);
#endif  // USE_SEPARATE_FAT_CACHE
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
 80a2596:	460d      	mov	r5, r1
  }
  /** Initialize the cache.
   * \param[in] vol FatVolume that owns this FatCache.
   */
  void init(FatVolume *vol) {
    m_vol = vol;
 80a2598:	62a0      	str	r0, [r4, #40]	; 0x28
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
 80a259a:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
    m_lbn = 0XFFFFFFFF;
 80a259e:	62c3      	str	r3, [r0, #44]	; 0x2c
  }
  /** Initialize the cache.
   * \param[in] vol FatVolume that owns this FatCache.
   */
  void init(FatVolume *vol) {
    m_vol = vol;
 80a25a0:	f8c4 0234 	str.w	r0, [r4, #564]	; 0x234
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
 80a25a4:	f880 2230 	strb.w	r2, [r0, #560]	; 0x230
    m_lbn = 0XFFFFFFFF;
 80a25a8:	f8c0 3238 	str.w	r3, [r0, #568]	; 0x238
 80a25ac:	b1a1      	cbz	r1, 80a25d8 <_ZN9FatVolume4initEh+0x52>
    if (part > 4) {
 80a25ae:	2904      	cmp	r1, #4
 80a25b0:	d85d      	bhi.n	80a266e <_ZN9FatVolume4initEh+0xe8>
  bool cacheSync() {
    return m_cache.sync() && syncBlocks();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t blockNumber, uint8_t options) {
    return m_cache.read(blockNumber, options);
 80a25b2:	4611      	mov	r1, r2
 80a25b4:	3024      	adds	r0, #36	; 0x24
 80a25b6:	f7ff fefe 	bl	80a23b6 <_ZN8FatCache4readEmh>
      DBG_FAIL_MACRO;
      goto fail;
    }
    pc = cacheFetchData(0, FatCache::CACHE_FOR_READ);
    if (!pc) {
 80a25ba:	2800      	cmp	r0, #0
 80a25bc:	d057      	beq.n	80a266e <_ZN9FatVolume4initEh+0xe8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    part_t* p = &pc->mbr.part[part - 1];
    if ((p->boot & 0X7F) != 0 || p->firstSector == 0) {
 80a25be:	eb00 1305 	add.w	r3, r0, r5, lsl #4
 80a25c2:	f893 31ae 	ldrb.w	r3, [r3, #430]	; 0x1ae
 80a25c6:	065b      	lsls	r3, r3, #25
 80a25c8:	d151      	bne.n	80a266e <_ZN9FatVolume4initEh+0xe8>
 80a25ca:	351b      	adds	r5, #27
 80a25cc:	eb00 1505 	add.w	r5, r0, r5, lsl #4
 80a25d0:	f8d5 5006 	ldr.w	r5, [r5, #6]
 80a25d4:	2d00      	cmp	r5, #0
 80a25d6:	d04a      	beq.n	80a266e <_ZN9FatVolume4initEh+0xe8>
 80a25d8:	2200      	movs	r2, #0
 80a25da:	4629      	mov	r1, r5
 80a25dc:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80a25e0:	f7ff fee9 	bl	80a23b6 <_ZN8FatCache4readEmh>
      goto fail;
    }
    volumeStartBlock = p->firstSector;
  }
  pc = cacheFetchData(volumeStartBlock, FatCache::CACHE_FOR_READ);
  if (!pc) {
 80a25e4:	2800      	cmp	r0, #0
 80a25e6:	d042      	beq.n	80a266e <_ZN9FatVolume4initEh+0xe8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  fbs = &(pc->fbs32);
  if (fbs->bytesPerSector != 512 ||
 80a25e8:	f8b0 300b 	ldrh.w	r3, [r0, #11]
 80a25ec:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80a25f0:	d13d      	bne.n	80a266e <_ZN9FatVolume4initEh+0xe8>
 80a25f2:	7c03      	ldrb	r3, [r0, #16]
 80a25f4:	2b02      	cmp	r3, #2
 80a25f6:	d13a      	bne.n	80a266e <_ZN9FatVolume4initEh+0xe8>
      fbs->fatCount != 2 ||
 80a25f8:	89c3      	ldrh	r3, [r0, #14]
 80a25fa:	2b00      	cmp	r3, #0
 80a25fc:	d037      	beq.n	80a266e <_ZN9FatVolume4initEh+0xe8>
      fbs->reservedSectorCount == 0) {
    // not valid FAT volume
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_blocksPerCluster = fbs->sectorsPerCluster;
 80a25fe:	7b41      	ldrb	r1, [r0, #13]
  m_clusterBlockMask = m_blocksPerCluster - 1;
  // determine shift that is same as multiply by m_blocksPerCluster
  m_clusterSizeShift = 0;
 80a2600:	2609      	movs	r6, #9
    // not valid FAT volume
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_blocksPerCluster = fbs->sectorsPerCluster;
  m_clusterBlockMask = m_blocksPerCluster - 1;
 80a2602:	1e4b      	subs	r3, r1, #1
 80a2604:	7163      	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_blocksPerCluster
  m_clusterSizeShift = 0;
 80a2606:	2300      	movs	r3, #0
 80a2608:	71a3      	strb	r3, [r4, #6]
      fbs->reservedSectorCount == 0) {
    // not valid FAT volume
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_blocksPerCluster = fbs->sectorsPerCluster;
 80a260a:	7121      	strb	r1, [r4, #4]
  m_clusterBlockMask = m_blocksPerCluster - 1;
  // determine shift that is same as multiply by m_blocksPerCluster
  m_clusterSizeShift = 0;
  for (tmp = 1; m_blocksPerCluster != tmp; tmp <<= 1, m_clusterSizeShift++) {
 80a260c:	2301      	movs	r3, #1
 80a260e:	428b      	cmp	r3, r1
 80a2610:	d007      	beq.n	80a2622 <_ZN9FatVolume4initEh+0x9c>
    if (tmp == 0) {
 80a2612:	3e01      	subs	r6, #1
 80a2614:	d02b      	beq.n	80a266e <_ZN9FatVolume4initEh+0xe8>
  }
  m_blocksPerCluster = fbs->sectorsPerCluster;
  m_clusterBlockMask = m_blocksPerCluster - 1;
  // determine shift that is same as multiply by m_blocksPerCluster
  m_clusterSizeShift = 0;
  for (tmp = 1; m_blocksPerCluster != tmp; tmp <<= 1, m_clusterSizeShift++) {
 80a2616:	79a2      	ldrb	r2, [r4, #6]
 80a2618:	005b      	lsls	r3, r3, #1
 80a261a:	3201      	adds	r2, #1
 80a261c:	b2db      	uxtb	r3, r3
 80a261e:	71a2      	strb	r2, [r4, #6]
 80a2620:	e7f5      	b.n	80a260e <_ZN9FatVolume4initEh+0x88>
    if (tmp == 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_blocksPerFat = fbs->sectorsPerFat16 ?
 80a2622:	8ac2      	ldrh	r2, [r0, #22]
                   fbs->sectorsPerFat16 : fbs->sectorsPerFat32;
 80a2624:	b902      	cbnz	r2, 80a2628 <_ZN9FatVolume4initEh+0xa2>
 80a2626:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80a2628:	6122      	str	r2, [r4, #16]

  m_fatStartBlock = volumeStartBlock + fbs->reservedSectorCount;
 80a262a:	89c6      	ldrh	r6, [r0, #14]
 80a262c:	442e      	add	r6, r5
 80a262e:	61a6      	str	r6, [r4, #24]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = fbs->rootDirEntryCount;
 80a2630:	f8b0 3011 	ldrh.w	r3, [r0, #17]

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartBlock + 2 * m_blocksPerFat;
 80a2634:	eb06 0142 	add.w	r1, r6, r2, lsl #1
                   fbs->sectorsPerFat16 : fbs->sectorsPerFat32;

  m_fatStartBlock = volumeStartBlock + fbs->reservedSectorCount;

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = fbs->rootDirEntryCount;
 80a2638:	8123      	strh	r3, [r4, #8]

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartBlock + 2 * m_blocksPerFat;
 80a263a:	6221      	str	r1, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartBlock = m_rootDirStart + ((32 * fbs->rootDirEntryCount + 511)/512);
 80a263c:	f8b0 2011 	ldrh.w	r2, [r0, #17]
 80a2640:	0152      	lsls	r2, r2, #5
 80a2642:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
 80a2646:	eb01 2262 	add.w	r2, r1, r2, asr #9
 80a264a:	6162      	str	r2, [r4, #20]

  // total blocks for FAT16 or FAT32
  totalBlocks = fbs->totalSectors16 ?
 80a264c:	f8b0 3013 	ldrh.w	r3, [r0, #19]
                fbs->totalSectors16 : fbs->totalSectors32;
 80a2650:	b903      	cbnz	r3, 80a2654 <_ZN9FatVolume4initEh+0xce>
 80a2652:	6a03      	ldr	r3, [r0, #32]
  // total data blocks
  clusterCount = totalBlocks - (m_dataStartBlock - volumeStartBlock);
 80a2654:	1aad      	subs	r5, r5, r2
 80a2656:	442b      	add	r3, r5

  // divide by cluster size to get cluster count
  clusterCount >>= m_clusterSizeShift;
 80a2658:	79a5      	ldrb	r5, [r4, #6]
 80a265a:	fa23 f505 	lsr.w	r5, r3, r5
  m_lastCluster = clusterCount + 1;
 80a265e:	1c6b      	adds	r3, r5, #1
 80a2660:	61e3      	str	r3, [r4, #28]

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
 80a2662:	f640 73f4 	movw	r3, #4084	; 0xff4
 80a2666:	429d      	cmp	r5, r3
 80a2668:	d803      	bhi.n	80a2672 <_ZN9FatVolume4initEh+0xec>
    m_fatType = 12;
 80a266a:	230c      	movs	r3, #12
 80a266c:	71e3      	strb	r3, [r4, #7]
    m_fatType = 32;
  }
  return true;

fail:
  return false;
 80a266e:	2000      	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
 80a2670:	bd70      	pop	{r4, r5, r6, pc}
    }
  } else if (clusterCount < 65525) {
 80a2672:	f64f 73f4 	movw	r3, #65524	; 0xfff4
 80a2676:	429d      	cmp	r5, r3
    m_fatType = 16;
  } else {
    m_rootDirStart = fbs->fat32RootCluster;
 80a2678:	bf89      	itett	hi
 80a267a:	6ac3      	ldrhi	r3, [r0, #44]	; 0x2c
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
 80a267c:	2310      	movls	r3, #16
  } else {
    m_rootDirStart = fbs->fat32RootCluster;
 80a267e:	6223      	strhi	r3, [r4, #32]
    m_fatType = 32;
 80a2680:	2320      	movhi	r3, #32
 80a2682:	71e3      	strb	r3, [r4, #7]
  }
  return true;
 80a2684:	2001      	movs	r0, #1

fail:
  return false;
}
 80a2686:	bd70      	pop	{r4, r5, r6, pc}

080a2688 <_GLOBAL__sub_I__ZN8FatCache4readEmh>:
 80a2688:	f000 bc78 	b.w	80a2f7c <HAL_Pin_Map>

080a268c <_GLOBAL__sub_I__ZN10SdioCardEX9readBlockEmPh>:
 80a268c:	f000 bc76 	b.w	80a2f7c <HAL_Pin_Map>

080a2690 <_GLOBAL__sub_I__ZN11SdSpiCardEX9readBlockEmPh>:
 80a2690:	f000 bc74 	b.w	80a2f7c <HAL_Pin_Map>

080a2694 <_ZN9SdSpiCard10isTimedOutEtt>:
    spiStop();
  }
  return rtn;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isTimedOut(uint16_t startMS, uint16_t timeoutMS) {
 80a2694:	b570      	push	{r4, r5, r6, lr}
 80a2696:	460e      	mov	r6, r1
 80a2698:	4615      	mov	r5, r2
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a269a:	f000 fcef 	bl	80a307c <HAL_Timer_Get_Micro_Seconds>
#if WDT_YIELD_TIME_MICROS
  static uint32_t last;
  if ((micros() - last) > WDT_YIELD_TIME_MICROS) {
 80a269e:	4c0c      	ldr	r4, [pc, #48]	; (80a26d0 <_ZN9SdSpiCard10isTimedOutEtt+0x3c>)
 80a26a0:	6823      	ldr	r3, [r4, #0]
 80a26a2:	1ac0      	subs	r0, r0, r3
 80a26a4:	4b0b      	ldr	r3, [pc, #44]	; (80a26d4 <_ZN9SdSpiCard10isTimedOutEtt+0x40>)
 80a26a6:	4298      	cmp	r0, r3
 80a26a8:	d908      	bls.n	80a26bc <_ZN9SdSpiCard10isTimedOutEtt+0x28>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a26aa:	f000 fcef 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a26ae:	4b0a      	ldr	r3, [pc, #40]	; (80a26d8 <_ZN9SdSpiCard10isTimedOutEtt+0x44>)
 80a26b0:	6018      	str	r0, [r3, #0]
        spark_cloud_flag_connect();
    }
    static void disconnect(void) { spark_cloud_flag_disconnect(); }
    static void process(void) {
    		application_checkin();
    		spark_process();
 80a26b2:	f000 fe69 	bl	80a3388 <spark_process>
 80a26b6:	f000 fce1 	bl	80a307c <HAL_Timer_Get_Micro_Seconds>
    SysCall::yield();
    last = micros();
 80a26ba:	6020      	str	r0, [r4, #0]
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a26bc:	f000 fce6 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
  }
#endif  // WDT_YIELD_TIME_MICROS
  return (curTimeMS() - startMS) > timeoutMS;
 80a26c0:	b280      	uxth	r0, r0
 80a26c2:	1b80      	subs	r0, r0, r6
}
 80a26c4:	42a8      	cmp	r0, r5
 80a26c6:	bfd4      	ite	le
 80a26c8:	2000      	movle	r0, #0
 80a26ca:	2001      	movgt	r0, #1
 80a26cc:	bd70      	pop	{r4, r5, r6, pc}
 80a26ce:	bf00      	nop
 80a26d0:	20000afc 	.word	0x20000afc
 80a26d4:	000186a0 	.word	0x000186a0
 80a26d8:	20000ff4 	.word	0x20000ff4

080a26dc <_ZN9SdSpiCard8spiStartEv>:
fail:
  spiStop();
  return false;
}
//-----------------------------------------------------------------------------
void SdSpiCard::spiStart() {
 80a26dc:	b538      	push	{r3, r4, r5, lr}
  if (!m_spiActive) {
 80a26de:	7a05      	ldrb	r5, [r0, #8]
fail:
  spiStop();
  return false;
}
//-----------------------------------------------------------------------------
void SdSpiCard::spiStart() {
 80a26e0:	4604      	mov	r4, r0
  if (!m_spiActive) {
 80a26e2:	b94d      	cbnz	r5, 80a26f8 <_ZN9SdSpiCard8spiStartEv+0x1c>
  bool writeData(uint8_t token, const uint8_t* src);

  //---------------------------------------------------------------------------
  // functions defined in SdSpiDriver.h
  void spiActivate() {
    m_spiDriver->activate();
 80a26e4:	6840      	ldr	r0, [r0, #4]
 80a26e6:	f000 fa7d 	bl	80a2be4 <_ZN14SdSpiAltDriver8activateEv>
 80a26ea:	6863      	ldr	r3, [r4, #4]
   * \param[in] n Number of bytes to send.
   */
  void send(const uint8_t* buf, size_t n);
  /** Set CS low. */
  void select() {
     digitalWrite(m_csPin, LOW);
 80a26ec:	4629      	mov	r1, r5
 80a26ee:	7d18      	ldrb	r0, [r3, #20]
 80a26f0:	f001 fc5b 	bl	80a3faa <digitalWrite>
    spiActivate();
    spiSelect();
    m_spiActive = true;
 80a26f4:	2301      	movs	r3, #1
 80a26f6:	7223      	strb	r3, [r4, #8]
 80a26f8:	bd38      	pop	{r3, r4, r5, pc}

080a26fa <_ZN9SdSpiCard7spiStopEv>:
  }
}
//-----------------------------------------------------------------------------
void SdSpiCard::spiStop() {
 80a26fa:	b510      	push	{r4, lr}
  if (m_spiActive) {
 80a26fc:	7a03      	ldrb	r3, [r0, #8]
    spiSelect();
    m_spiActive = true;
  }
}
//-----------------------------------------------------------------------------
void SdSpiCard::spiStop() {
 80a26fe:	4604      	mov	r4, r0
  if (m_spiActive) {
 80a2700:	b16b      	cbz	r3, 80a271e <_ZN9SdSpiCard7spiStopEv+0x24>
 80a2702:	6843      	ldr	r3, [r0, #4]
  void setSpiSettings(SPISettings spiSettings) {
    m_spiSettings = spiSettings;
  }
  /** Set CS high. */
  void unselect() {
    digitalWrite(m_csPin, HIGH);
 80a2704:	2101      	movs	r1, #1
 80a2706:	7d18      	ldrb	r0, [r3, #20]
 80a2708:	f001 fc4f 	bl	80a3faa <digitalWrite>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver->receive(buf, n);
  }
  void spiSend(uint8_t data) {
     m_spiDriver->send(data);
 80a270c:	21ff      	movs	r1, #255	; 0xff
 80a270e:	6860      	ldr	r0, [r4, #4]
 80a2710:	f000 fa9a 	bl	80a2c48 <_ZN14SdSpiAltDriver4sendEh>
  // functions defined in SdSpiDriver.h
  void spiActivate() {
    m_spiDriver->activate();
  }
  void spiDeactivate() {
    m_spiDriver->deactivate();
 80a2714:	6860      	ldr	r0, [r4, #4]
 80a2716:	f000 fa79 	bl	80a2c0c <_ZN14SdSpiAltDriver10deactivateEv>
    spiUnselect();
    spiSend(0XFF);
    spiDeactivate();
    m_spiActive = false;
 80a271a:	2300      	movs	r3, #0
 80a271c:	7223      	strb	r3, [r4, #8]
 80a271e:	bd10      	pop	{r4, pc}

080a2720 <_ZN9SdSpiCard8readDataEPhj>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t *dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
 80a2720:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2722:	4604      	mov	r4, r0
 80a2724:	460d      	mov	r5, r1
 80a2726:	4616      	mov	r6, r2
 80a2728:	f000 fcb0 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
#define F(str) (str)
#endif  // F
//------------------------------------------------------------------------------
/** \return the time in milliseconds. */
inline uint16_t curTimeMS() {
  return millis();
 80a272c:	b287      	uxth	r7, r0
  }
  uint8_t spiReceive() {
    return m_spiDriver->receive();
 80a272e:	6860      	ldr	r0, [r4, #4]
 80a2730:	f000 fa6f 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
  uint16_t crc;
#endif  // USE_SD_CRC
  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start block token
  uint16_t t0 = curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
 80a2734:	28ff      	cmp	r0, #255	; 0xff
 80a2736:	7260      	strb	r0, [r4, #9]
 80a2738:	d109      	bne.n	80a274e <_ZN9SdSpiCard8readDataEPhj+0x2e>
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
 80a273a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a273e:	4639      	mov	r1, r7
 80a2740:	4620      	mov	r0, r4
 80a2742:	f7ff ffa7 	bl	80a2694 <_ZN9SdSpiCard10isTimedOutEtt>
 80a2746:	2800      	cmp	r0, #0
 80a2748:	d0f1      	beq.n	80a272e <_ZN9SdSpiCard8readDataEPhj+0xe>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
 80a274a:	2355      	movs	r3, #85	; 0x55
 80a274c:	e00b      	b.n	80a2766 <_ZN9SdSpiCard8readDataEPhj+0x46>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_BLOCK) {
 80a274e:	28fe      	cmp	r0, #254	; 0xfe
 80a2750:	d001      	beq.n	80a2756 <_ZN9SdSpiCard8readDataEPhj+0x36>
 80a2752:	2350      	movs	r3, #80	; 0x50
 80a2754:	e007      	b.n	80a2766 <_ZN9SdSpiCard8readDataEPhj+0x46>
  }
  uint8_t spiReceive() {
    return m_spiDriver->receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver->receive(buf, n);
 80a2756:	4632      	mov	r2, r6
 80a2758:	4629      	mov	r1, r5
 80a275a:	6860      	ldr	r0, [r4, #4]
 80a275c:	f000 fa5e 	bl	80a2c1c <_ZN14SdSpiAltDriver7receiveEPhj>
    error(SD_CARD_ERROR_READ);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
 80a2760:	7260      	strb	r0, [r4, #9]
 80a2762:	b130      	cbz	r0, 80a2772 <_ZN9SdSpiCard8readDataEPhj+0x52>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
 80a2764:	2360      	movs	r3, #96	; 0x60
  spiReceive();
#endif  // USE_SD_CRC
  return true;

fail:
  spiStop();
 80a2766:	4620      	mov	r0, r4
 80a2768:	7023      	strb	r3, [r4, #0]
 80a276a:	f7ff ffc6 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a276e:	2000      	movs	r0, #0
}
 80a2770:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }
  void spiDeactivate() {
    m_spiDriver->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver->receive();
 80a2772:	6860      	ldr	r0, [r4, #4]
 80a2774:	f000 fa4d 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
 80a2778:	6860      	ldr	r0, [r4, #4]
 80a277a:	f000 fa4a 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
 80a277e:	2001      	movs	r0, #1
 80a2780:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2782 <_ZN9SdSpiCard11waitNotBusyEt>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(uint16_t timeoutMS) {
 80a2782:	b570      	push	{r4, r5, r6, lr}
 80a2784:	4604      	mov	r4, r0
 80a2786:	460e      	mov	r6, r1
 80a2788:	f000 fc80 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
 80a278c:	b285      	uxth	r5, r0
  uint16_t t0 = curTimeMS();
#if WDT_YIELD_TIME_MICROS
  // Call isTimedOut first to insure yield is called.
  while (!isTimedOut(t0, timeoutMS)) {
 80a278e:	4632      	mov	r2, r6
 80a2790:	4629      	mov	r1, r5
 80a2792:	4620      	mov	r0, r4
 80a2794:	f7ff ff7e 	bl	80a2694 <_ZN9SdSpiCard10isTimedOutEtt>
 80a2798:	b930      	cbnz	r0, 80a27a8 <_ZN9SdSpiCard11waitNotBusyEt+0x26>
 80a279a:	6860      	ldr	r0, [r4, #4]
 80a279c:	f000 fa39 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
    if (spiReceive() == 0XFF) {
 80a27a0:	28ff      	cmp	r0, #255	; 0xff
 80a27a2:	d1f4      	bne.n	80a278e <_ZN9SdSpiCard11waitNotBusyEt+0xc>
      return true;
 80a27a4:	2001      	movs	r0, #1
 80a27a6:	bd70      	pop	{r4, r5, r6, pc}
    }
  }
  return false;
 80a27a8:	2000      	movs	r0, #0
      return false;
    }
  }
  return true;
#endif  // WDT_YIELD_TIME_MICROS
}
 80a27aa:	bd70      	pop	{r4, r5, r6, pc}

080a27ac <_ZN9SdSpiCard11cardCommandEhm>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
 80a27ac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  // select card
  if (!m_spiActive) {
 80a27ae:	7a03      	ldrb	r3, [r0, #8]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
 80a27b0:	4604      	mov	r4, r0
 80a27b2:	460d      	mov	r5, r1
 80a27b4:	9201      	str	r2, [sp, #4]
  // select card
  if (!m_spiActive) {
 80a27b6:	b90b      	cbnz	r3, 80a27bc <_ZN9SdSpiCard11cardCommandEhm+0x10>
    spiStart();
 80a27b8:	f7ff ff90 	bl	80a26dc <_ZN9SdSpiCard8spiStartEv>
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
 80a27bc:	b125      	cbz	r5, 80a27c8 <_ZN9SdSpiCard11cardCommandEhm+0x1c>
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
 80a27be:	f44f 7196 	mov.w	r1, #300	; 0x12c
 80a27c2:	4620      	mov	r0, r4
 80a27c4:	f7ff ffdd 	bl	80a2782 <_ZN9SdSpiCard11waitNotBusyEt>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver->receive(buf, n);
  }
  void spiSend(uint8_t data) {
     m_spiDriver->send(data);
 80a27c8:	f045 0140 	orr.w	r1, r5, #64	; 0x40
 80a27cc:	6860      	ldr	r0, [r4, #4]
 80a27ce:	f000 fa3b 	bl	80a2c48 <_ZN14SdSpiAltDriver4sendEh>
 80a27d2:	f10d 0607 	add.w	r6, sp, #7
 80a27d6:	f10d 0703 	add.w	r7, sp, #3
 80a27da:	f816 1901 	ldrb.w	r1, [r6], #-1
 80a27de:	6860      	ldr	r0, [r4, #4]
 80a27e0:	f000 fa32 	bl	80a2c48 <_ZN14SdSpiAltDriver4sendEh>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t *pa = reinterpret_cast<uint8_t *>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
 80a27e4:	42be      	cmp	r6, r7
 80a27e6:	d1f8      	bne.n	80a27da <_ZN9SdSpiCard11cardCommandEhm+0x2e>
    spiSend(pa[i]);
  }
  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
 80a27e8:	2d00      	cmp	r5, #0
 80a27ea:	bf0c      	ite	eq
 80a27ec:	2195      	moveq	r1, #149	; 0x95
 80a27ee:	2187      	movne	r1, #135	; 0x87
 80a27f0:	6860      	ldr	r0, [r4, #4]
 80a27f2:	f000 fa29 	bl	80a2c48 <_ZN14SdSpiAltDriver4sendEh>
  }
  void spiDeactivate() {
    m_spiDriver->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver->receive();
 80a27f6:	6860      	ldr	r0, [r4, #4]
 80a27f8:	f000 fa0b 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
 80a27fc:	250b      	movs	r5, #11
 80a27fe:	6860      	ldr	r0, [r4, #4]
 80a2800:	f000 fa07 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
 80a2804:	0603      	lsls	r3, r0, #24
 80a2806:	7260      	strb	r0, [r4, #9]
 80a2808:	d503      	bpl.n	80a2812 <_ZN9SdSpiCard11cardCommandEhm+0x66>
 80a280a:	3d01      	subs	r5, #1
 80a280c:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 80a2810:	d1f5      	bne.n	80a27fe <_ZN9SdSpiCard11cardCommandEhm+0x52>
  }
  return m_status;
}
 80a2812:	b003      	add	sp, #12
 80a2814:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a2816 <_ZN9SdSpiCard8cardAcmdEhm>:
  /** Set CS high and deactivate the card. */
  void spiStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
 80a2816:	b570      	push	{r4, r5, r6, lr}
 80a2818:	4604      	mov	r4, r0
 80a281a:	460d      	mov	r5, r1
 80a281c:	4616      	mov	r6, r2
    cardCommand(CMD55, 0);
 80a281e:	2137      	movs	r1, #55	; 0x37
 80a2820:	2200      	movs	r2, #0
 80a2822:	f7ff ffc3 	bl	80a27ac <_ZN9SdSpiCard11cardCommandEhm>
    return cardCommand(cmd, arg);
 80a2826:	4632      	mov	r2, r6
 80a2828:	4629      	mov	r1, r5
 80a282a:	4620      	mov	r0, r4
  }
 80a282c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    return cardCommand(cmd, arg);
 80a2830:	f7ff bfbc 	b.w	80a27ac <_ZN9SdSpiCard11cardCommandEhm>

080a2834 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiDriver* spi, uint8_t csPin, SPISettings settings) {
 80a2834:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_spiActive = false;
 80a2838:	2500      	movs	r5, #0
 80a283a:	7205      	strb	r5, [r0, #8]
  m_errorCode = SD_CARD_ERROR_NONE;
 80a283c:	7005      	strb	r5, [r0, #0]
  m_type = 0;
 80a283e:	7285      	strb	r5, [r0, #10]
  m_spiDriver = spi;
 80a2840:	6041      	str	r1, [r0, #4]
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiDriver* spi, uint8_t csPin, SPISettings settings) {
 80a2842:	4604      	mov	r4, r0
 80a2844:	4690      	mov	r8, r2
 80a2846:	461e      	mov	r6, r3
 80a2848:	f000 fc20 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
  m_type = 0;
  m_spiDriver = spi;
  uint16_t t0 = curTimeMS();
  uint32_t arg;

  m_spiDriver->begin(csPin);
 80a284c:	4641      	mov	r1, r8
 80a284e:	4607      	mov	r7, r0
 80a2850:	6860      	ldr	r0, [r4, #4]
 80a2852:	f000 f9cb 	bl	80a2bec <_ZN14SdSpiAltDriver5beginEh>
  m_spiDriver->setSpiSettings(SD_SCK_HZ(250000));
 80a2856:	6863      	ldr	r3, [r4, #4]
    SPI_CLK_CORE = 72*MHZ,
    SPI_CLK_PHOTON = 60*MHZ
};

namespace particle {
class __SPISettings : public Printable {
 80a2858:	4a4f      	ldr	r2, [pc, #316]	; (80a2998 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x164>)
 80a285a:	f04f 0801 	mov.w	r8, #1
 80a285e:	721d      	strb	r5, [r3, #8]
 80a2860:	60da      	str	r2, [r3, #12]
 80a2862:	745d      	strb	r5, [r3, #17]
 80a2864:	f883 8010 	strb.w	r8, [r3, #16]
  spiStart();
 80a2868:	4620      	mov	r0, r4
 80a286a:	f7ff ff37 	bl	80a26dc <_ZN9SdSpiCard8spiStartEv>
 80a286e:	6863      	ldr	r3, [r4, #4]
 80a2870:	4641      	mov	r1, r8
 80a2872:	7d18      	ldrb	r0, [r3, #20]
 80a2874:	f001 fb99 	bl	80a3faa <digitalWrite>
 80a2878:	250a      	movs	r5, #10
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver->receive(buf, n);
  }
  void spiSend(uint8_t data) {
     m_spiDriver->send(data);
 80a287a:	21ff      	movs	r1, #255	; 0xff
 80a287c:	6860      	ldr	r0, [r4, #4]
 80a287e:	3d01      	subs	r5, #1
 80a2880:	f000 f9e2 	bl	80a2c48 <_ZN14SdSpiAltDriver4sendEh>

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
 80a2884:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 80a2888:	d1f7      	bne.n	80a287a <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x46>
 80a288a:	6863      	ldr	r3, [r4, #4]
   * \param[in] n Number of bytes to send.
   */
  void send(const uint8_t* buf, size_t n);
  /** Set CS low. */
  void select() {
     digitalWrite(m_csPin, LOW);
 80a288c:	4629      	mov	r1, r5
 80a288e:	7d18      	ldrb	r0, [r3, #20]
 80a2890:	f001 fb8b 	bl	80a3faa <digitalWrite>
 80a2894:	250a      	movs	r5, #10

  DBG_BEGIN_TIME(DBG_CMD0_TIME);
  // command to go idle in SPI mode
  for (uint8_t i = 1;; i++) {
    DBG_EVENT_COUNT(DBG_CMD0_COUNT);
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
 80a2896:	2200      	movs	r2, #0
 80a2898:	4611      	mov	r1, r2
 80a289a:	4620      	mov	r0, r4
 80a289c:	f7ff ff86 	bl	80a27ac <_ZN9SdSpiCard11cardCommandEhm>
 80a28a0:	2801      	cmp	r0, #1
 80a28a2:	4680      	mov	r8, r0
 80a28a4:	d012      	beq.n	80a28cc <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x98>
 80a28a6:	3d01      	subs	r5, #1
      break;
    }
    if (i == SD_CMD0_RETRY) {
 80a28a8:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 80a28ac:	d101      	bne.n	80a28b2 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x7e>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
 80a28ae:	2320      	movs	r3, #32
 80a28b0:	e057      	b.n	80a2962 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x12e>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver->receive(buf, n);
  }
  void spiSend(uint8_t data) {
     m_spiDriver->send(data);
 80a28b2:	21fd      	movs	r1, #253	; 0xfd
 80a28b4:	6860      	ldr	r0, [r4, #4]
 80a28b6:	f000 f9c7 	bl	80a2c48 <_ZN14SdSpiAltDriver4sendEh>
 80a28ba:	f44f 7802 	mov.w	r8, #520	; 0x208
  }
  void spiDeactivate() {
    m_spiDriver->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver->receive();
 80a28be:	6860      	ldr	r0, [r4, #4]
 80a28c0:	f000 f9a7 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    // finish block transfer
    for (int i = 0; i < 520; i++) {
 80a28c4:	f1b8 0801 	subs.w	r8, r8, #1
 80a28c8:	d1f9      	bne.n	80a28be <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x8a>
 80a28ca:	e7e4      	b.n	80a2896 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x62>
    error(SD_CARD_ERROR_CMD59);
    goto fail;
  }
#endif  // USE_SD_CRC
  // check SD version
  if (cardCommand(CMD8, 0x1AA) == (R1_ILLEGAL_COMMAND | R1_IDLE_STATE)) {
 80a28cc:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 80a28d0:	2108      	movs	r1, #8
 80a28d2:	4620      	mov	r0, r4
 80a28d4:	f7ff ff6a 	bl	80a27ac <_ZN9SdSpiCard11cardCommandEhm>
 80a28d8:	2805      	cmp	r0, #5
 80a28da:	d102      	bne.n	80a28e2 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0xae>
  bool isTimedOut(uint16_t startMS, uint16_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);

  void type(uint8_t value) {
    m_type = value;
 80a28dc:	f884 800a 	strb.w	r8, [r4, #10]
 80a28e0:	e00f      	b.n	80a2902 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0xce>
 80a28e2:	2504      	movs	r5, #4
  }
  void spiDeactivate() {
    m_spiDriver->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver->receive();
 80a28e4:	6860      	ldr	r0, [r4, #4]
 80a28e6:	f000 f994 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
 80a28ea:	3d01      	subs	r5, #1
    type(SD_CARD_TYPE_SD1);
  } else {
    for (uint8_t i = 0; i < 4; i++) {
 80a28ec:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
      m_status = spiReceive();
 80a28f0:	7260      	strb	r0, [r4, #9]
#endif  // USE_SD_CRC
  // check SD version
  if (cardCommand(CMD8, 0x1AA) == (R1_ILLEGAL_COMMAND | R1_IDLE_STATE)) {
    type(SD_CARD_TYPE_SD1);
  } else {
    for (uint8_t i = 0; i < 4; i++) {
 80a28f2:	d1f7      	bne.n	80a28e4 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0xb0>
      m_status = spiReceive();
    }
    if (m_status == 0XAA) {
 80a28f4:	28aa      	cmp	r0, #170	; 0xaa
 80a28f6:	d102      	bne.n	80a28fe <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0xca>
  bool isTimedOut(uint16_t startMS, uint16_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);

  void type(uint8_t value) {
    m_type = value;
 80a28f8:	2302      	movs	r3, #2
 80a28fa:	72a3      	strb	r3, [r4, #10]
 80a28fc:	e001      	b.n	80a2902 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0xce>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
 80a28fe:	2325      	movs	r3, #37	; 0x25
 80a2900:	e02f      	b.n	80a2962 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x12e>
      error(SD_CARD_ERROR_CMD8);
      goto fail;
    }
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
 80a2902:	7aa3      	ldrb	r3, [r4, #10]
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
 80a2904:	b2bf      	uxth	r7, r7
      error(SD_CARD_ERROR_CMD8);
      goto fail;
    }
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
 80a2906:	2b02      	cmp	r3, #2
 80a2908:	bf0c      	ite	eq
 80a290a:	f04f 4580 	moveq.w	r5, #1073741824	; 0x40000000
 80a290e:	2500      	movne	r5, #0
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
 80a2910:	462a      	mov	r2, r5
 80a2912:	2129      	movs	r1, #41	; 0x29
 80a2914:	4620      	mov	r0, r4
 80a2916:	f7ff ff7e 	bl	80a2816 <_ZN9SdSpiCard8cardAcmdEhm>
 80a291a:	4602      	mov	r2, r0
 80a291c:	b148      	cbz	r0, 80a2932 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0xfe>
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
 80a291e:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 80a2922:	4639      	mov	r1, r7
 80a2924:	4620      	mov	r0, r4
 80a2926:	f7ff feb5 	bl	80a2694 <_ZN9SdSpiCard10isTimedOutEtt>
 80a292a:	2800      	cmp	r0, #0
 80a292c:	d0f0      	beq.n	80a2910 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0xdc>
 80a292e:	2343      	movs	r3, #67	; 0x43
 80a2930:	e017      	b.n	80a2962 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x12e>
      goto fail;
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);
  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
 80a2932:	7aa3      	ldrb	r3, [r4, #10]
 80a2934:	2b02      	cmp	r3, #2
 80a2936:	d00e      	beq.n	80a2956 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x122>
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    }
  }
  spiStop();
 80a2938:	4620      	mov	r0, r4
 80a293a:	f7ff fede 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  m_spiDriver->setSpiSettings(settings);
 80a293e:	6863      	ldr	r3, [r4, #4]
 80a2940:	68b0      	ldr	r0, [r6, #8]
 80a2942:	7934      	ldrb	r4, [r6, #4]
 80a2944:	7b31      	ldrb	r1, [r6, #12]
 80a2946:	7b72      	ldrb	r2, [r6, #13]
 80a2948:	60d8      	str	r0, [r3, #12]
 80a294a:	721c      	strb	r4, [r3, #8]
 80a294c:	7419      	strb	r1, [r3, #16]
 80a294e:	745a      	strb	r2, [r3, #17]
  return true;
 80a2950:	2001      	movs	r0, #1
 80a2952:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);
  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
 80a2956:	213a      	movs	r1, #58	; 0x3a
 80a2958:	4620      	mov	r0, r4
 80a295a:	f7ff ff27 	bl	80a27ac <_ZN9SdSpiCard11cardCommandEhm>
 80a295e:	b138      	cbz	r0, 80a2970 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x13c>
 80a2960:	2337      	movs	r3, #55	; 0x37
  spiStop();
  m_spiDriver->setSpiSettings(settings);
  return true;

fail:
  spiStop();
 80a2962:	4620      	mov	r0, r4
 80a2964:	7023      	strb	r3, [r4, #0]
 80a2966:	f7ff fec8 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a296a:	2000      	movs	r0, #0
}
 80a296c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  void spiDeactivate() {
    m_spiDriver->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver->receive();
 80a2970:	6860      	ldr	r0, [r4, #4]
 80a2972:	f000 f94e 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
 80a2976:	f000 00c0 	and.w	r0, r0, #192	; 0xc0
 80a297a:	28c0      	cmp	r0, #192	; 0xc0
  bool isTimedOut(uint16_t startMS, uint16_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);

  void type(uint8_t value) {
    m_type = value;
 80a297c:	bf04      	itt	eq
 80a297e:	2303      	moveq	r3, #3
 80a2980:	72a3      	strbeq	r3, [r4, #10]
  }
  void spiDeactivate() {
    m_spiDriver->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver->receive();
 80a2982:	6860      	ldr	r0, [r4, #4]
 80a2984:	f000 f945 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
 80a2988:	6860      	ldr	r0, [r4, #4]
 80a298a:	f000 f942 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
 80a298e:	6860      	ldr	r0, [r4, #4]
 80a2990:	f000 f93f 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
 80a2994:	e7d0      	b.n	80a2938 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE+0x104>
 80a2996:	bf00      	nop
 80a2998:	0003d090 	.word	0x0003d090

080a299c <_ZN9SdSpiCard9readBlockEmPh>:
  }
#endif  // WDT_YIELD_TIME_MICROS
  return (curTimeMS() - startMS) > timeoutMS;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readBlock(uint32_t blockNumber, uint8_t* dst) {
 80a299c:	b538      	push	{r3, r4, r5, lr}
  SD_TRACE("RB", blockNumber);
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
 80a299e:	7a83      	ldrb	r3, [r0, #10]
  }
#endif  // WDT_YIELD_TIME_MICROS
  return (curTimeMS() - startMS) > timeoutMS;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readBlock(uint32_t blockNumber, uint8_t* dst) {
 80a29a0:	4615      	mov	r5, r2
  SD_TRACE("RB", blockNumber);
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
 80a29a2:	2b03      	cmp	r3, #3
    blockNumber <<= 9;
 80a29a4:	bf18      	it	ne
 80a29a6:	0249      	lslne	r1, r1, #9
  }
  if (cardCommand(CMD17, blockNumber)) {
 80a29a8:	460a      	mov	r2, r1
 80a29aa:	2111      	movs	r1, #17
  }
#endif  // WDT_YIELD_TIME_MICROS
  return (curTimeMS() - startMS) > timeoutMS;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readBlock(uint32_t blockNumber, uint8_t* dst) {
 80a29ac:	4604      	mov	r4, r0
  SD_TRACE("RB", blockNumber);
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    blockNumber <<= 9;
  }
  if (cardCommand(CMD17, blockNumber)) {
 80a29ae:	f7ff fefd 	bl	80a27ac <_ZN9SdSpiCard11cardCommandEhm>
 80a29b2:	b110      	cbz	r0, 80a29ba <_ZN9SdSpiCard9readBlockEmPh+0x1e>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
 80a29b4:	2330      	movs	r3, #48	; 0x30
 80a29b6:	7023      	strb	r3, [r4, #0]
 80a29b8:	e00b      	b.n	80a29d2 <_ZN9SdSpiCard9readBlockEmPh+0x36>
    error(SD_CARD_ERROR_CMD17);
    goto fail;
  }
  if (!readData(dst, 512)) {
 80a29ba:	4629      	mov	r1, r5
 80a29bc:	f44f 7200 	mov.w	r2, #512	; 0x200
 80a29c0:	4620      	mov	r0, r4
 80a29c2:	f7ff fead 	bl	80a2720 <_ZN9SdSpiCard8readDataEPhj>
 80a29c6:	4605      	mov	r5, r0
 80a29c8:	b118      	cbz	r0, 80a29d2 <_ZN9SdSpiCard9readBlockEmPh+0x36>
    goto fail;
  }
  spiStop();
 80a29ca:	4620      	mov	r0, r4
 80a29cc:	f7ff fe95 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return true;
 80a29d0:	e003      	b.n	80a29da <_ZN9SdSpiCard9readBlockEmPh+0x3e>

fail:
  spiStop();
 80a29d2:	4620      	mov	r0, r4
 80a29d4:	f7ff fe91 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a29d8:	2500      	movs	r5, #0
}
 80a29da:	4628      	mov	r0, r5
 80a29dc:	bd38      	pop	{r3, r4, r5, pc}

080a29de <_ZN9SdSpiCard9readStartEm>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t blockNumber) {
 80a29de:	b510      	push	{r4, lr}
  SD_TRACE("RS", blockNumber);
  if (type() != SD_CARD_TYPE_SDHC) {
 80a29e0:	7a83      	ldrb	r3, [r0, #10]
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t blockNumber) {
 80a29e2:	460a      	mov	r2, r1
  SD_TRACE("RS", blockNumber);
  if (type() != SD_CARD_TYPE_SDHC) {
 80a29e4:	2b03      	cmp	r3, #3
    blockNumber <<= 9;
 80a29e6:	bf18      	it	ne
 80a29e8:	024a      	lslne	r2, r1, #9
  }
  if (cardCommand(CMD18, blockNumber)) {
 80a29ea:	2112      	movs	r1, #18
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t blockNumber) {
 80a29ec:	4604      	mov	r4, r0
  SD_TRACE("RS", blockNumber);
  if (type() != SD_CARD_TYPE_SDHC) {
    blockNumber <<= 9;
  }
  if (cardCommand(CMD18, blockNumber)) {
 80a29ee:	f7ff fedd 	bl	80a27ac <_ZN9SdSpiCard11cardCommandEhm>
 80a29f2:	b130      	cbz	r0, 80a2a02 <_ZN9SdSpiCard9readStartEm+0x24>
 80a29f4:	2331      	movs	r3, #49	; 0x31
  }
//  spiStop();
  return true;

fail:
  spiStop();
 80a29f6:	4620      	mov	r0, r4
 80a29f8:	7023      	strb	r3, [r4, #0]
 80a29fa:	f7ff fe7e 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a29fe:	2000      	movs	r0, #0
 80a2a00:	bd10      	pop	{r4, pc}
  if (cardCommand(CMD18, blockNumber)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
//  spiStop();
  return true;
 80a2a02:	2001      	movs	r0, #1

fail:
  spiStop();
  return false;
}
 80a2a04:	bd10      	pop	{r4, pc}

080a2a06 <_ZN9SdSpiCard8readStopEv>:
    spiDeactivate();
    m_spiActive = false;
  }
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
 80a2a06:	b510      	push	{r4, lr}
  if (cardCommand(CMD12, 0)) {
 80a2a08:	2200      	movs	r2, #0
 80a2a0a:	210c      	movs	r1, #12
    spiDeactivate();
    m_spiActive = false;
  }
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
 80a2a0c:	4604      	mov	r4, r0
  if (cardCommand(CMD12, 0)) {
 80a2a0e:	f7ff fecd 	bl	80a27ac <_ZN9SdSpiCard11cardCommandEhm>
 80a2a12:	b130      	cbz	r0, 80a2a22 <_ZN9SdSpiCard8readStopEv+0x1c>
 80a2a14:	2328      	movs	r3, #40	; 0x28
  }
  spiStop();
  return true;

fail:
  spiStop();
 80a2a16:	4620      	mov	r0, r4
 80a2a18:	7023      	strb	r3, [r4, #0]
 80a2a1a:	f7ff fe6e 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2a1e:	2000      	movs	r0, #0
 80a2a20:	bd10      	pop	{r4, pc}
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
 80a2a22:	4620      	mov	r0, r4
 80a2a24:	f7ff fe69 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return true;
 80a2a28:	2001      	movs	r0, #1

fail:
  spiStop();
  return false;
}
 80a2a2a:	bd10      	pop	{r4, pc}

080a2a2c <_ZN9SdSpiCard10readBlocksEmPhj>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readBlocks(uint32_t block, uint8_t* dst, size_t count) {
 80a2a2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2a2e:	4605      	mov	r5, r0
 80a2a30:	4616      	mov	r6, r2
 80a2a32:	461f      	mov	r7, r3
  if (!readStart(block)) {
 80a2a34:	f7ff ffd3 	bl	80a29de <_ZN9SdSpiCard9readStartEm>
 80a2a38:	b198      	cbz	r0, 80a2a62 <_ZN9SdSpiCard10readBlocksEmPhj+0x36>
 80a2a3a:	2400      	movs	r4, #0
 80a2a3c:	b2a3      	uxth	r3, r4
    return false;
  }
  for (uint16_t b = 0; b < count; b++, dst += 512) {
 80a2a3e:	429f      	cmp	r7, r3
 80a2a40:	eb06 2144 	add.w	r1, r6, r4, lsl #9
 80a2a44:	d908      	bls.n	80a2a58 <_ZN9SdSpiCard10readBlocksEmPhj+0x2c>
    if (!readData(dst, 512)) {
 80a2a46:	f44f 7200 	mov.w	r2, #512	; 0x200
 80a2a4a:	4628      	mov	r0, r5
 80a2a4c:	f7ff fe68 	bl	80a2720 <_ZN9SdSpiCard8readDataEPhj>
 80a2a50:	3401      	adds	r4, #1
 80a2a52:	2800      	cmp	r0, #0
 80a2a54:	d1f2      	bne.n	80a2a3c <_ZN9SdSpiCard10readBlocksEmPhj+0x10>
 80a2a56:	e004      	b.n	80a2a62 <_ZN9SdSpiCard10readBlocksEmPhj+0x36>
      return false;
    }
  }
  return readStop();
 80a2a58:	4628      	mov	r0, r5
}
 80a2a5a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  for (uint16_t b = 0; b < count; b++, dst += 512) {
    if (!readData(dst, 512)) {
      return false;
    }
  }
  return readStop();
 80a2a5e:	f7ff bfd2 	b.w	80a2a06 <_ZN9SdSpiCard8readStopEv>
}
 80a2a62:	2000      	movs	r0, #0
 80a2a64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2a66 <_ZN9SdSpiCard9writeDataEhPKh>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
 80a2a66:	b538      	push	{r3, r4, r5, lr}
 80a2a68:	4604      	mov	r4, r0
 80a2a6a:	4615      	mov	r5, r2
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver->receive(buf, n);
  }
  void spiSend(uint8_t data) {
     m_spiDriver->send(data);
 80a2a6c:	6840      	ldr	r0, [r0, #4]
 80a2a6e:	f000 f8eb 	bl	80a2c48 <_ZN14SdSpiAltDriver4sendEh>
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriver->send(buf, n);
 80a2a72:	f44f 7200 	mov.w	r2, #512	; 0x200
 80a2a76:	4629      	mov	r1, r5
 80a2a78:	6860      	ldr	r0, [r4, #4]
 80a2a7a:	f000 f8e9 	bl	80a2c50 <_ZN14SdSpiAltDriver4sendEPKhj>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver->receive(buf, n);
  }
  void spiSend(uint8_t data) {
     m_spiDriver->send(data);
 80a2a7e:	21ff      	movs	r1, #255	; 0xff
 80a2a80:	6860      	ldr	r0, [r4, #4]
 80a2a82:	f000 f8e1 	bl	80a2c48 <_ZN14SdSpiAltDriver4sendEh>
 80a2a86:	21ff      	movs	r1, #255	; 0xff
 80a2a88:	6860      	ldr	r0, [r4, #4]
 80a2a8a:	f000 f8dd 	bl	80a2c48 <_ZN14SdSpiAltDriver4sendEh>
  }
  void spiDeactivate() {
    m_spiDriver->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver->receive();
 80a2a8e:	6860      	ldr	r0, [r4, #4]
 80a2a90:	f000 f8bf 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
  spiSend(token);
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
 80a2a94:	7260      	strb	r0, [r4, #9]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
 80a2a96:	f000 001f 	and.w	r0, r0, #31
 80a2a9a:	2805      	cmp	r0, #5
 80a2a9c:	d006      	beq.n	80a2aac <_ZN9SdSpiCard9writeDataEhPKh+0x46>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
 80a2a9e:	2357      	movs	r3, #87	; 0x57
    goto fail;
  }
  return true;

fail:
  spiStop();
 80a2aa0:	4620      	mov	r0, r4
 80a2aa2:	7023      	strb	r3, [r4, #0]
 80a2aa4:	f7ff fe29 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2aa8:	2000      	movs	r0, #0
 80a2aaa:	bd38      	pop	{r3, r4, r5, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE);
    goto fail;
  }
  return true;
 80a2aac:	2001      	movs	r0, #1

fail:
  spiStop();
  return false;
}
 80a2aae:	bd38      	pop	{r3, r4, r5, pc}

080a2ab0 <_ZN9SdSpiCard10writeBlockEmPKh>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MICROS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlock(uint32_t blockNumber, const uint8_t* src) {
 80a2ab0:	b570      	push	{r4, r5, r6, lr}
  SD_TRACE("WB", blockNumber);
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
 80a2ab2:	7a83      	ldrb	r3, [r0, #10]
  }
  return true;
#endif  // WDT_YIELD_TIME_MICROS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlock(uint32_t blockNumber, const uint8_t* src) {
 80a2ab4:	4615      	mov	r5, r2
  SD_TRACE("WB", blockNumber);
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
 80a2ab6:	2b03      	cmp	r3, #3
    blockNumber <<= 9;
 80a2ab8:	bf18      	it	ne
 80a2aba:	0249      	lslne	r1, r1, #9
  }
  if (cardCommand(CMD24, blockNumber)) {
 80a2abc:	460a      	mov	r2, r1
 80a2abe:	2118      	movs	r1, #24
  }
  return true;
#endif  // WDT_YIELD_TIME_MICROS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlock(uint32_t blockNumber, const uint8_t* src) {
 80a2ac0:	4604      	mov	r4, r0
  SD_TRACE("WB", blockNumber);
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    blockNumber <<= 9;
  }
  if (cardCommand(CMD24, blockNumber)) {
 80a2ac2:	f7ff fe73 	bl	80a27ac <_ZN9SdSpiCard11cardCommandEhm>
 80a2ac6:	4606      	mov	r6, r0
 80a2ac8:	b108      	cbz	r0, 80a2ace <_ZN9SdSpiCard10writeBlockEmPKh+0x1e>
 80a2aca:	2332      	movs	r3, #50	; 0x32
 80a2acc:	e01d      	b.n	80a2b0a <_ZN9SdSpiCard10writeBlockEmPKh+0x5a>
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_BLOCK, src)) {
 80a2ace:	462a      	mov	r2, r5
 80a2ad0:	21fe      	movs	r1, #254	; 0xfe
 80a2ad2:	4620      	mov	r0, r4
 80a2ad4:	f7ff ffc7 	bl	80a2a66 <_ZN9SdSpiCard9writeDataEhPKh>
 80a2ad8:	b1c0      	cbz	r0, 80a2b0c <_ZN9SdSpiCard10writeBlockEmPKh+0x5c>


#if CHECK_FLASH_PROGRAMMING
  // wait for flash programming to complete
  DBG_BEGIN_TIME(DBG_WRITE_FLASH);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
 80a2ada:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80a2ade:	4620      	mov	r0, r4
 80a2ae0:	f7ff fe4f 	bl	80a2782 <_ZN9SdSpiCard11waitNotBusyEt>
 80a2ae4:	4605      	mov	r5, r0
 80a2ae6:	b908      	cbnz	r0, 80a2aec <_ZN9SdSpiCard10writeBlockEmPKh+0x3c>
 80a2ae8:	235a      	movs	r3, #90	; 0x5a
 80a2aea:	e00e      	b.n	80a2b0a <_ZN9SdSpiCard10writeBlockEmPKh+0x5a>
    error(SD_CARD_ERROR_FLASH_PROGRAMMING);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_FLASH);
  // response is r2 so get and check two bytes for nonzero
  if (cardCommand(CMD13, 0) || spiReceive()) {
 80a2aec:	4632      	mov	r2, r6
 80a2aee:	210d      	movs	r1, #13
 80a2af0:	4620      	mov	r0, r4
 80a2af2:	f7ff fe5b 	bl	80a27ac <_ZN9SdSpiCard11cardCommandEhm>
 80a2af6:	b938      	cbnz	r0, 80a2b08 <_ZN9SdSpiCard10writeBlockEmPKh+0x58>
  }
  void spiDeactivate() {
    m_spiDriver->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver->receive();
 80a2af8:	6860      	ldr	r0, [r4, #4]
 80a2afa:	f000 f88a 	bl	80a2c12 <_ZN14SdSpiAltDriver7receiveEv>
 80a2afe:	b918      	cbnz	r0, 80a2b08 <_ZN9SdSpiCard10writeBlockEmPKh+0x58>
    error(SD_CARD_ERROR_CMD13);
    goto fail;
  }
#endif  // CHECK_PROGRAMMING

  spiStop();
 80a2b00:	4620      	mov	r0, r4
 80a2b02:	f7ff fdfa 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return true;
 80a2b06:	e005      	b.n	80a2b14 <_ZN9SdSpiCard10writeBlockEmPKh+0x64>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
 80a2b08:	2329      	movs	r3, #41	; 0x29
 80a2b0a:	7023      	strb	r3, [r4, #0]

fail:
  spiStop();
 80a2b0c:	4620      	mov	r0, r4
 80a2b0e:	f7ff fdf4 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2b12:	2500      	movs	r5, #0
}
 80a2b14:	4628      	mov	r0, r5
 80a2b16:	bd70      	pop	{r4, r5, r6, pc}

080a2b18 <_ZN9SdSpiCard9writeDataEPKh>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
 80a2b18:	b538      	push	{r3, r4, r5, lr}
 80a2b1a:	460d      	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
 80a2b1c:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
 80a2b20:	4604      	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
 80a2b22:	f7ff fe2e 	bl	80a2782 <_ZN9SdSpiCard11waitNotBusyEt>
 80a2b26:	b910      	cbnz	r0, 80a2b2e <_ZN9SdSpiCard9writeDataEPKh+0x16>
 80a2b28:	235b      	movs	r3, #91	; 0x5b
 80a2b2a:	7023      	strb	r3, [r4, #0]
 80a2b2c:	e005      	b.n	80a2b3a <_ZN9SdSpiCard9writeDataEPKh+0x22>
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
 80a2b2e:	462a      	mov	r2, r5
 80a2b30:	21fc      	movs	r1, #252	; 0xfc
 80a2b32:	4620      	mov	r0, r4
 80a2b34:	f7ff ff97 	bl	80a2a66 <_ZN9SdSpiCard9writeDataEhPKh>
 80a2b38:	b918      	cbnz	r0, 80a2b42 <_ZN9SdSpiCard9writeDataEPKh+0x2a>
    goto fail;
  }
  return true;

fail:
  spiStop();
 80a2b3a:	4620      	mov	r0, r4
 80a2b3c:	f7ff fddd 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2b40:	2000      	movs	r0, #0
}
 80a2b42:	bd38      	pop	{r3, r4, r5, pc}

080a2b44 <_ZN9SdSpiCard10writeStartEm>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t blockNumber) {
 80a2b44:	b510      	push	{r4, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
 80a2b46:	7a83      	ldrb	r3, [r0, #10]
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t blockNumber) {
 80a2b48:	460a      	mov	r2, r1
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
 80a2b4a:	2b03      	cmp	r3, #3
    blockNumber <<= 9;
 80a2b4c:	bf18      	it	ne
 80a2b4e:	024a      	lslne	r2, r1, #9
  }
  if (cardCommand(CMD25, blockNumber)) {
 80a2b50:	2119      	movs	r1, #25
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t blockNumber) {
 80a2b52:	4604      	mov	r4, r0
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    blockNumber <<= 9;
  }
  if (cardCommand(CMD25, blockNumber)) {
 80a2b54:	f7ff fe2a 	bl	80a27ac <_ZN9SdSpiCard11cardCommandEhm>
 80a2b58:	b130      	cbz	r0, 80a2b68 <_ZN9SdSpiCard10writeStartEm+0x24>
 80a2b5a:	2333      	movs	r3, #51	; 0x33
    goto fail;
  }
  return true;

fail:
  spiStop();
 80a2b5c:	4620      	mov	r0, r4
 80a2b5e:	7023      	strb	r3, [r4, #0]
 80a2b60:	f7ff fdcb 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return false;
 80a2b64:	2000      	movs	r0, #0
 80a2b66:	bd10      	pop	{r4, pc}
  }
  if (cardCommand(CMD25, blockNumber)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
 80a2b68:	2001      	movs	r0, #1

fail:
  spiStop();
  return false;
}
 80a2b6a:	bd10      	pop	{r4, pc}

080a2b6c <_ZN9SdSpiCard9writeStopEv>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
 80a2b6c:	b538      	push	{r3, r4, r5, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
 80a2b6e:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
 80a2b72:	4604      	mov	r4, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
 80a2b74:	f7ff fe05 	bl	80a2782 <_ZN9SdSpiCard11waitNotBusyEt>
 80a2b78:	4605      	mov	r5, r0
 80a2b7a:	b120      	cbz	r0, 80a2b86 <_ZN9SdSpiCard9writeStopEv+0x1a>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver->receive(buf, n);
  }
  void spiSend(uint8_t data) {
     m_spiDriver->send(data);
 80a2b7c:	21fd      	movs	r1, #253	; 0xfd
 80a2b7e:	6860      	ldr	r0, [r4, #4]
 80a2b80:	f000 f862 	bl	80a2c48 <_ZN14SdSpiAltDriver4sendEh>
 80a2b84:	e001      	b.n	80a2b8a <_ZN9SdSpiCard9writeStopEv+0x1e>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
 80a2b86:	2356      	movs	r3, #86	; 0x56
 80a2b88:	7023      	strb	r3, [r4, #0]
  spiStop();
  return true;

fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
 80a2b8a:	4620      	mov	r0, r4
 80a2b8c:	f7ff fdb5 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return false;
}
 80a2b90:	4628      	mov	r0, r5
 80a2b92:	bd38      	pop	{r3, r4, r5, pc}

080a2b94 <_ZN9SdSpiCard11writeBlocksEmPKhj>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlocks(uint32_t block, const uint8_t* src, size_t count) {
 80a2b94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2b96:	4605      	mov	r5, r0
 80a2b98:	4616      	mov	r6, r2
 80a2b9a:	461f      	mov	r7, r3
  if (!writeStart(block)) {
 80a2b9c:	f7ff ffd2 	bl	80a2b44 <_ZN9SdSpiCard10writeStartEm>
 80a2ba0:	b170      	cbz	r0, 80a2bc0 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x2c>
 80a2ba2:	2400      	movs	r4, #0
    goto fail;
  }
  for (size_t b = 0; b < count; b++, src += 512) {
 80a2ba4:	42bc      	cmp	r4, r7
 80a2ba6:	eb06 2144 	add.w	r1, r6, r4, lsl #9
    if (!writeData(src)) {
      goto fail;
    }
  }
  return writeStop();
 80a2baa:	4628      	mov	r0, r5
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlocks(uint32_t block, const uint8_t* src, size_t count) {
  if (!writeStart(block)) {
    goto fail;
  }
  for (size_t b = 0; b < count; b++, src += 512) {
 80a2bac:	d004      	beq.n	80a2bb8 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x24>
    if (!writeData(src)) {
 80a2bae:	f7ff ffb3 	bl	80a2b18 <_ZN9SdSpiCard9writeDataEPKh>
 80a2bb2:	b128      	cbz	r0, 80a2bc0 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x2c>
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlocks(uint32_t block, const uint8_t* src, size_t count) {
  if (!writeStart(block)) {
    goto fail;
  }
  for (size_t b = 0; b < count; b++, src += 512) {
 80a2bb4:	3401      	adds	r4, #1
 80a2bb6:	e7f5      	b.n	80a2ba4 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x10>
  return writeStop();

 fail:
  spiStop();
  return false;
}
 80a2bb8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  for (size_t b = 0; b < count; b++, src += 512) {
    if (!writeData(src)) {
      goto fail;
    }
  }
  return writeStop();
 80a2bbc:	f7ff bfd6 	b.w	80a2b6c <_ZN9SdSpiCard9writeStopEv>

 fail:
  spiStop();
 80a2bc0:	4628      	mov	r0, r5
 80a2bc2:	f7ff fd9a 	bl	80a26fa <_ZN9SdSpiCard7spiStopEv>
  return false;
}
 80a2bc6:	2000      	movs	r0, #0
 80a2bc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2bca <_GLOBAL__sub_I__ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE>:
 80a2bca:	f000 b9d7 	b.w	80a2f7c <HAL_Pin_Map>

080a2bce <_GLOBAL__sub_I_SdSpiSAM3X.cpp>:
 80a2bce:	f000 b9d5 	b.w	80a2f7c <HAL_Pin_Map>

080a2bd2 <_GLOBAL__sub_I_SdSpiTeensy3.cpp>:
 80a2bd2:	f000 b9d3 	b.w	80a2f7c <HAL_Pin_Map>
	...

080a2bd8 <_ZL36SD_SPI_DMA_TransferComplete_Callbackv>:
#if defined(PLATFORM_ID)
#include "SdSpiDriver.h"
static volatile bool SPI_DMA_TransferCompleted = false;
//-----------------------------------------------------------------------------
static void SD_SPI_DMA_TransferComplete_Callback(void) {
    SPI_DMA_TransferCompleted = true;
 80a2bd8:	4b01      	ldr	r3, [pc, #4]	; (80a2be0 <_ZL36SD_SPI_DMA_TransferComplete_Callbackv+0x8>)
 80a2bda:	2201      	movs	r2, #1
 80a2bdc:	701a      	strb	r2, [r3, #0]
 80a2bde:	4770      	bx	lr
 80a2be0:	20000b00 	.word	0x20000b00

080a2be4 <_ZN14SdSpiAltDriver8activateEv>:
/** Set SPI options for access to SD/SDHC cards.
 *
 * \param[in] divisor SCK clock divider relative to the APB1 or APB2 clock.
 */
void SdSpiAltDriver::activate() {
  m_spi->beginTransaction(m_spiSettings);
 80a2be4:	1d01      	adds	r1, r0, #4
 80a2be6:	6800      	ldr	r0, [r0, #0]
 80a2be8:	f000 bc60 	b.w	80a34ac <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>

080a2bec <_ZN14SdSpiAltDriver5beginEh>:
//------------------------------------------------------------------------------
/** Initialize the SPI bus.
 *
 * \param[in] chipSelectPin SD card chip select pin.
 */
void SdSpiAltDriver::begin(uint8_t csPin) {
 80a2bec:	b510      	push	{r4, lr}
 80a2bee:	4604      	mov	r4, r0
  m_csPin = csPin;
 80a2bf0:	7501      	strb	r1, [r0, #20]
  m_spi->begin();
 80a2bf2:	6800      	ldr	r0, [r0, #0]
 80a2bf4:	f000 fc3c 	bl	80a3470 <_ZN8SPIClass5beginEv>
  pinMode(m_csPin, OUTPUT);
 80a2bf8:	7d20      	ldrb	r0, [r4, #20]
 80a2bfa:	2101      	movs	r1, #1
 80a2bfc:	f001 f9c4 	bl	80a3f88 <pinMode>
  digitalWrite(m_csPin, HIGH);
 80a2c00:	7d20      	ldrb	r0, [r4, #20]
 80a2c02:	2101      	movs	r1, #1
}
 80a2c04:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 */
void SdSpiAltDriver::begin(uint8_t csPin) {
  m_csPin = csPin;
  m_spi->begin();
  pinMode(m_csPin, OUTPUT);
  digitalWrite(m_csPin, HIGH);
 80a2c08:	f001 b9cf 	b.w	80a3faa <digitalWrite>

080a2c0c <_ZN14SdSpiAltDriver10deactivateEv>:
//------------------------------------------------------------------------------
/**
 * End SPI transaction.
 */
void SdSpiAltDriver::deactivate() {
  m_spi->endTransaction();
 80a2c0c:	6800      	ldr	r0, [r0, #0]
 80a2c0e:	f000 bc34 	b.w	80a347a <_ZN8SPIClass14endTransactionEv>

080a2c12 <_ZN14SdSpiAltDriver7receiveEv>:
/** Receive a byte.
 *
 * \return The byte.
 */
uint8_t SdSpiAltDriver::receive() {
  return m_spi->transfer(0XFF);
 80a2c12:	21ff      	movs	r1, #255	; 0xff
 80a2c14:	6800      	ldr	r0, [r0, #0]
 80a2c16:	f000 bcb9 	b.w	80a358c <_ZN8SPIClass8transferEh>
	...

080a2c1c <_ZN14SdSpiAltDriver7receiveEPhj>:
 * \param[out] buf Buffer to receive the data.
 * \param[in] n Number of bytes to receive.
 *
 * \return Zero for no error or nonzero error code.
 */
uint8_t SdSpiAltDriver::receive(uint8_t* buf, size_t n) {
 80a2c1c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SPI_DMA_TransferCompleted = false;
  m_spi->transfer(nullptr, buf, n, SD_SPI_DMA_TransferComplete_Callback);
 80a2c1e:	4b08      	ldr	r3, [pc, #32]	; (80a2c40 <_ZN14SdSpiAltDriver7receiveEPhj+0x24>)
 * \param[in] n Number of bytes to receive.
 *
 * \return Zero for no error or nonzero error code.
 */
uint8_t SdSpiAltDriver::receive(uint8_t* buf, size_t n) {
  SPI_DMA_TransferCompleted = false;
 80a2c20:	2500      	movs	r5, #0
  m_spi->transfer(nullptr, buf, n, SD_SPI_DMA_TransferComplete_Callback);
 80a2c22:	9300      	str	r3, [sp, #0]
 * \param[in] n Number of bytes to receive.
 *
 * \return Zero for no error or nonzero error code.
 */
uint8_t SdSpiAltDriver::receive(uint8_t* buf, size_t n) {
  SPI_DMA_TransferCompleted = false;
 80a2c24:	4c07      	ldr	r4, [pc, #28]	; (80a2c44 <_ZN14SdSpiAltDriver7receiveEPhj+0x28>)
  m_spi->transfer(nullptr, buf, n, SD_SPI_DMA_TransferComplete_Callback);
 80a2c26:	4613      	mov	r3, r2
 80a2c28:	6800      	ldr	r0, [r0, #0]
 80a2c2a:	460a      	mov	r2, r1
 80a2c2c:	4629      	mov	r1, r5
 * \param[in] n Number of bytes to receive.
 *
 * \return Zero for no error or nonzero error code.
 */
uint8_t SdSpiAltDriver::receive(uint8_t* buf, size_t n) {
  SPI_DMA_TransferCompleted = false;
 80a2c2e:	7025      	strb	r5, [r4, #0]
  m_spi->transfer(nullptr, buf, n, SD_SPI_DMA_TransferComplete_Callback);
 80a2c30:	f000 fcb2 	bl	80a3598 <_ZN8SPIClass8transferEPvS0_jPFvvE>
  while (!SPI_DMA_TransferCompleted) {}
 80a2c34:	7823      	ldrb	r3, [r4, #0]
 80a2c36:	2b00      	cmp	r3, #0
 80a2c38:	d0fc      	beq.n	80a2c34 <_ZN14SdSpiAltDriver7receiveEPhj+0x18>
  return 0;
}
 80a2c3a:	2000      	movs	r0, #0
 80a2c3c:	b003      	add	sp, #12
 80a2c3e:	bd30      	pop	{r4, r5, pc}
 80a2c40:	080a2bd9 	.word	0x080a2bd9
 80a2c44:	20000b00 	.word	0x20000b00

080a2c48 <_ZN14SdSpiAltDriver4sendEh>:
/** Send a byte.
 *
 * \param[in] b Byte to send
 */
void SdSpiAltDriver::send(uint8_t b) {
  m_spi->transfer(b);
 80a2c48:	6800      	ldr	r0, [r0, #0]
 80a2c4a:	f000 bc9f 	b.w	80a358c <_ZN8SPIClass8transferEh>
	...

080a2c50 <_ZN14SdSpiAltDriver4sendEPKhj>:
/** Send multiple bytes.
 *
 * \param[in] buf Buffer for data to be sent.
 * \param[in] n Number of bytes to send.
 */
void SdSpiAltDriver::send(const uint8_t* buf , size_t n) {
 80a2c50:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SPI_DMA_TransferCompleted = false;

  m_spi->transfer(const_cast<uint8_t*>(buf), nullptr, n,
                            SD_SPI_DMA_TransferComplete_Callback);
 80a2c52:	4b07      	ldr	r3, [pc, #28]	; (80a2c70 <_ZN14SdSpiAltDriver4sendEPKhj+0x20>)
 *
 * \param[in] buf Buffer for data to be sent.
 * \param[in] n Number of bytes to send.
 */
void SdSpiAltDriver::send(const uint8_t* buf , size_t n) {
  SPI_DMA_TransferCompleted = false;
 80a2c54:	2500      	movs	r5, #0

  m_spi->transfer(const_cast<uint8_t*>(buf), nullptr, n,
                            SD_SPI_DMA_TransferComplete_Callback);
 80a2c56:	9300      	str	r3, [sp, #0]
 *
 * \param[in] buf Buffer for data to be sent.
 * \param[in] n Number of bytes to send.
 */
void SdSpiAltDriver::send(const uint8_t* buf , size_t n) {
  SPI_DMA_TransferCompleted = false;
 80a2c58:	4c06      	ldr	r4, [pc, #24]	; (80a2c74 <_ZN14SdSpiAltDriver4sendEPKhj+0x24>)

  m_spi->transfer(const_cast<uint8_t*>(buf), nullptr, n,
                            SD_SPI_DMA_TransferComplete_Callback);
 80a2c5a:	4613      	mov	r3, r2
 80a2c5c:	6800      	ldr	r0, [r0, #0]
 80a2c5e:	462a      	mov	r2, r5
 *
 * \param[in] buf Buffer for data to be sent.
 * \param[in] n Number of bytes to send.
 */
void SdSpiAltDriver::send(const uint8_t* buf , size_t n) {
  SPI_DMA_TransferCompleted = false;
 80a2c60:	7025      	strb	r5, [r4, #0]

  m_spi->transfer(const_cast<uint8_t*>(buf), nullptr, n,
                            SD_SPI_DMA_TransferComplete_Callback);
 80a2c62:	f000 fc99 	bl	80a3598 <_ZN8SPIClass8transferEPvS0_jPFvvE>

  while (!SPI_DMA_TransferCompleted) {}
 80a2c66:	7823      	ldrb	r3, [r4, #0]
 80a2c68:	2b00      	cmp	r3, #0
 80a2c6a:	d0fc      	beq.n	80a2c66 <_ZN14SdSpiAltDriver4sendEPKhj+0x16>
}
 80a2c6c:	b003      	add	sp, #12
 80a2c6e:	bd30      	pop	{r4, r5, pc}
 80a2c70:	080a2bd9 	.word	0x080a2bd9
 80a2c74:	20000b00 	.word	0x20000b00

080a2c78 <_GLOBAL__sub_I__ZN14SdSpiAltDriver8activateEv>:
 80a2c78:	f000 b980 	b.w	80a2f7c <HAL_Pin_Map>

080a2c7c <Wiring_TIM3_Interrupt_Handler_override>:
		IntervalTimer::SIT_CALLBACK[2]();
	}
}
#elif defined(STM32F2XX) && defined(PLATFORM_ID)	//Photon
void Wiring_TIM3_Interrupt_Handler_override()
{
 80a2c7c:	b510      	push	{r4, lr}
	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)
 80a2c7e:	2101      	movs	r1, #1
 80a2c80:	4806      	ldr	r0, [pc, #24]	; (80a2c9c <Wiring_TIM3_Interrupt_Handler_override+0x20>)
 80a2c82:	f7fd fb6e 	bl	80a0362 <TIM_GetITStatus>
 80a2c86:	b140      	cbz	r0, 80a2c9a <Wiring_TIM3_Interrupt_Handler_override+0x1e>
	{
		TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
 80a2c88:	2101      	movs	r1, #1
 80a2c8a:	4804      	ldr	r0, [pc, #16]	; (80a2c9c <Wiring_TIM3_Interrupt_Handler_override+0x20>)
 80a2c8c:	f7fd fb74 	bl	80a0378 <TIM_ClearITPendingBit>
		IntervalTimer::SIT_CALLBACK[0]();
	}
}
 80a2c90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void Wiring_TIM3_Interrupt_Handler_override()
{
	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)
	{
		TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
		IntervalTimer::SIT_CALLBACK[0]();
 80a2c94:	4b02      	ldr	r3, [pc, #8]	; (80a2ca0 <Wiring_TIM3_Interrupt_Handler_override+0x24>)
 80a2c96:	681b      	ldr	r3, [r3, #0]
 80a2c98:	4718      	bx	r3
 80a2c9a:	bd10      	pop	{r4, pc}
 80a2c9c:	40000400 	.word	0x40000400
 80a2ca0:	20000b04 	.word	0x20000b04

080a2ca4 <Wiring_TIM4_Interrupt_Handler_override>:
	}
}

void Wiring_TIM4_Interrupt_Handler_override()
{
 80a2ca4:	b510      	push	{r4, lr}
	if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET)
 80a2ca6:	2101      	movs	r1, #1
 80a2ca8:	4806      	ldr	r0, [pc, #24]	; (80a2cc4 <Wiring_TIM4_Interrupt_Handler_override+0x20>)
 80a2caa:	f7fd fb5a 	bl	80a0362 <TIM_GetITStatus>
 80a2cae:	b140      	cbz	r0, 80a2cc2 <Wiring_TIM4_Interrupt_Handler_override+0x1e>
	{
		TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
 80a2cb0:	2101      	movs	r1, #1
 80a2cb2:	4804      	ldr	r0, [pc, #16]	; (80a2cc4 <Wiring_TIM4_Interrupt_Handler_override+0x20>)
 80a2cb4:	f7fd fb60 	bl	80a0378 <TIM_ClearITPendingBit>
		IntervalTimer::SIT_CALLBACK[1]();
	}
}
 80a2cb8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void Wiring_TIM4_Interrupt_Handler_override()
{
	if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET)
	{
		TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
		IntervalTimer::SIT_CALLBACK[1]();
 80a2cbc:	4b02      	ldr	r3, [pc, #8]	; (80a2cc8 <Wiring_TIM4_Interrupt_Handler_override+0x24>)
 80a2cbe:	685b      	ldr	r3, [r3, #4]
 80a2cc0:	4718      	bx	r3
 80a2cc2:	bd10      	pop	{r4, pc}
 80a2cc4:	40000800 	.word	0x40000800
 80a2cc8:	20000b04 	.word	0x20000b04

080a2ccc <Wiring_TIM5_Interrupt_Handler_override>:
	}
}

void Wiring_TIM5_Interrupt_Handler_override()
{
 80a2ccc:	b510      	push	{r4, lr}
	if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET)
 80a2cce:	2101      	movs	r1, #1
 80a2cd0:	4806      	ldr	r0, [pc, #24]	; (80a2cec <Wiring_TIM5_Interrupt_Handler_override+0x20>)
 80a2cd2:	f7fd fb46 	bl	80a0362 <TIM_GetITStatus>
 80a2cd6:	b140      	cbz	r0, 80a2cea <Wiring_TIM5_Interrupt_Handler_override+0x1e>
	{
		TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
 80a2cd8:	2101      	movs	r1, #1
 80a2cda:	4804      	ldr	r0, [pc, #16]	; (80a2cec <Wiring_TIM5_Interrupt_Handler_override+0x20>)
 80a2cdc:	f7fd fb4c 	bl	80a0378 <TIM_ClearITPendingBit>
		IntervalTimer::SIT_CALLBACK[2]();
	}
}
 80a2ce0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void Wiring_TIM5_Interrupt_Handler_override()
{
	if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET)
	{
		TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
		IntervalTimer::SIT_CALLBACK[2]();
 80a2ce4:	4b02      	ldr	r3, [pc, #8]	; (80a2cf0 <Wiring_TIM5_Interrupt_Handler_override+0x24>)
 80a2ce6:	689b      	ldr	r3, [r3, #8]
 80a2ce8:	4718      	bx	r3
 80a2cea:	bd10      	pop	{r4, pc}
 80a2cec:	40000c00 	.word	0x40000c00
 80a2cf0:	20000b04 	.word	0x20000b04

080a2cf4 <Wiring_TIM6_Interrupt_Handler_override>:
	}
}

void Wiring_TIM6_Interrupt_Handler_override()
{
 80a2cf4:	b510      	push	{r4, lr}
	if (TIM_GetITStatus(TIM6, TIM_IT_Update) != RESET)
 80a2cf6:	2101      	movs	r1, #1
 80a2cf8:	4806      	ldr	r0, [pc, #24]	; (80a2d14 <Wiring_TIM6_Interrupt_Handler_override+0x20>)
 80a2cfa:	f7fd fb32 	bl	80a0362 <TIM_GetITStatus>
 80a2cfe:	b140      	cbz	r0, 80a2d12 <Wiring_TIM6_Interrupt_Handler_override+0x1e>
	{
		TIM_ClearITPendingBit(TIM6, TIM_IT_Update);
 80a2d00:	2101      	movs	r1, #1
 80a2d02:	4804      	ldr	r0, [pc, #16]	; (80a2d14 <Wiring_TIM6_Interrupt_Handler_override+0x20>)
 80a2d04:	f7fd fb38 	bl	80a0378 <TIM_ClearITPendingBit>
		IntervalTimer::SIT_CALLBACK[3]();
	}
}
 80a2d08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void Wiring_TIM6_Interrupt_Handler_override()
{
	if (TIM_GetITStatus(TIM6, TIM_IT_Update) != RESET)
	{
		TIM_ClearITPendingBit(TIM6, TIM_IT_Update);
		IntervalTimer::SIT_CALLBACK[3]();
 80a2d0c:	4b02      	ldr	r3, [pc, #8]	; (80a2d18 <Wiring_TIM6_Interrupt_Handler_override+0x24>)
 80a2d0e:	68db      	ldr	r3, [r3, #12]
 80a2d10:	4718      	bx	r3
 80a2d12:	bd10      	pop	{r4, pc}
 80a2d14:	40001000 	.word	0x40001000
 80a2d18:	20000b04 	.word	0x20000b04

080a2d1c <Wiring_TIM7_Interrupt_Handler_override>:
	}
}

void Wiring_TIM7_Interrupt_Handler_override()
{
 80a2d1c:	b510      	push	{r4, lr}
	if (TIM_GetITStatus(TIM7, TIM_IT_Update) != RESET)
 80a2d1e:	2101      	movs	r1, #1
 80a2d20:	4806      	ldr	r0, [pc, #24]	; (80a2d3c <Wiring_TIM7_Interrupt_Handler_override+0x20>)
 80a2d22:	f7fd fb1e 	bl	80a0362 <TIM_GetITStatus>
 80a2d26:	b140      	cbz	r0, 80a2d3a <Wiring_TIM7_Interrupt_Handler_override+0x1e>
	{
		TIM_ClearITPendingBit(TIM7, TIM_IT_Update);
 80a2d28:	2101      	movs	r1, #1
 80a2d2a:	4804      	ldr	r0, [pc, #16]	; (80a2d3c <Wiring_TIM7_Interrupt_Handler_override+0x20>)
 80a2d2c:	f7fd fb24 	bl	80a0378 <TIM_ClearITPendingBit>
		IntervalTimer::SIT_CALLBACK[4]();
	}
}
 80a2d30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void Wiring_TIM7_Interrupt_Handler_override()
{
	if (TIM_GetITStatus(TIM7, TIM_IT_Update) != RESET)
	{
		TIM_ClearITPendingBit(TIM7, TIM_IT_Update);
		IntervalTimer::SIT_CALLBACK[4]();
 80a2d34:	4b02      	ldr	r3, [pc, #8]	; (80a2d40 <Wiring_TIM7_Interrupt_Handler_override+0x24>)
 80a2d36:	691b      	ldr	r3, [r3, #16]
 80a2d38:	4718      	bx	r3
 80a2d3a:	bd10      	pop	{r4, pc}
 80a2d3c:	40001400 	.word	0x40001400
 80a2d40:	20000b04 	.word	0x20000b04

080a2d44 <_ZN13IntervalTimer9start_SITEmb>:

// ------------------------------------------------------------
// configuters a SIT's TIMER registers, etc and enables
// interrupts, effectively starting the timer upon completion
// ------------------------------------------------------------
void IntervalTimer::start_SIT(intPeriod Period, bool scale) {
 80a2d44:	b5f0      	push	{r4, r5, r6, r7, lr}
    NVIC_InitTypeDef nvicStructure;
	intPeriod prescaler;
	TIM_TypeDef* TIMx;

	//use SIT_id to identify TIM#
	switch (SIT_id) {
 80a2d46:	7a43      	ldrb	r3, [r0, #9]

// ------------------------------------------------------------
// configuters a SIT's TIMER registers, etc and enables
// interrupts, effectively starting the timer upon completion
// ------------------------------------------------------------
void IntervalTimer::start_SIT(intPeriod Period, bool scale) {
 80a2d48:	b085      	sub	sp, #20
 80a2d4a:	4605      	mov	r5, r0
 80a2d4c:	460f      	mov	r7, r1
 80a2d4e:	4616      	mov	r6, r2
    NVIC_InitTypeDef nvicStructure;
	intPeriod prescaler;
	TIM_TypeDef* TIMx;

	//use SIT_id to identify TIM#
	switch (SIT_id) {
 80a2d50:	2b04      	cmp	r3, #4
 80a2d52:	d830      	bhi.n	80a2db6 <_ZN13IntervalTimer9start_SITEmb+0x72>
 80a2d54:	e8df f003 	tbb	[pc, r3]
 80a2d58:	1e150c03 	.word	0x1e150c03
 80a2d5c:	27          	.byte	0x27
 80a2d5d:	00          	.byte	0x00
		nvicStructure.NVIC_IRQChannel = TIM4_IRQn;
		TIMx = TIM4;
		break;
#elif defined(STM32F2XX) && defined(PLATFORM_ID)	//Photon
	case 0:		// TIM3
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
 80a2d5e:	2101      	movs	r1, #1
 80a2d60:	2002      	movs	r0, #2
 80a2d62:	f7fd f9dd 	bl	80a0120 <RCC_APB1PeriphClockCmd>
		nvicStructure.NVIC_IRQChannel = TIM3_IRQn;
 80a2d66:	231d      	movs	r3, #29
 80a2d68:	f88d 3000 	strb.w	r3, [sp]
		TIMx = TIM3;
 80a2d6c:	4c29      	ldr	r4, [pc, #164]	; (80a2e14 <_ZN13IntervalTimer9start_SITEmb+0xd0>)
		break;
 80a2d6e:	e022      	b.n	80a2db6 <_ZN13IntervalTimer9start_SITEmb+0x72>
	case 1:		// TIM4
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
 80a2d70:	2101      	movs	r1, #1
 80a2d72:	2004      	movs	r0, #4
 80a2d74:	f7fd f9d4 	bl	80a0120 <RCC_APB1PeriphClockCmd>
		nvicStructure.NVIC_IRQChannel = TIM4_IRQn;
 80a2d78:	231e      	movs	r3, #30
 80a2d7a:	f88d 3000 	strb.w	r3, [sp]
		TIMx = TIM4;
 80a2d7e:	4c26      	ldr	r4, [pc, #152]	; (80a2e18 <_ZN13IntervalTimer9start_SITEmb+0xd4>)
		break;
 80a2d80:	e019      	b.n	80a2db6 <_ZN13IntervalTimer9start_SITEmb+0x72>
	case 2:		// TIM5
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);
 80a2d82:	2101      	movs	r1, #1
 80a2d84:	2008      	movs	r0, #8
 80a2d86:	f7fd f9cb 	bl	80a0120 <RCC_APB1PeriphClockCmd>
		nvicStructure.NVIC_IRQChannel = TIM5_IRQn;
 80a2d8a:	2332      	movs	r3, #50	; 0x32
 80a2d8c:	f88d 3000 	strb.w	r3, [sp]
		TIMx = TIM5;
 80a2d90:	4c22      	ldr	r4, [pc, #136]	; (80a2e1c <_ZN13IntervalTimer9start_SITEmb+0xd8>)
		break;
 80a2d92:	e010      	b.n	80a2db6 <_ZN13IntervalTimer9start_SITEmb+0x72>
	case 3:		// TIM6
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
 80a2d94:	2101      	movs	r1, #1
 80a2d96:	2010      	movs	r0, #16
 80a2d98:	f7fd f9c2 	bl	80a0120 <RCC_APB1PeriphClockCmd>
		nvicStructure.NVIC_IRQChannel = TIM6_DAC_IRQn;
 80a2d9c:	2336      	movs	r3, #54	; 0x36
 80a2d9e:	f88d 3000 	strb.w	r3, [sp]
		TIMx = TIM6;
 80a2da2:	4c1f      	ldr	r4, [pc, #124]	; (80a2e20 <_ZN13IntervalTimer9start_SITEmb+0xdc>)
		break;
 80a2da4:	e007      	b.n	80a2db6 <_ZN13IntervalTimer9start_SITEmb+0x72>
	case 4:		// TIM7
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);
 80a2da6:	2101      	movs	r1, #1
 80a2da8:	2020      	movs	r0, #32
 80a2daa:	f7fd f9b9 	bl	80a0120 <RCC_APB1PeriphClockCmd>
		nvicStructure.NVIC_IRQChannel = TIM7_IRQn;
		TIMx = TIM7;
 80a2dae:	4c1d      	ldr	r4, [pc, #116]	; (80a2e24 <_ZN13IntervalTimer9start_SITEmb+0xe0>)
		nvicStructure.NVIC_IRQChannel = TIM6_DAC_IRQn;
		TIMx = TIM6;
		break;
	case 4:		// TIM7
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);
		nvicStructure.NVIC_IRQChannel = TIM7_IRQn;
 80a2db0:	2337      	movs	r3, #55	; 0x37
 80a2db2:	f88d 3000 	strb.w	r3, [sp]
		break;
#endif
	}
	
	// Initialize Timer
	switch (scale) {
 80a2db6:	b11e      	cbz	r6, 80a2dc0 <_ZN13IntervalTimer9start_SITEmb+0x7c>
 80a2db8:	2e01      	cmp	r6, #1
 80a2dba:	d101      	bne.n	80a2dc0 <_ZN13IntervalTimer9start_SITEmb+0x7c>
		case uSec:
			prescaler = SIT_PRESCALERu;	// Set prescaler for 1MHz clock, 1us period
			break;
		case hmSec:
			prescaler = SIT_PRESCALERm;	// Set prescaler for 2Hz clock, .5ms period
 80a2dbc:	88ae      	ldrh	r6, [r5, #4]
			break;
 80a2dbe:	e000      	b.n	80a2dc2 <_ZN13IntervalTimer9start_SITEmb+0x7e>
		default:
			prescaler = SIT_PRESCALERu;
 80a2dc0:	886e      	ldrh	r6, [r5, #2]
			scale = uSec;				// Default to microseconds
			break;
	}

	// point to the correct SIT ISR
	SIT_CALLBACK[SIT_id] = myISRcallback;
 80a2dc2:	7a6a      	ldrb	r2, [r5, #9]
 80a2dc4:	68e9      	ldr	r1, [r5, #12]
 80a2dc6:	4b18      	ldr	r3, [pc, #96]	; (80a2e28 <_ZN13IntervalTimer9start_SITEmb+0xe4>)

	// Enable Timer Interrupt
    	nvicStructure.NVIC_IRQChannelPreemptionPriority = 10;
    	nvicStructure.NVIC_IRQChannelSubPriority = 1;
 80a2dc8:	2501      	movs	r5, #1
			scale = uSec;				// Default to microseconds
			break;
	}

	// point to the correct SIT ISR
	SIT_CALLBACK[SIT_id] = myISRcallback;
 80a2dca:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	// Enable Timer Interrupt
    	nvicStructure.NVIC_IRQChannelPreemptionPriority = 10;
    	nvicStructure.NVIC_IRQChannelSubPriority = 1;
    	nvicStructure.NVIC_IRQChannelCmd = ENABLE;
    	NVIC_Init(&nvicStructure);
 80a2dce:	4668      	mov	r0, sp

	// point to the correct SIT ISR
	SIT_CALLBACK[SIT_id] = myISRcallback;

	// Enable Timer Interrupt
    	nvicStructure.NVIC_IRQChannelPreemptionPriority = 10;
 80a2dd0:	230a      	movs	r3, #10
 80a2dd2:	f88d 3001 	strb.w	r3, [sp, #1]
    	nvicStructure.NVIC_IRQChannelSubPriority = 1;
 80a2dd6:	f88d 5002 	strb.w	r5, [sp, #2]
    	nvicStructure.NVIC_IRQChannelCmd = ENABLE;
 80a2dda:	f88d 5003 	strb.w	r5, [sp, #3]
    	NVIC_Init(&nvicStructure);
 80a2dde:	f7fd f969 	bl	80a00b4 <NVIC_Init>
	
	// Timebase configuration
	timerInitStructure.TIM_Prescaler = prescaler;
	timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80a2de2:	2300      	movs	r3, #0
	timerInitStructure.TIM_Period = Period;
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInitStructure.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIMx, &timerInitStructure);
 80a2de4:	a901      	add	r1, sp, #4
 80a2de6:	4620      	mov	r0, r4
    	nvicStructure.NVIC_IRQChannelCmd = ENABLE;
    	NVIC_Init(&nvicStructure);
	
	// Timebase configuration
	timerInitStructure.TIM_Prescaler = prescaler;
	timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80a2de8:	f8ad 3006 	strh.w	r3, [sp, #6]
	timerInitStructure.TIM_Period = Period;
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
 80a2dec:	f8ad 300c 	strh.w	r3, [sp, #12]
	timerInitStructure.TIM_RepetitionCounter = 0;
 80a2df0:	f88d 300e 	strb.w	r3, [sp, #14]
    	nvicStructure.NVIC_IRQChannelSubPriority = 1;
    	nvicStructure.NVIC_IRQChannelCmd = ENABLE;
    	NVIC_Init(&nvicStructure);
	
	// Timebase configuration
	timerInitStructure.TIM_Prescaler = prescaler;
 80a2df4:	f8ad 6004 	strh.w	r6, [sp, #4]
	timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	timerInitStructure.TIM_Period = Period;
 80a2df8:	9702      	str	r7, [sp, #8]
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInitStructure.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIMx, &timerInitStructure);
 80a2dfa:	f7fd fa5f 	bl	80a02bc <TIM_TimeBaseInit>
	TIM_ITConfig(TIMx, TIM_IT_Update, ENABLE);
 80a2dfe:	462a      	mov	r2, r5
 80a2e00:	4629      	mov	r1, r5
 80a2e02:	4620      	mov	r0, r4
 80a2e04:	f7fd faa4 	bl	80a0350 <TIM_ITConfig>
	TIM_Cmd(TIMx, ENABLE);
 80a2e08:	4629      	mov	r1, r5
 80a2e0a:	4620      	mov	r0, r4
 80a2e0c:	f7fd fa94 	bl	80a0338 <TIM_Cmd>
}
 80a2e10:	b005      	add	sp, #20
 80a2e12:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a2e14:	40000400 	.word	0x40000400
 80a2e18:	40000800 	.word	0x40000800
 80a2e1c:	40000c00 	.word	0x40000c00
 80a2e20:	40001000 	.word	0x40001000
 80a2e24:	40001400 	.word	0x40001400
 80a2e28:	20000b04 	.word	0x20000b04

080a2e2c <_ZN13IntervalTimer12allocate_SITEmb5TIMid>:
// it's initialized and started with the specified value, and
// the function returns true, otherwise it returns false
// ------------------------------------------------------------
bool IntervalTimer::allocate_SIT(intPeriod Period, bool scale, TIMid id) {

	if (id < NUM_SIT) {		// Allocate specified timer (id=TIMER3/4/5) or auto-allocate from pool (id=AUTO)
 80a2e2c:	2b04      	cmp	r3, #4
// enables the SIT clock if not already enabled, then checks to
// see if any SITs are available for use. if one is available,
// it's initialized and started with the specified value, and
// the function returns true, otherwise it returns false
// ------------------------------------------------------------
bool IntervalTimer::allocate_SIT(intPeriod Period, bool scale, TIMid id) {
 80a2e2e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2e30:	4606      	mov	r6, r0
 80a2e32:	460f      	mov	r7, r1
 80a2e34:	4696      	mov	lr, r2
 80a2e36:	461c      	mov	r4, r3
 80a2e38:	4d0e      	ldr	r5, [pc, #56]	; (80a2e74 <_ZN13IntervalTimer12allocate_SITEmb5TIMid+0x48>)

	if (id < NUM_SIT) {		// Allocate specified timer (id=TIMER3/4/5) or auto-allocate from pool (id=AUTO)
 80a2e3a:	d911      	bls.n	80a2e60 <_ZN13IntervalTimer12allocate_SITEmb5TIMid+0x34>
 80a2e3c:	2400      	movs	r4, #0
		}
	}
	else {	
		// Auto allocate - check for an available SIT, and if so, start it
		for (uint8_t tid = 0; tid < NUM_SIT; tid++) {
			if (!SIT_used[tid]) {
 80a2e3e:	5d2a      	ldrb	r2, [r5, r4]
 80a2e40:	b2e3      	uxtb	r3, r4
 80a2e42:	b94a      	cbnz	r2, 80a2e58 <_ZN13IntervalTimer12allocate_SITEmb5TIMid+0x2c>
				SIT_id = tid;
 80a2e44:	7273      	strb	r3, [r6, #9]
				start_SIT(Period, scale);
 80a2e46:	4630      	mov	r0, r6
 80a2e48:	4672      	mov	r2, lr
 80a2e4a:	4639      	mov	r1, r7
 80a2e4c:	f7ff ff7a 	bl	80a2d44 <_ZN13IntervalTimer9start_SITEmb>
				SIT_used[tid] = true;
 80a2e50:	4b08      	ldr	r3, [pc, #32]	; (80a2e74 <_ZN13IntervalTimer12allocate_SITEmb5TIMid+0x48>)
 80a2e52:	2001      	movs	r0, #1
 80a2e54:	5518      	strb	r0, [r3, r4]
 80a2e56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a2e58:	3401      	adds	r4, #1
			return true;
		}
	}
	else {	
		// Auto allocate - check for an available SIT, and if so, start it
		for (uint8_t tid = 0; tid < NUM_SIT; tid++) {
 80a2e5a:	2c05      	cmp	r4, #5
 80a2e5c:	d1ef      	bne.n	80a2e3e <_ZN13IntervalTimer12allocate_SITEmb5TIMid+0x12>
 80a2e5e:	e007      	b.n	80a2e70 <_ZN13IntervalTimer12allocate_SITEmb5TIMid+0x44>
// the function returns true, otherwise it returns false
// ------------------------------------------------------------
bool IntervalTimer::allocate_SIT(intPeriod Period, bool scale, TIMid id) {

	if (id < NUM_SIT) {		// Allocate specified timer (id=TIMER3/4/5) or auto-allocate from pool (id=AUTO)
		if (!SIT_used[id]) {
 80a2e60:	5ceb      	ldrb	r3, [r5, r3]
 80a2e62:	b92b      	cbnz	r3, 80a2e70 <_ZN13IntervalTimer12allocate_SITEmb5TIMid+0x44>
			SIT_id = id;
 80a2e64:	7244      	strb	r4, [r0, #9]
			start_SIT(Period, scale);
 80a2e66:	f7ff ff6d 	bl	80a2d44 <_ZN13IntervalTimer9start_SITEmb>
			SIT_used[id] = true;
 80a2e6a:	2001      	movs	r0, #1
 80a2e6c:	5528      	strb	r0, [r5, r4]
			return true;
 80a2e6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			}
		}
	}
	
	// Specified or no auto-allocate SIT available
	return false;
 80a2e70:	2000      	movs	r0, #0
}
 80a2e72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a2e74:	20000b18 	.word	0x20000b18

080a2e78 <_ZN13IntervalTimer8stop_SITEv>:

// ------------------------------------------------------------
// stops an active SIT by disabling its interrupt and TIMER
// and freeing up its state for future use.
// ------------------------------------------------------------
void IntervalTimer::stop_SIT() {
 80a2e78:	b573      	push	{r0, r1, r4, r5, r6, lr}
    NVIC_InitTypeDef nvicStructure;
	TIM_TypeDef* TIMx;


	//use SIT_id to identify TIM#
	switch (SIT_id) {
 80a2e7a:	7a43      	ldrb	r3, [r0, #9]

// ------------------------------------------------------------
// stops an active SIT by disabling its interrupt and TIMER
// and freeing up its state for future use.
// ------------------------------------------------------------
void IntervalTimer::stop_SIT() {
 80a2e7c:	4606      	mov	r6, r0
    NVIC_InitTypeDef nvicStructure;
	TIM_TypeDef* TIMx;


	//use SIT_id to identify TIM#
	switch (SIT_id) {
 80a2e7e:	2b04      	cmp	r3, #4
 80a2e80:	d81c      	bhi.n	80a2ebc <_ZN13IntervalTimer8stop_SITEv+0x44>
 80a2e82:	e8df f003 	tbb	[pc, r3]
 80a2e86:	0803      	.short	0x0803
 80a2e88:	120d      	.short	0x120d
 80a2e8a:	17          	.byte	0x17
 80a2e8b:	00          	.byte	0x00
		nvicStructure.NVIC_IRQChannel = TIM4_IRQn;
		TIMx = TIM4;
		break;
#elif defined(STM32F2XX) && defined(PLATFORM_ID)	//Photon
	case 0:		// TIM3
		nvicStructure.NVIC_IRQChannel = TIM3_IRQn;
 80a2e8c:	231d      	movs	r3, #29
 80a2e8e:	f88d 3004 	strb.w	r3, [sp, #4]
		TIMx = TIM3;
 80a2e92:	4c13      	ldr	r4, [pc, #76]	; (80a2ee0 <_ZN13IntervalTimer8stop_SITEv+0x68>)
		break;
 80a2e94:	e012      	b.n	80a2ebc <_ZN13IntervalTimer8stop_SITEv+0x44>
	case 1:		// TIM4
		nvicStructure.NVIC_IRQChannel = TIM4_IRQn;
 80a2e96:	231e      	movs	r3, #30
 80a2e98:	f88d 3004 	strb.w	r3, [sp, #4]
		TIMx = TIM4;
 80a2e9c:	4c11      	ldr	r4, [pc, #68]	; (80a2ee4 <_ZN13IntervalTimer8stop_SITEv+0x6c>)
		break;
 80a2e9e:	e00d      	b.n	80a2ebc <_ZN13IntervalTimer8stop_SITEv+0x44>
	case 2:		// TIM5
		nvicStructure.NVIC_IRQChannel = TIM5_IRQn;
 80a2ea0:	2332      	movs	r3, #50	; 0x32
 80a2ea2:	f88d 3004 	strb.w	r3, [sp, #4]
		TIMx = TIM5;
 80a2ea6:	4c10      	ldr	r4, [pc, #64]	; (80a2ee8 <_ZN13IntervalTimer8stop_SITEv+0x70>)
		break;
 80a2ea8:	e008      	b.n	80a2ebc <_ZN13IntervalTimer8stop_SITEv+0x44>
	case 3:		// TIM6
		nvicStructure.NVIC_IRQChannel = TIM6_DAC_IRQn;
 80a2eaa:	2336      	movs	r3, #54	; 0x36
 80a2eac:	f88d 3004 	strb.w	r3, [sp, #4]
		TIMx = TIM6;
 80a2eb0:	4c0e      	ldr	r4, [pc, #56]	; (80a2eec <_ZN13IntervalTimer8stop_SITEv+0x74>)
		break;
 80a2eb2:	e003      	b.n	80a2ebc <_ZN13IntervalTimer8stop_SITEv+0x44>
	case 4:		// TIM7
		nvicStructure.NVIC_IRQChannel = TIM7_IRQn;
 80a2eb4:	2337      	movs	r3, #55	; 0x37
		TIMx = TIM7;
 80a2eb6:	4c0e      	ldr	r4, [pc, #56]	; (80a2ef0 <_ZN13IntervalTimer8stop_SITEv+0x78>)
	case 3:		// TIM6
		nvicStructure.NVIC_IRQChannel = TIM6_DAC_IRQn;
		TIMx = TIM6;
		break;
	case 4:		// TIM7
		nvicStructure.NVIC_IRQChannel = TIM7_IRQn;
 80a2eb8:	f88d 3004 	strb.w	r3, [sp, #4]
		TIMx = TIM7;
		break;
#endif
		}
	// disable counter
	TIM_Cmd(TIMx, DISABLE);
 80a2ebc:	2100      	movs	r1, #0
 80a2ebe:	4620      	mov	r0, r4
 80a2ec0:	f7fd fa3a 	bl	80a0338 <TIM_Cmd>
	
	// disable interrupt
    nvicStructure.NVIC_IRQChannelCmd = DISABLE;
 80a2ec4:	2500      	movs	r5, #0
    NVIC_Init(&nvicStructure);
 80a2ec6:	a801      	add	r0, sp, #4
		}
	// disable counter
	TIM_Cmd(TIMx, DISABLE);
	
	// disable interrupt
    nvicStructure.NVIC_IRQChannelCmd = DISABLE;
 80a2ec8:	f88d 5007 	strb.w	r5, [sp, #7]
    NVIC_Init(&nvicStructure);
 80a2ecc:	f7fd f8f2 	bl	80a00b4 <NVIC_Init>
	
	// disable timer peripheral
	TIM_DeInit(TIMx);
 80a2ed0:	4620      	mov	r0, r4
 80a2ed2:	f7fd f949 	bl	80a0168 <TIM_DeInit>
	
	// free SIT for future use
	SIT_used[SIT_id] = false;
 80a2ed6:	7a73      	ldrb	r3, [r6, #9]
 80a2ed8:	4a06      	ldr	r2, [pc, #24]	; (80a2ef4 <_ZN13IntervalTimer8stop_SITEv+0x7c>)
 80a2eda:	54d5      	strb	r5, [r2, r3]
}
 80a2edc:	b002      	add	sp, #8
 80a2ede:	bd70      	pop	{r4, r5, r6, pc}
 80a2ee0:	40000400 	.word	0x40000400
 80a2ee4:	40000800 	.word	0x40000800
 80a2ee8:	40000c00 	.word	0x40000c00
 80a2eec:	40001000 	.word	0x40001000
 80a2ef0:	40001400 	.word	0x40001400
 80a2ef4:	20000b18 	.word	0x20000b18

080a2ef8 <_ZN13IntervalTimer11beginCyclesEPFvvEmb5TIMid>:
// returning true on success or false in case of failure.
// Period units is defined by scale, where scale = uSec or hmSec
// and = 1-65535 microsecond (uSec)
// or 1-65535 0.5ms increments (hmSec)
// ------------------------------------------------------------
bool IntervalTimer::beginCycles(void (*isrCallback)(), intPeriod Period, bool scale, TIMid id) {
 80a2ef8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a2efc:	461f      	mov	r7, r3

	// if this interval timer is already running, stop and deallocate it
	if (status == TIMER_SIT) {
 80a2efe:	7a03      	ldrb	r3, [r0, #8]
// returning true on success or false in case of failure.
// Period units is defined by scale, where scale = uSec or hmSec
// and = 1-65535 microsecond (uSec)
// or 1-65535 0.5ms increments (hmSec)
// ------------------------------------------------------------
bool IntervalTimer::beginCycles(void (*isrCallback)(), intPeriod Period, bool scale, TIMid id) {
 80a2f00:	4604      	mov	r4, r0
 80a2f02:	4688      	mov	r8, r1
 80a2f04:	4616      	mov	r6, r2
 80a2f06:	f89d 5018 	ldrb.w	r5, [sp, #24]

	// if this interval timer is already running, stop and deallocate it
	if (status == TIMER_SIT) {
 80a2f0a:	b11b      	cbz	r3, 80a2f14 <_ZN13IntervalTimer11beginCyclesEPFvvEmb5TIMid+0x1c>
		stop_SIT();
 80a2f0c:	f7ff ffb4 	bl	80a2e78 <_ZN13IntervalTimer8stop_SITEv>
		status = TIMER_OFF;
 80a2f10:	2300      	movs	r3, #0
 80a2f12:	7223      	strb	r3, [r4, #8]
	}
	// store callback pointer
	myISRcallback = isrCallback;

	if (id < NUM_SIT) {		// Allocate specified timer (id=0 to 2/4) or auto-allocate from pool (id=255)
 80a2f14:	2d04      	cmp	r5, #4
	if (status == TIMER_SIT) {
		stop_SIT();
		status = TIMER_OFF;
	}
	// store callback pointer
	myISRcallback = isrCallback;
 80a2f16:	f8c4 800c 	str.w	r8, [r4, #12]

	if (id < NUM_SIT) {		// Allocate specified timer (id=0 to 2/4) or auto-allocate from pool (id=255)
 80a2f1a:	d810      	bhi.n	80a2f3e <_ZN13IntervalTimer11beginCyclesEPFvvEmb5TIMid+0x46>
		// attempt to allocate this timer
		if (allocate_SIT(Period, scale, id)) status = TIMER_SIT;		//255 means allocate from pool
 80a2f1c:	462b      	mov	r3, r5
 80a2f1e:	463a      	mov	r2, r7
 80a2f20:	4631      	mov	r1, r6
 80a2f22:	4620      	mov	r0, r4
 80a2f24:	f7ff ff82 	bl	80a2e2c <_ZN13IntervalTimer12allocate_SITEmb5TIMid>
 80a2f28:	b120      	cbz	r0, 80a2f34 <_ZN13IntervalTimer11beginCyclesEPFvvEmb5TIMid+0x3c>
 80a2f2a:	2301      	movs	r3, #1
 80a2f2c:	e003      	b.n	80a2f36 <_ZN13IntervalTimer11beginCyclesEPFvvEmb5TIMid+0x3e>
 80a2f2e:	3501      	adds	r5, #1
			return true;
		}
	}
	else {	
		// Auto allocate - check for an available SIT, and if so, start it
		for (uint8_t tid = 0; tid < NUM_SIT; tid++) {
 80a2f30:	2d05      	cmp	r5, #5
 80a2f32:	d106      	bne.n	80a2f42 <_ZN13IntervalTimer11beginCyclesEPFvvEmb5TIMid+0x4a>
	myISRcallback = isrCallback;

	if (id < NUM_SIT) {		// Allocate specified timer (id=0 to 2/4) or auto-allocate from pool (id=255)
		// attempt to allocate this timer
		if (allocate_SIT(Period, scale, id)) status = TIMER_SIT;		//255 means allocate from pool
		else status = TIMER_OFF;
 80a2f34:	2300      	movs	r3, #0
 80a2f36:	7223      	strb	r3, [r4, #8]

	// check for success and return
	if (status != TIMER_OFF) return true;
	return false;

}
 80a2f38:	7a20      	ldrb	r0, [r4, #8]
 80a2f3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		}
	}
	else {	
		// Auto allocate - check for an available SIT, and if so, start it
		for (uint8_t tid = 0; tid < NUM_SIT; tid++) {
			if (!SIT_used[tid]) {
 80a2f3e:	4b08      	ldr	r3, [pc, #32]	; (80a2f60 <_ZN13IntervalTimer11beginCyclesEPFvvEmb5TIMid+0x68>)
 80a2f40:	2500      	movs	r5, #0
 80a2f42:	5ce9      	ldrb	r1, [r5, r3]
 80a2f44:	b2ea      	uxtb	r2, r5
 80a2f46:	2900      	cmp	r1, #0
 80a2f48:	d1f1      	bne.n	80a2f2e <_ZN13IntervalTimer11beginCyclesEPFvvEmb5TIMid+0x36>
				SIT_id = tid;
 80a2f4a:	7262      	strb	r2, [r4, #9]
				start_SIT(Period, scale);
 80a2f4c:	4631      	mov	r1, r6
 80a2f4e:	463a      	mov	r2, r7
 80a2f50:	4620      	mov	r0, r4
 80a2f52:	f7ff fef7 	bl	80a2d44 <_ZN13IntervalTimer9start_SITEmb>
				SIT_used[tid] = true;
 80a2f56:	4a02      	ldr	r2, [pc, #8]	; (80a2f60 <_ZN13IntervalTimer11beginCyclesEPFvvEmb5TIMid+0x68>)
 80a2f58:	2301      	movs	r3, #1
 80a2f5a:	5553      	strb	r3, [r2, r5]
 80a2f5c:	e7eb      	b.n	80a2f36 <_ZN13IntervalTimer11beginCyclesEPFvvEmb5TIMid+0x3e>
 80a2f5e:	bf00      	nop
 80a2f60:	20000b18 	.word	0x20000b18

080a2f64 <_ZN13IntervalTimer3endEv>:
// ------------------------------------------------------------
// stop the timer if it's currently running, using its status
// to determine what hardware resources the timer may be using
// ------------------------------------------------------------
void IntervalTimer::end() {
	if (status == TIMER_SIT) stop_SIT();
 80a2f64:	7a03      	ldrb	r3, [r0, #8]

// ------------------------------------------------------------
// stop the timer if it's currently running, using its status
// to determine what hardware resources the timer may be using
// ------------------------------------------------------------
void IntervalTimer::end() {
 80a2f66:	b510      	push	{r4, lr}
 80a2f68:	4604      	mov	r4, r0
	if (status == TIMER_SIT) stop_SIT();
 80a2f6a:	b10b      	cbz	r3, 80a2f70 <_ZN13IntervalTimer3endEv+0xc>
 80a2f6c:	f7ff ff84 	bl	80a2e78 <_ZN13IntervalTimer8stop_SITEv>
	status = TIMER_OFF;
 80a2f70:	2300      	movs	r3, #0
 80a2f72:	7223      	strb	r3, [r4, #8]
 80a2f74:	bd10      	pop	{r4, pc}

080a2f76 <_GLOBAL__sub_I__ZN13IntervalTimer8SIT_usedE>:
 80a2f76:	f000 b801 	b.w	80a2f7c <HAL_Pin_Map>
	...

080a2f7c <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, STM32_Pin_Info*(void))
 80a2f7c:	b508      	push	{r3, lr}
 80a2f7e:	4b02      	ldr	r3, [pc, #8]	; (80a2f88 <HAL_Pin_Map+0xc>)
 80a2f80:	681b      	ldr	r3, [r3, #0]
 80a2f82:	681b      	ldr	r3, [r3, #0]
 80a2f84:	9301      	str	r3, [sp, #4]
 80a2f86:	bd08      	pop	{r3, pc}
 80a2f88:	080601b0 	.word	0x080601b0

080a2f8c <HAL_Validate_Pin_Function>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
 80a2f8c:	b508      	push	{r3, lr}
 80a2f8e:	4b02      	ldr	r3, [pc, #8]	; (80a2f98 <HAL_Validate_Pin_Function+0xc>)
 80a2f90:	681b      	ldr	r3, [r3, #0]
 80a2f92:	685b      	ldr	r3, [r3, #4]
 80a2f94:	9301      	str	r3, [sp, #4]
 80a2f96:	bd08      	pop	{r3, pc}
 80a2f98:	080601b0 	.word	0x080601b0

080a2f9c <HAL_Pin_Mode>:
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a2f9c:	b508      	push	{r3, lr}
 80a2f9e:	4b02      	ldr	r3, [pc, #8]	; (80a2fa8 <HAL_Pin_Mode+0xc>)
 80a2fa0:	681b      	ldr	r3, [r3, #0]
 80a2fa2:	689b      	ldr	r3, [r3, #8]
 80a2fa4:	9301      	str	r3, [sp, #4]
 80a2fa6:	bd08      	pop	{r3, pc}
 80a2fa8:	080601b0 	.word	0x080601b0

080a2fac <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a2fac:	b508      	push	{r3, lr}
 80a2fae:	4b02      	ldr	r3, [pc, #8]	; (80a2fb8 <HAL_Get_Pin_Mode+0xc>)
 80a2fb0:	681b      	ldr	r3, [r3, #0]
 80a2fb2:	68db      	ldr	r3, [r3, #12]
 80a2fb4:	9301      	str	r3, [sp, #4]
 80a2fb6:	bd08      	pop	{r3, pc}
 80a2fb8:	080601b0 	.word	0x080601b0

080a2fbc <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
 80a2fbc:	b508      	push	{r3, lr}
 80a2fbe:	4b02      	ldr	r3, [pc, #8]	; (80a2fc8 <HAL_GPIO_Write+0xc>)
 80a2fc0:	681b      	ldr	r3, [r3, #0]
 80a2fc2:	691b      	ldr	r3, [r3, #16]
 80a2fc4:	9301      	str	r3, [sp, #4]
 80a2fc6:	bd08      	pop	{r3, pc}
 80a2fc8:	080601b0 	.word	0x080601b0

080a2fcc <HAL_ADC_Read>:
DYNALIB_FN(8, hal_gpio, HAL_Interrupts_Enable_All, void(void))
DYNALIB_FN(9, hal_gpio, HAL_Interrupts_Disable_All, void(void))

DYNALIB_FN(10, hal_gpio, HAL_DAC_Write, void(pin_t, uint16_t))
DYNALIB_FN(11, hal_gpio, HAL_ADC_Set_Sample_Time, void(uint8_t))
DYNALIB_FN(12, hal_gpio, HAL_ADC_Read, int32_t(uint16_t))
 80a2fcc:	b508      	push	{r3, lr}
 80a2fce:	4b02      	ldr	r3, [pc, #8]	; (80a2fd8 <HAL_ADC_Read+0xc>)
 80a2fd0:	681b      	ldr	r3, [r3, #0]
 80a2fd2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a2fd4:	9301      	str	r3, [sp, #4]
 80a2fd6:	bd08      	pop	{r3, pc}
 80a2fd8:	080601b0 	.word	0x080601b0

080a2fdc <HAL_Set_System_Interrupt_Handler>:

DYNALIB_FN(13, hal_gpio, HAL_PWM_Write, void(uint16_t, uint8_t))
DYNALIB_FN(14, hal_gpio, HAL_PWM_Get_Frequency, uint16_t(uint16_t))
DYNALIB_FN(15, hal_gpio, HAL_PWM_Get_AnalogValue, uint16_t(uint16_t))

DYNALIB_FN(16, hal_gpio, HAL_Set_System_Interrupt_Handler, uint8_t(hal_irq_t, const HAL_InterruptCallback*, HAL_InterruptCallback*, void*))
 80a2fdc:	b508      	push	{r3, lr}
 80a2fde:	4b02      	ldr	r3, [pc, #8]	; (80a2fe8 <HAL_Set_System_Interrupt_Handler+0xc>)
 80a2fe0:	681b      	ldr	r3, [r3, #0]
 80a2fe2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a2fe4:	9301      	str	r3, [sp, #4]
 80a2fe6:	bd08      	pop	{r3, pc}
 80a2fe8:	080601b0 	.word	0x080601b0

080a2fec <HAL_SPI_Begin>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_spi)

DYNALIB_FN(0, hal_spi, HAL_SPI_Begin, void(HAL_SPI_Interface, uint16_t))
 80a2fec:	b508      	push	{r3, lr}
 80a2fee:	4b02      	ldr	r3, [pc, #8]	; (80a2ff8 <HAL_SPI_Begin+0xc>)
 80a2ff0:	681b      	ldr	r3, [r3, #0]
 80a2ff2:	681b      	ldr	r3, [r3, #0]
 80a2ff4:	9301      	str	r3, [sp, #4]
 80a2ff6:	bd08      	pop	{r3, pc}
 80a2ff8:	080601b4 	.word	0x080601b4

080a2ffc <HAL_SPI_Send_Receive_Data>:
DYNALIB_FN(1, hal_spi, HAL_SPI_End, void(HAL_SPI_Interface))
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
 80a2ffc:	b508      	push	{r3, lr}
 80a2ffe:	4b02      	ldr	r3, [pc, #8]	; (80a3008 <HAL_SPI_Send_Receive_Data+0xc>)
 80a3000:	681b      	ldr	r3, [r3, #0]
 80a3002:	695b      	ldr	r3, [r3, #20]
 80a3004:	9301      	str	r3, [sp, #4]
 80a3006:	bd08      	pop	{r3, pc}
 80a3008:	080601b4 	.word	0x080601b4

080a300c <HAL_SPI_Init>:
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a300c:	b508      	push	{r3, lr}
 80a300e:	4b02      	ldr	r3, [pc, #8]	; (80a3018 <HAL_SPI_Init+0xc>)
 80a3010:	681b      	ldr	r3, [r3, #0]
 80a3012:	69db      	ldr	r3, [r3, #28]
 80a3014:	9301      	str	r3, [sp, #4]
 80a3016:	bd08      	pop	{r3, pc}
 80a3018:	080601b4 	.word	0x080601b4

080a301c <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a301c:	b508      	push	{r3, lr}
 80a301e:	4b02      	ldr	r3, [pc, #8]	; (80a3028 <HAL_SPI_Is_Enabled+0xc>)
 80a3020:	681b      	ldr	r3, [r3, #0]
 80a3022:	6a1b      	ldr	r3, [r3, #32]
 80a3024:	9301      	str	r3, [sp, #4]
 80a3026:	bd08      	pop	{r3, pc}
 80a3028:	080601b4 	.word	0x080601b4

080a302c <HAL_SPI_Info>:
DYNALIB_FN(9, hal_spi, HAL_SPI_Info, void(HAL_SPI_Interface, hal_spi_info_t*, void*))
 80a302c:	b508      	push	{r3, lr}
 80a302e:	4b02      	ldr	r3, [pc, #8]	; (80a3038 <HAL_SPI_Info+0xc>)
 80a3030:	681b      	ldr	r3, [r3, #0]
 80a3032:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a3034:	9301      	str	r3, [sp, #4]
 80a3036:	bd08      	pop	{r3, pc}
 80a3038:	080601b4 	.word	0x080601b4

080a303c <HAL_SPI_DMA_Transfer>:
DYNALIB_FN(10, hal_spi, HAL_SPI_DMA_Transfer, void(HAL_SPI_Interface, void*, void*, uint32_t, HAL_SPI_DMA_UserCallback))
 80a303c:	b508      	push	{r3, lr}
 80a303e:	4b02      	ldr	r3, [pc, #8]	; (80a3048 <HAL_SPI_DMA_Transfer+0xc>)
 80a3040:	681b      	ldr	r3, [r3, #0]
 80a3042:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a3044:	9301      	str	r3, [sp, #4]
 80a3046:	bd08      	pop	{r3, pc}
 80a3048:	080601b4 	.word	0x080601b4

080a304c <HAL_SPI_DMA_Transfer_Status>:
DYNALIB_FN(11, hal_spi, HAL_SPI_Begin_Ext, void(HAL_SPI_Interface, SPI_Mode, uint16_t, void*))
DYNALIB_FN(12, hal_spi, HAL_SPI_Set_Callback_On_Select, void(HAL_SPI_Interface, HAL_SPI_Select_UserCallback, void*))
DYNALIB_FN(13, hal_spi, HAL_SPI_DMA_Transfer_Cancel, void(HAL_SPI_Interface))
DYNALIB_FN(14, hal_spi, HAL_SPI_DMA_Transfer_Status, int32_t(HAL_SPI_Interface, HAL_SPI_TransferStatus*))
 80a304c:	b508      	push	{r3, lr}
 80a304e:	4b02      	ldr	r3, [pc, #8]	; (80a3058 <HAL_SPI_DMA_Transfer_Status+0xc>)
 80a3050:	681b      	ldr	r3, [r3, #0]
 80a3052:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a3054:	9301      	str	r3, [sp, #4]
 80a3056:	bd08      	pop	{r3, pc}
 80a3058:	080601b4 	.word	0x080601b4

080a305c <HAL_SPI_Set_Settings>:
DYNALIB_FN(15, hal_spi, HAL_SPI_Set_Settings, int32_t(HAL_SPI_Interface, uint8_t, uint8_t, uint8_t, uint8_t, void*))
 80a305c:	b508      	push	{r3, lr}
 80a305e:	4b02      	ldr	r3, [pc, #8]	; (80a3068 <HAL_SPI_Set_Settings+0xc>)
 80a3060:	681b      	ldr	r3, [r3, #0]
 80a3062:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a3064:	9301      	str	r3, [sp, #4]
 80a3066:	bd08      	pop	{r3, pc}
 80a3068:	080601b4 	.word	0x080601b4

080a306c <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a306c:	b508      	push	{r3, lr}
 80a306e:	4b02      	ldr	r3, [pc, #8]	; (80a3078 <HAL_RNG_GetRandomNumber+0xc>)
 80a3070:	681b      	ldr	r3, [r3, #0]
 80a3072:	685b      	ldr	r3, [r3, #4]
 80a3074:	9301      	str	r3, [sp, #4]
 80a3076:	bd08      	pop	{r3, pc}
 80a3078:	0806019c 	.word	0x0806019c

080a307c <HAL_Timer_Get_Micro_Seconds>:
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
 80a307c:	b508      	push	{r3, lr}
 80a307e:	4b02      	ldr	r3, [pc, #8]	; (80a3088 <HAL_Timer_Get_Micro_Seconds+0xc>)
 80a3080:	681b      	ldr	r3, [r3, #0]
 80a3082:	691b      	ldr	r3, [r3, #16]
 80a3084:	9301      	str	r3, [sp, #4]
 80a3086:	bd08      	pop	{r3, pc}
 80a3088:	0806019c 	.word	0x0806019c

080a308c <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a308c:	b508      	push	{r3, lr}
 80a308e:	4b02      	ldr	r3, [pc, #8]	; (80a3098 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a3090:	681b      	ldr	r3, [r3, #0]
 80a3092:	695b      	ldr	r3, [r3, #20]
 80a3094:	9301      	str	r3, [sp, #4]
 80a3096:	bd08      	pop	{r3, pc}
 80a3098:	0806019c 	.word	0x0806019c

080a309c <HAL_RTC_Get_UnixTime>:

DYNALIB_FN(BASE_IDX + 4, hal, HAL_RTC_Configuration, void(void))
DYNALIB_FN(BASE_IDX + 5, hal, HAL_RTC_Get_UnixTime, time_t(void))
 80a309c:	b508      	push	{r3, lr}
 80a309e:	4b02      	ldr	r3, [pc, #8]	; (80a30a8 <HAL_RTC_Get_UnixTime+0xc>)
 80a30a0:	681b      	ldr	r3, [r3, #0]
 80a30a2:	69db      	ldr	r3, [r3, #28]
 80a30a4:	9301      	str	r3, [sp, #4]
 80a30a6:	bd08      	pop	{r3, pc}
 80a30a8:	0806019c 	.word	0x0806019c

080a30ac <HAL_RTC_Time_Is_Valid>:
DYNALIB_FN(BASE_IDX + 15, hal,HAL_EEPROM_Get, void(uint32_t, void *, size_t))
DYNALIB_FN(BASE_IDX + 16, hal,HAL_EEPROM_Put, void(uint32_t, const void *, size_t))
DYNALIB_FN(BASE_IDX + 17, hal,HAL_EEPROM_Clear, void(void))
DYNALIB_FN(BASE_IDX + 18, hal,HAL_EEPROM_Has_Pending_Erase, bool(void))
DYNALIB_FN(BASE_IDX + 19, hal,HAL_EEPROM_Perform_Pending_Erase, void(void))
DYNALIB_FN(BASE_IDX + 20, hal, HAL_RTC_Time_Is_Valid, uint8_t(void*))
 80a30ac:	b508      	push	{r3, lr}
 80a30ae:	4b02      	ldr	r3, [pc, #8]	; (80a30b8 <HAL_RTC_Time_Is_Valid+0xc>)
 80a30b0:	681b      	ldr	r3, [r3, #0]
 80a30b2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a30b4:	9301      	str	r3, [sp, #4]
 80a30b6:	bd08      	pop	{r3, pc}
 80a30b8:	0806019c 	.word	0x0806019c

080a30bc <HAL_Core_Get_Last_Reset_Info>:
DYNALIB_FN(22, hal_core, HAL_Set_System_Config, int(hal_system_config_t, const void*, unsigned))
DYNALIB_FN(23, hal_core, HAL_Core_Enter_Safe_Mode, void(void*))
DYNALIB_FN(24, hal_core, HAL_Feature_Get, bool(HAL_Feature))
DYNALIB_FN(25, hal_core, HAL_Feature_Set, int(HAL_Feature, bool))
DYNALIB_FN(26, hal_core, HAL_Core_System_Reset_Ex, void(int, uint32_t, void*))
DYNALIB_FN(27, hal_core, HAL_Core_Get_Last_Reset_Info, int(int*, uint32_t*, void*))
 80a30bc:	b508      	push	{r3, lr}
 80a30be:	4b02      	ldr	r3, [pc, #8]	; (80a30c8 <HAL_Core_Get_Last_Reset_Info+0xc>)
 80a30c0:	681b      	ldr	r3, [r3, #0]
 80a30c2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a30c4:	9301      	str	r3, [sp, #4]
 80a30c6:	bd08      	pop	{r3, pc}
 80a30c8:	080601b8 	.word	0x080601b8

080a30cc <os_thread_create>:

DYNALIB_BEGIN(hal_concurrent)

#if PLATFORM_THREADING
DYNALIB_FN(0, hal_concurrent, __gthread_equal, bool(__gthread_t, __gthread_t))
DYNALIB_FN(1, hal_concurrent, os_thread_create, os_result_t(os_thread_t*, const char*, os_thread_prio_t, os_thread_fn_t, void*, size_t))
 80a30cc:	b508      	push	{r3, lr}
 80a30ce:	4b02      	ldr	r3, [pc, #8]	; (80a30d8 <os_thread_create+0xc>)
 80a30d0:	681b      	ldr	r3, [r3, #0]
 80a30d2:	685b      	ldr	r3, [r3, #4]
 80a30d4:	9301      	str	r3, [sp, #4]
 80a30d6:	bd08      	pop	{r3, pc}
 80a30d8:	080601d0 	.word	0x080601d0

080a30dc <os_thread_yield>:
DYNALIB_FN(2, hal_concurrent, os_thread_is_current, bool(os_thread_t))
DYNALIB_FN(3, hal_concurrent, os_thread_yield, os_result_t(void))
 80a30dc:	b508      	push	{r3, lr}
 80a30de:	4b02      	ldr	r3, [pc, #8]	; (80a30e8 <os_thread_yield+0xc>)
 80a30e0:	681b      	ldr	r3, [r3, #0]
 80a30e2:	68db      	ldr	r3, [r3, #12]
 80a30e4:	9301      	str	r3, [sp, #4]
 80a30e6:	bd08      	pop	{r3, pc}
 80a30e8:	080601d0 	.word	0x080601d0

080a30ec <os_mutex_create>:
DYNALIB_FN(8, hal_concurrent, os_timer_create, int(os_timer_t*, unsigned, void(*)(os_timer_t), void*, bool, void*))
DYNALIB_FN(9, hal_concurrent, os_timer_destroy, int(os_timer_t, void*))
DYNALIB_FN(10, hal_concurrent, os_timer_get_id, int(os_timer_t, void**))
DYNALIB_FN(11, hal_concurrent, os_timer_change, int(os_timer_t, os_timer_change_t, bool, unsigned, unsigned, void*))

DYNALIB_FN(12, hal_concurrent, os_mutex_create, int(os_mutex_t*))
 80a30ec:	b508      	push	{r3, lr}
 80a30ee:	4b02      	ldr	r3, [pc, #8]	; (80a30f8 <os_mutex_create+0xc>)
 80a30f0:	681b      	ldr	r3, [r3, #0]
 80a30f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a30f4:	9301      	str	r3, [sp, #4]
 80a30f6:	bd08      	pop	{r3, pc}
 80a30f8:	080601d0 	.word	0x080601d0

080a30fc <os_mutex_lock>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
 80a30fc:	b508      	push	{r3, lr}
 80a30fe:	4b02      	ldr	r3, [pc, #8]	; (80a3108 <os_mutex_lock+0xc>)
 80a3100:	681b      	ldr	r3, [r3, #0]
 80a3102:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a3104:	9301      	str	r3, [sp, #4]
 80a3106:	bd08      	pop	{r3, pc}
 80a3108:	080601d0 	.word	0x080601d0

080a310c <os_mutex_unlock>:
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))
 80a310c:	b508      	push	{r3, lr}
 80a310e:	4b02      	ldr	r3, [pc, #8]	; (80a3118 <os_mutex_unlock+0xc>)
 80a3110:	681b      	ldr	r3, [r3, #0]
 80a3112:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a3114:	9301      	str	r3, [sp, #4]
 80a3116:	bd08      	pop	{r3, pc}
 80a3118:	080601d0 	.word	0x080601d0

080a311c <os_mutex_recursive_create>:

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
 80a311c:	b508      	push	{r3, lr}
 80a311e:	4b02      	ldr	r3, [pc, #8]	; (80a3128 <os_mutex_recursive_create+0xc>)
 80a3120:	681b      	ldr	r3, [r3, #0]
 80a3122:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a3124:	9301      	str	r3, [sp, #4]
 80a3126:	bd08      	pop	{r3, pc}
 80a3128:	080601d0 	.word	0x080601d0

080a312c <os_mutex_recursive_lock>:
DYNALIB_FN(18, hal_concurrent, os_mutex_recursive_destroy, int(os_mutex_recursive_t))
DYNALIB_FN(19, hal_concurrent, os_mutex_recursive_lock, int(os_mutex_recursive_t))
 80a312c:	b508      	push	{r3, lr}
 80a312e:	4b02      	ldr	r3, [pc, #8]	; (80a3138 <os_mutex_recursive_lock+0xc>)
 80a3130:	681b      	ldr	r3, [r3, #0]
 80a3132:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a3134:	9301      	str	r3, [sp, #4]
 80a3136:	bd08      	pop	{r3, pc}
 80a3138:	080601d0 	.word	0x080601d0

080a313c <os_mutex_recursive_unlock>:
DYNALIB_FN(20, hal_concurrent, os_mutex_recursive_trylock, int(os_mutex_recursive_t))
DYNALIB_FN(21, hal_concurrent, os_mutex_recursive_unlock, int(os_mutex_recursive_t))
 80a313c:	b508      	push	{r3, lr}
 80a313e:	4b02      	ldr	r3, [pc, #8]	; (80a3148 <os_mutex_recursive_unlock+0xc>)
 80a3140:	681b      	ldr	r3, [r3, #0]
 80a3142:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a3144:	9301      	str	r3, [sp, #4]
 80a3146:	bd08      	pop	{r3, pc}
 80a3148:	080601d0 	.word	0x080601d0

080a314c <os_thread_exit>:

DYNALIB_FN(23, hal_concurrent, os_queue_create, int(os_queue_t*, size_t, size_t, void*))
DYNALIB_FN(24, hal_concurrent, os_queue_destroy, int(os_queue_t, void*))
DYNALIB_FN(25, hal_concurrent, os_queue_put, int(os_queue_t, const void* item, system_tick_t, void*))
DYNALIB_FN(26, hal_concurrent, os_queue_take, int(os_queue_t, void* item, system_tick_t, void*))
DYNALIB_FN(27, hal_concurrent, os_thread_exit, os_result_t(os_thread_t))
 80a314c:	b508      	push	{r3, lr}
 80a314e:	4b02      	ldr	r3, [pc, #8]	; (80a3158 <os_thread_exit+0xc>)
 80a3150:	681b      	ldr	r3, [r3, #0]
 80a3152:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a3154:	9301      	str	r3, [sp, #4]
 80a3156:	bd08      	pop	{r3, pc}
 80a3158:	080601d0 	.word	0x080601d0

080a315c <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a315c:	b508      	push	{r3, lr}
 80a315e:	4b02      	ldr	r3, [pc, #8]	; (80a3168 <HAL_USART_Init+0xc>)
 80a3160:	681b      	ldr	r3, [r3, #0]
 80a3162:	699b      	ldr	r3, [r3, #24]
 80a3164:	9301      	str	r3, [sp, #4]
 80a3166:	bd08      	pop	{r3, pc}
 80a3168:	080601c4 	.word	0x080601c4

080a316c <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a316c:	b508      	push	{r3, lr}
 80a316e:	4b02      	ldr	r3, [pc, #8]	; (80a3178 <HAL_USART_Write_Data+0xc>)
 80a3170:	681b      	ldr	r3, [r3, #0]
 80a3172:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a3174:	9301      	str	r3, [sp, #4]
 80a3176:	bd08      	pop	{r3, pc}
 80a3178:	080601c4 	.word	0x080601c4

080a317c <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a317c:	b508      	push	{r3, lr}
 80a317e:	4b02      	ldr	r3, [pc, #8]	; (80a3188 <HAL_USART_Available_Data+0xc>)
 80a3180:	681b      	ldr	r3, [r3, #0]
 80a3182:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a3184:	9301      	str	r3, [sp, #4]
 80a3186:	bd08      	pop	{r3, pc}
 80a3188:	080601c4 	.word	0x080601c4

080a318c <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a318c:	b508      	push	{r3, lr}
 80a318e:	4b02      	ldr	r3, [pc, #8]	; (80a3198 <HAL_USART_Read_Data+0xc>)
 80a3190:	681b      	ldr	r3, [r3, #0]
 80a3192:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a3194:	9301      	str	r3, [sp, #4]
 80a3196:	bd08      	pop	{r3, pc}
 80a3198:	080601c4 	.word	0x080601c4

080a319c <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a319c:	b508      	push	{r3, lr}
 80a319e:	4b02      	ldr	r3, [pc, #8]	; (80a31a8 <HAL_USART_Peek_Data+0xc>)
 80a31a0:	681b      	ldr	r3, [r3, #0]
 80a31a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a31a4:	9301      	str	r3, [sp, #4]
 80a31a6:	bd08      	pop	{r3, pc}
 80a31a8:	080601c4 	.word	0x080601c4

080a31ac <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a31ac:	b508      	push	{r3, lr}
 80a31ae:	4b02      	ldr	r3, [pc, #8]	; (80a31b8 <HAL_USART_Flush_Data+0xc>)
 80a31b0:	681b      	ldr	r3, [r3, #0]
 80a31b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a31b4:	9301      	str	r3, [sp, #4]
 80a31b6:	bd08      	pop	{r3, pc}
 80a31b8:	080601c4 	.word	0x080601c4

080a31bc <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a31bc:	b508      	push	{r3, lr}
 80a31be:	4b02      	ldr	r3, [pc, #8]	; (80a31c8 <HAL_USART_Is_Enabled+0xc>)
 80a31c0:	681b      	ldr	r3, [r3, #0]
 80a31c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a31c4:	9301      	str	r3, [sp, #4]
 80a31c6:	bd08      	pop	{r3, pc}
 80a31c8:	080601c4 	.word	0x080601c4

080a31cc <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a31cc:	b508      	push	{r3, lr}
 80a31ce:	4b02      	ldr	r3, [pc, #8]	; (80a31d8 <HAL_USART_Available_Data_For_Write+0xc>)
 80a31d0:	681b      	ldr	r3, [r3, #0]
 80a31d2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a31d4:	9301      	str	r3, [sp, #4]
 80a31d6:	bd08      	pop	{r3, pc}
 80a31d8:	080601c4 	.word	0x080601c4

080a31dc <HAL_USART_BeginConfig>:
#define BASE_IDX2 (BASE_IDX+13)
#else
#define BASE_IDX2 (BASE_IDX+11)
#endif

DYNALIB_FN(BASE_IDX2 + 0, hal_usart, HAL_USART_BeginConfig, void(HAL_USART_Serial serial, uint32_t baud, uint32_t config, void *ptr))
 80a31dc:	b508      	push	{r3, lr}
 80a31de:	4b02      	ldr	r3, [pc, #8]	; (80a31e8 <HAL_USART_BeginConfig+0xc>)
 80a31e0:	681b      	ldr	r3, [r3, #0]
 80a31e2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a31e4:	9301      	str	r3, [sp, #4]
 80a31e6:	bd08      	pop	{r3, pc}
 80a31e8:	080601c4 	.word	0x080601c4

080a31ec <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a31ec:	b508      	push	{r3, lr}
 80a31ee:	4b02      	ldr	r3, [pc, #8]	; (80a31f8 <HAL_I2C_Write_Data+0xc>)
 80a31f0:	681b      	ldr	r3, [r3, #0]
 80a31f2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a31f4:	9301      	str	r3, [sp, #4]
 80a31f6:	bd08      	pop	{r3, pc}
 80a31f8:	080601ac 	.word	0x080601ac

080a31fc <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a31fc:	b508      	push	{r3, lr}
 80a31fe:	4b02      	ldr	r3, [pc, #8]	; (80a3208 <HAL_I2C_Available_Data+0xc>)
 80a3200:	681b      	ldr	r3, [r3, #0]
 80a3202:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a3204:	9301      	str	r3, [sp, #4]
 80a3206:	bd08      	pop	{r3, pc}
 80a3208:	080601ac 	.word	0x080601ac

080a320c <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a320c:	b508      	push	{r3, lr}
 80a320e:	4b02      	ldr	r3, [pc, #8]	; (80a3218 <HAL_I2C_Read_Data+0xc>)
 80a3210:	681b      	ldr	r3, [r3, #0]
 80a3212:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a3214:	9301      	str	r3, [sp, #4]
 80a3216:	bd08      	pop	{r3, pc}
 80a3218:	080601ac 	.word	0x080601ac

080a321c <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a321c:	b508      	push	{r3, lr}
 80a321e:	4b02      	ldr	r3, [pc, #8]	; (80a3228 <HAL_I2C_Peek_Data+0xc>)
 80a3220:	681b      	ldr	r3, [r3, #0]
 80a3222:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a3224:	9301      	str	r3, [sp, #4]
 80a3226:	bd08      	pop	{r3, pc}
 80a3228:	080601ac 	.word	0x080601ac

080a322c <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a322c:	b508      	push	{r3, lr}
 80a322e:	4b02      	ldr	r3, [pc, #8]	; (80a3238 <HAL_I2C_Flush_Data+0xc>)
 80a3230:	681b      	ldr	r3, [r3, #0]
 80a3232:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a3234:	9301      	str	r3, [sp, #4]
 80a3236:	bd08      	pop	{r3, pc}
 80a3238:	080601ac 	.word	0x080601ac

080a323c <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a323c:	b508      	push	{r3, lr}
 80a323e:	4b02      	ldr	r3, [pc, #8]	; (80a3248 <HAL_I2C_Is_Enabled+0xc>)
 80a3240:	681b      	ldr	r3, [r3, #0]
 80a3242:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a3244:	9301      	str	r3, [sp, #4]
 80a3246:	bd08      	pop	{r3, pc}
 80a3248:	080601ac 	.word	0x080601ac

080a324c <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a324c:	b508      	push	{r3, lr}
 80a324e:	4b03      	ldr	r3, [pc, #12]	; (80a325c <HAL_I2C_Init+0x10>)
 80a3250:	681b      	ldr	r3, [r3, #0]
 80a3252:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a3256:	9301      	str	r3, [sp, #4]
 80a3258:	bd08      	pop	{r3, pc}
 80a325a:	0000      	.short	0x0000
 80a325c:	080601ac 	.word	0x080601ac

080a3260 <HAL_CAN_Init>:
#include "can_hal.h"
#endif

DYNALIB_BEGIN(hal_can)

DYNALIB_FN(0, hal_can, HAL_CAN_Init, void(HAL_CAN_Channel, uint16_t, uint16_t, void*))
 80a3260:	b508      	push	{r3, lr}
 80a3262:	4b02      	ldr	r3, [pc, #8]	; (80a326c <HAL_CAN_Init+0xc>)
 80a3264:	681b      	ldr	r3, [r3, #0]
 80a3266:	681b      	ldr	r3, [r3, #0]
 80a3268:	9301      	str	r3, [sp, #4]
 80a326a:	bd08      	pop	{r3, pc}
 80a326c:	080601d4 	.word	0x080601d4

080a3270 <HAL_CAN_Begin>:
DYNALIB_FN(1, hal_can, HAL_CAN_Begin, void(HAL_CAN_Channel, uint32_t, uint32_t, void*))
 80a3270:	b508      	push	{r3, lr}
 80a3272:	4b02      	ldr	r3, [pc, #8]	; (80a327c <HAL_CAN_Begin+0xc>)
 80a3274:	681b      	ldr	r3, [r3, #0]
 80a3276:	685b      	ldr	r3, [r3, #4]
 80a3278:	9301      	str	r3, [sp, #4]
 80a327a:	bd08      	pop	{r3, pc}
 80a327c:	080601d4 	.word	0x080601d4

080a3280 <HAL_CAN_Receive>:
DYNALIB_FN(2, hal_can, HAL_CAN_End, void(HAL_CAN_Channel, void*))
DYNALIB_FN(3, hal_can, HAL_CAN_Transmit, bool(HAL_CAN_Channel, const CANMessage*, void*))
DYNALIB_FN(4, hal_can, HAL_CAN_Receive, bool(HAL_CAN_Channel, CANMessage*, void*))
 80a3280:	b508      	push	{r3, lr}
 80a3282:	4b02      	ldr	r3, [pc, #8]	; (80a328c <HAL_CAN_Receive+0xc>)
 80a3284:	681b      	ldr	r3, [r3, #0]
 80a3286:	691b      	ldr	r3, [r3, #16]
 80a3288:	9301      	str	r3, [sp, #4]
 80a328a:	bd08      	pop	{r3, pc}
 80a328c:	080601d4 	.word	0x080601d4

080a3290 <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a3290:	b508      	push	{r3, lr}
 80a3292:	4b02      	ldr	r3, [pc, #8]	; (80a329c <HAL_USB_USART_Init+0xc>)
 80a3294:	681b      	ldr	r3, [r3, #0]
 80a3296:	681b      	ldr	r3, [r3, #0]
 80a3298:	9301      	str	r3, [sp, #4]
 80a329a:	bd08      	pop	{r3, pc}
 80a329c:	080601d8 	.word	0x080601d8

080a32a0 <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
 80a32a0:	b508      	push	{r3, lr}
 80a32a2:	4b02      	ldr	r3, [pc, #8]	; (80a32ac <HAL_USB_USART_Begin+0xc>)
 80a32a4:	681b      	ldr	r3, [r3, #0]
 80a32a6:	685b      	ldr	r3, [r3, #4]
 80a32a8:	9301      	str	r3, [sp, #4]
 80a32aa:	bd08      	pop	{r3, pc}
 80a32ac:	080601d8 	.word	0x080601d8

080a32b0 <HAL_USB_USART_Available_Data>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a32b0:	b508      	push	{r3, lr}
 80a32b2:	4b02      	ldr	r3, [pc, #8]	; (80a32bc <HAL_USB_USART_Available_Data+0xc>)
 80a32b4:	681b      	ldr	r3, [r3, #0]
 80a32b6:	691b      	ldr	r3, [r3, #16]
 80a32b8:	9301      	str	r3, [sp, #4]
 80a32ba:	bd08      	pop	{r3, pc}
 80a32bc:	080601d8 	.word	0x080601d8

080a32c0 <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a32c0:	b508      	push	{r3, lr}
 80a32c2:	4b02      	ldr	r3, [pc, #8]	; (80a32cc <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a32c4:	681b      	ldr	r3, [r3, #0]
 80a32c6:	695b      	ldr	r3, [r3, #20]
 80a32c8:	9301      	str	r3, [sp, #4]
 80a32ca:	bd08      	pop	{r3, pc}
 80a32cc:	080601d8 	.word	0x080601d8

080a32d0 <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a32d0:	b508      	push	{r3, lr}
 80a32d2:	4b02      	ldr	r3, [pc, #8]	; (80a32dc <HAL_USB_USART_Receive_Data+0xc>)
 80a32d4:	681b      	ldr	r3, [r3, #0]
 80a32d6:	699b      	ldr	r3, [r3, #24]
 80a32d8:	9301      	str	r3, [sp, #4]
 80a32da:	bd08      	pop	{r3, pc}
 80a32dc:	080601d8 	.word	0x080601d8

080a32e0 <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a32e0:	b508      	push	{r3, lr}
 80a32e2:	4b02      	ldr	r3, [pc, #8]	; (80a32ec <HAL_USB_USART_Send_Data+0xc>)
 80a32e4:	681b      	ldr	r3, [r3, #0]
 80a32e6:	69db      	ldr	r3, [r3, #28]
 80a32e8:	9301      	str	r3, [sp, #4]
 80a32ea:	bd08      	pop	{r3, pc}
 80a32ec:	080601d8 	.word	0x080601d8

080a32f0 <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a32f0:	b508      	push	{r3, lr}
 80a32f2:	4b02      	ldr	r3, [pc, #8]	; (80a32fc <HAL_USB_USART_Flush_Data+0xc>)
 80a32f4:	681b      	ldr	r3, [r3, #0]
 80a32f6:	6a1b      	ldr	r3, [r3, #32]
 80a32f8:	9301      	str	r3, [sp, #4]
 80a32fa:	bd08      	pop	{r3, pc}
 80a32fc:	080601d8 	.word	0x080601d8

080a3300 <system_mode>:
#include "system_setup.h"
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
 80a3300:	b508      	push	{r3, lr}
 80a3302:	4b02      	ldr	r3, [pc, #8]	; (80a330c <system_mode+0xc>)
 80a3304:	681b      	ldr	r3, [r3, #0]
 80a3306:	681b      	ldr	r3, [r3, #0]
 80a3308:	9301      	str	r3, [sp, #4]
 80a330a:	bd08      	pop	{r3, pc}
 80a330c:	080601a4 	.word	0x080601a4

080a3310 <set_system_mode>:
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a3310:	b508      	push	{r3, lr}
 80a3312:	4b02      	ldr	r3, [pc, #8]	; (80a331c <set_system_mode+0xc>)
 80a3314:	681b      	ldr	r3, [r3, #0]
 80a3316:	685b      	ldr	r3, [r3, #4]
 80a3318:	9301      	str	r3, [sp, #4]
 80a331a:	bd08      	pop	{r3, pc}
 80a331c:	080601a4 	.word	0x080601a4

080a3320 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a3320:	b508      	push	{r3, lr}
 80a3322:	4b02      	ldr	r3, [pc, #8]	; (80a332c <system_delay_ms+0xc>)
 80a3324:	681b      	ldr	r3, [r3, #0]
 80a3326:	695b      	ldr	r3, [r3, #20]
 80a3328:	9301      	str	r3, [sp, #4]
 80a332a:	bd08      	pop	{r3, pc}
 80a332c:	080601a4 	.word	0x080601a4

080a3330 <system_thread_set_state>:
DYNALIB_FN(6, system, system_sleep, void(Spark_Sleep_TypeDef, long, uint32_t, void*))
DYNALIB_FN(7, system, system_sleep_pin, void(uint16_t, uint16_t, long, uint32_t, void*))
DYNALIB_FN(8, system, system_subscribe_event, int(system_event_t, system_event_handler_t*, void*))
DYNALIB_FN(9, system, system_unsubscribe_event, void(system_event_t, system_event_handler_t*, void*))
DYNALIB_FN(10, system, system_button_pushed_duration, uint16_t(uint8_t, void*))
DYNALIB_FN(11, system, system_thread_set_state, void(spark::feature::State, void*))
 80a3330:	b508      	push	{r3, lr}
 80a3332:	4b02      	ldr	r3, [pc, #8]	; (80a333c <system_thread_set_state+0xc>)
 80a3334:	681b      	ldr	r3, [r3, #0]
 80a3336:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a3338:	9301      	str	r3, [sp, #4]
 80a333a:	bd08      	pop	{r3, pc}
 80a333c:	080601a4 	.word	0x080601a4

080a3340 <system_thread_get_state>:
DYNALIB_FN(18, system, Spark_Finish_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))

DYNALIB_FN(19, system, application_thread_current, uint8_t(void*))
DYNALIB_FN(20, system, system_thread_current, uint8_t(void*))
DYNALIB_FN(21, system, application_thread_invoke, uint8_t(void(*)(void*), void*, void*))
DYNALIB_FN(22, system, system_thread_get_state, spark::feature::State(void*))
 80a3340:	b508      	push	{r3, lr}
 80a3342:	4b02      	ldr	r3, [pc, #8]	; (80a334c <system_thread_get_state+0xc>)
 80a3344:	681b      	ldr	r3, [r3, #0]
 80a3346:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a3348:	9301      	str	r3, [sp, #4]
 80a334a:	bd08      	pop	{r3, pc}
 80a334c:	080601a4 	.word	0x080601a4

080a3350 <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a3350:	b508      	push	{r3, lr}
 80a3352:	4b03      	ldr	r3, [pc, #12]	; (80a3360 <system_ctrl_set_app_request_handler+0x10>)
 80a3354:	681b      	ldr	r3, [r3, #0]
 80a3356:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a335a:	9301      	str	r3, [sp, #4]
 80a335c:	bd08      	pop	{r3, pc}
 80a335e:	0000      	.short	0x0000
 80a3360:	080601a4 	.word	0x080601a4

080a3364 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a3364:	b508      	push	{r3, lr}
 80a3366:	4b03      	ldr	r3, [pc, #12]	; (80a3374 <system_ctrl_set_result+0x10>)
 80a3368:	681b      	ldr	r3, [r3, #0]
 80a336a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a336e:	9301      	str	r3, [sp, #4]
 80a3370:	bd08      	pop	{r3, pc}
 80a3372:	0000      	.short	0x0000
 80a3374:	080601a4 	.word	0x080601a4

080a3378 <network_ready>:

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a3378:	b508      	push	{r3, lr}
 80a337a:	4b02      	ldr	r3, [pc, #8]	; (80a3384 <network_ready+0xc>)
 80a337c:	681b      	ldr	r3, [r3, #0]
 80a337e:	691b      	ldr	r3, [r3, #16]
 80a3380:	9301      	str	r3, [sp, #4]
 80a3382:	bd08      	pop	{r3, pc}
 80a3384:	080601c8 	.word	0x080601c8

080a3388 <spark_process>:

DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
DYNALIB_FN(2, system_cloud, spark_process, void(void))
 80a3388:	b508      	push	{r3, lr}
 80a338a:	4b02      	ldr	r3, [pc, #8]	; (80a3394 <spark_process+0xc>)
 80a338c:	681b      	ldr	r3, [r3, #0]
 80a338e:	689b      	ldr	r3, [r3, #8]
 80a3390:	9301      	str	r3, [sp, #4]
 80a3392:	bd08      	pop	{r3, pc}
 80a3394:	080601cc 	.word	0x080601cc

080a3398 <spark_cloud_flag_connected>:
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
 80a3398:	b508      	push	{r3, lr}
 80a339a:	4b02      	ldr	r3, [pc, #8]	; (80a33a4 <spark_cloud_flag_connected+0xc>)
 80a339c:	681b      	ldr	r3, [r3, #0]
 80a339e:	695b      	ldr	r3, [r3, #20]
 80a33a0:	9301      	str	r3, [sp, #4]
 80a33a2:	bd08      	pop	{r3, pc}
 80a33a4:	080601cc 	.word	0x080601cc

080a33a8 <spark_sync_time_pending>:
DYNALIB_FN(7, system_cloud, spark_deviceID, String(void))
DYNALIB_FN(8, system_cloud, spark_send_event, bool(const char*, const char*, int, uint32_t, void*))
DYNALIB_FN(9, system_cloud, spark_subscribe, bool(const char*, EventHandler, void*, Spark_Subscription_Scope_TypeDef, const char*, void*))
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
 80a33a8:	b508      	push	{r3, lr}
 80a33aa:	4b02      	ldr	r3, [pc, #8]	; (80a33b4 <spark_sync_time_pending+0xc>)
 80a33ac:	681b      	ldr	r3, [r3, #0]
 80a33ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a33b0:	9301      	str	r3, [sp, #4]
 80a33b2:	bd08      	pop	{r3, pc}
 80a33b4:	080601cc 	.word	0x080601cc

080a33b8 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a33b8:	b508      	push	{r3, lr}
 80a33ba:	4b02      	ldr	r3, [pc, #8]	; (80a33c4 <spark_set_random_seed_from_cloud_handler+0xc>)
 80a33bc:	681b      	ldr	r3, [r3, #0]
 80a33be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a33c0:	9301      	str	r3, [sp, #4]
 80a33c2:	bd08      	pop	{r3, pc}
 80a33c4:	080601cc 	.word	0x080601cc

080a33c8 <malloc>:

#include "dynalib.h"

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a33c8:	b508      	push	{r3, lr}
 80a33ca:	4b02      	ldr	r3, [pc, #8]	; (80a33d4 <malloc+0xc>)
 80a33cc:	681b      	ldr	r3, [r3, #0]
 80a33ce:	681b      	ldr	r3, [r3, #0]
 80a33d0:	9301      	str	r3, [sp, #4]
 80a33d2:	bd08      	pop	{r3, pc}
 80a33d4:	080601a0 	.word	0x080601a0

080a33d8 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a33d8:	b508      	push	{r3, lr}
 80a33da:	4b02      	ldr	r3, [pc, #8]	; (80a33e4 <free+0xc>)
 80a33dc:	681b      	ldr	r3, [r3, #0]
 80a33de:	685b      	ldr	r3, [r3, #4]
 80a33e0:	9301      	str	r3, [sp, #4]
 80a33e2:	bd08      	pop	{r3, pc}
 80a33e4:	080601a0 	.word	0x080601a0

080a33e8 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a33e8:	b508      	push	{r3, lr}
 80a33ea:	4b02      	ldr	r3, [pc, #8]	; (80a33f4 <realloc+0xc>)
 80a33ec:	681b      	ldr	r3, [r3, #0]
 80a33ee:	689b      	ldr	r3, [r3, #8]
 80a33f0:	9301      	str	r3, [sp, #4]
 80a33f2:	bd08      	pop	{r3, pc}
 80a33f4:	080601a0 	.word	0x080601a0

080a33f8 <siscanf>:
DYNALIB_FN(3, rt, sprintf, int(char*, const char*, ...))
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
 80a33f8:	b508      	push	{r3, lr}
 80a33fa:	4b02      	ldr	r3, [pc, #8]	; (80a3404 <siscanf+0xc>)
 80a33fc:	681b      	ldr	r3, [r3, #0]
 80a33fe:	699b      	ldr	r3, [r3, #24]
 80a3400:	9301      	str	r3, [sp, #4]
 80a3402:	bd08      	pop	{r3, pc}
 80a3404:	080601a0 	.word	0x080601a0

080a3408 <vsnprintf>:
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a3408:	b508      	push	{r3, lr}
 80a340a:	4b02      	ldr	r3, [pc, #8]	; (80a3414 <vsnprintf+0xc>)
 80a340c:	681b      	ldr	r3, [r3, #0]
 80a340e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a3410:	9301      	str	r3, [sp, #4]
 80a3412:	bd08      	pop	{r3, pc}
 80a3414:	080601a0 	.word	0x080601a0

080a3418 <abort>:
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
 80a3418:	b508      	push	{r3, lr}
 80a341a:	4b02      	ldr	r3, [pc, #8]	; (80a3424 <abort+0xc>)
 80a341c:	681b      	ldr	r3, [r3, #0]
 80a341e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a3420:	9301      	str	r3, [sp, #4]
 80a3422:	bd08      	pop	{r3, pc}
 80a3424:	080601a0 	.word	0x080601a0

080a3428 <_malloc_r>:
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
 80a3428:	b508      	push	{r3, lr}
 80a342a:	4b02      	ldr	r3, [pc, #8]	; (80a3434 <_malloc_r+0xc>)
 80a342c:	681b      	ldr	r3, [r3, #0]
 80a342e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3430:	9301      	str	r3, [sp, #4]
 80a3432:	bd08      	pop	{r3, pc}
 80a3434:	080601a0 	.word	0x080601a0

080a3438 <_ZN8SPIClassD1Ev>:
  Mutex mutex_;
#endif

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a3438:	4770      	bx	lr

080a343a <_ZN8SPIClassD0Ev>:
 80a343a:	b510      	push	{r4, lr}
 80a343c:	4604      	mov	r4, r0
 80a343e:	f7fc fe2e 	bl	80a009e <_ZdlPv>
 80a3442:	4620      	mov	r0, r4
 80a3444:	bd10      	pop	{r4, pc}
	...

080a3448 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
  if (!info->enabled || info->default_settings)
    return particle::__SPISettings();
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a3448:	b570      	push	{r4, r5, r6, lr}
 80a344a:	4604      	mov	r4, r0
 80a344c:	460e      	mov	r6, r1
 80a344e:	4b07      	ldr	r3, [pc, #28]	; (80a346c <_ZN8SPIClassC1E17HAL_SPI_Interface+0x24>)
    Mutex(os_mutex_t handle) : handle_(handle) {}

    /**
     * Creates a new mutex.
     */
    Mutex() : handle_(nullptr)
 80a3450:	2500      	movs	r5, #0
 80a3452:	6003      	str	r3, [r0, #0]
 80a3454:	f840 5f0c 	str.w	r5, [r0, #12]!
    {
        os_mutex_create(&handle_);
 80a3458:	f7ff fe48 	bl	80a30ec <os_mutex_create>
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a345c:	4630      	mov	r0, r6
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
{
  _spi = spi;
 80a345e:	7126      	strb	r6, [r4, #4]
  HAL_SPI_Init(_spi);
 80a3460:	f7ff fdd4 	bl	80a300c <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a3464:	60a5      	str	r5, [r4, #8]
}
 80a3466:	4620      	mov	r0, r4
 80a3468:	bd70      	pop	{r4, r5, r6, pc}
 80a346a:	bf00      	nop
 80a346c:	080a59e0 	.word	0x080a59e0

080a3470 <_ZN8SPIClass5beginEv>:

void SPIClass::begin()
{
    // todo - fetch default pin from HAL
  HAL_SPI_Begin(_spi, SPI_DEFAULT_SS);
 80a3470:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80a3474:	7900      	ldrb	r0, [r0, #4]
 80a3476:	f7ff bdb9 	b.w	80a2fec <HAL_SPI_Begin>

080a347a <_ZN8SPIClass14endTransactionEv>:
        }
    }

    void lock() { os_mutex_lock(handle_); }
    bool trylock() { return os_mutex_trylock(handle_)==0; }
    void unlock() { os_mutex_unlock(handle_); }
 80a347a:	68c0      	ldr	r0, [r0, #12]
 80a347c:	f7ff be46 	b.w	80a310c <os_mutex_unlock>

080a3480 <_ZN8SPIClass19computeClockDividerEjjRhRj>:

void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1;        // div2 is the first
 80a3480:	0840      	lsrs	r0, r0, #1
        HAL_SPI_Set_Clock_Divider(_spi, rate);
    }
}

void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock)
{
 80a3482:	b530      	push	{r4, r5, lr}
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1;        // div2 is the first
 80a3484:	6018      	str	r0, [r3, #0]
 80a3486:	2400      	movs	r4, #0
    while (clock > targetSpeed && scale<7) {
 80a3488:	6818      	ldr	r0, [r3, #0]
 80a348a:	b2e5      	uxtb	r5, r4
 80a348c:	4288      	cmp	r0, r1
 80a348e:	d906      	bls.n	80a349e <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1e>
 80a3490:	3401      	adds	r4, #1
 80a3492:	2c08      	cmp	r4, #8
 80a3494:	d002      	beq.n	80a349c <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1c>
        clock >>= 1;
 80a3496:	0840      	lsrs	r0, r0, #1
 80a3498:	6018      	str	r0, [r3, #0]
void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1;        // div2 is the first
    while (clock > targetSpeed && scale<7) {
 80a349a:	e7f5      	b.n	80a3488 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x8>
 80a349c:	2507      	movs	r5, #7
        clock >>= 1;
        scale++;
    }
    divider = clock_divisors[scale];
 80a349e:	4b02      	ldr	r3, [pc, #8]	; (80a34a8 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x28>)
 80a34a0:	5d5b      	ldrb	r3, [r3, r5]
 80a34a2:	7013      	strb	r3, [r2, #0]
 80a34a4:	bd30      	pop	{r4, r5, pc}
 80a34a6:	bf00      	nop
 80a34a8:	080a59e8 	.word	0x080a59e8

080a34ac <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>:
  lock();
  return 0;
}

int32_t SPIClass::beginTransaction(const particle::__SPISettings& settings)
{
 80a34ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a34b0:	4680      	mov	r8, r0
 80a34b2:	b08f      	sub	sp, #60	; 0x3c
            os_mutex_destroy(handle_);
            handle_ = nullptr;
        }
    }

    void lock() { os_mutex_lock(handle_); }
 80a34b4:	68c0      	ldr	r0, [r0, #12]
 80a34b6:	460f      	mov	r7, r1
 80a34b8:	f7ff fe20 	bl	80a30fc <os_mutex_lock>
  lock();
  // Get Current SPISettings
  hal_spi_info_t info;
  querySpiInfo(_spi, &info);
 80a34bc:	f898 4004 	ldrb.w	r4, [r8, #4]
#include "core_hal.h"
#include "spark_macros.h"

static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
  memset(info, 0, sizeof(hal_spi_info_t));
 80a34c0:	2214      	movs	r2, #20
 80a34c2:	2100      	movs	r1, #0
 80a34c4:	a809      	add	r0, sp, #36	; 0x24
 80a34c6:	f001 fd25 	bl	80a4f14 <memset>
  info->version = HAL_SPI_INFO_VERSION_1;
 80a34ca:	230b      	movs	r3, #11
  HAL_SPI_Info(spi, info, nullptr);
 80a34cc:	4620      	mov	r0, r4
 80a34ce:	2200      	movs	r2, #0
 80a34d0:	a909      	add	r1, sp, #36	; 0x24
#include "spark_macros.h"

static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
  memset(info, 0, sizeof(hal_spi_info_t));
  info->version = HAL_SPI_INFO_VERSION_1;
 80a34d2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
  HAL_SPI_Info(spi, info, nullptr);
 80a34d6:	f7ff fda9 	bl	80a302c <HAL_SPI_Info>
}

static particle::__SPISettings spiSettingsFromSpiInfo(hal_spi_info_t* info)
{
  if (!info->enabled || info->default_settings)
 80a34da:	f89d 402d 	ldrb.w	r4, [sp, #45]	; 0x2d
 80a34de:	b14c      	cbz	r4, 80a34f4 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x48>
 80a34e0:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
 80a34e4:	b92d      	cbnz	r5, 80a34f2 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x46>
    return particle::__SPISettings();
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
 80a34e6:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80a34e8:	f89d 9034 	ldrb.w	r9, [sp, #52]	; 0x34
 80a34ec:	f89d 4035 	ldrb.w	r4, [sp, #53]	; 0x35
 80a34f0:	e003      	b.n	80a34fa <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x4e>
      dataMode_{dataMode}
  {
  }

  __SPISettings()
  {
 80a34f2:	2400      	movs	r4, #0
 80a34f4:	46a1      	mov	r9, r4
 80a34f6:	4626      	mov	r6, r4
 80a34f8:	2501      	movs	r5, #1
 80a34fa:	793b      	ldrb	r3, [r7, #4]
  }

  bool operator==(const __SPISettings& other) const
  {
    if (default_ && other.default_)
 80a34fc:	b10d      	cbz	r5, 80a3502 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x56>
 80a34fe:	2b00      	cmp	r3, #0
 80a3500:	d140      	bne.n	80a3584 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd8>
      return true;

    if (default_ == other.default_ &&
 80a3502:	429d      	cmp	r5, r3
 80a3504:	d10b      	bne.n	80a351e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x72>
 80a3506:	68ba      	ldr	r2, [r7, #8]
 80a3508:	42b2      	cmp	r2, r6
 80a350a:	d108      	bne.n	80a351e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x72>
        clock_ == other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
 80a350c:	f88d 9020 	strb.w	r9, [sp, #32]
 80a3510:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
 80a3514:	f8bd 1020 	ldrh.w	r1, [sp, #32]
 80a3518:	89ba      	ldrh	r2, [r7, #12]
 80a351a:	4291      	cmp	r1, r2
 80a351c:	d032      	beq.n	80a3584 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd8>
  querySpiInfo(_spi, &info);
  particle::__SPISettings current = spiSettingsFromSpiInfo(&info);
  // If they differ, reconfigure SPI peripheral
  if (settings != current)
  {
    if (!settings.default_) {
 80a351e:	bb23      	cbnz	r3, 80a356a <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xbe>
      uint8_t divisor = 0;
 80a3520:	f88d 300f 	strb.w	r3, [sp, #15]
      unsigned int clock;
      computeClockDivider((unsigned int)info.system_clock, settings.clock_, divisor, clock);
 80a3524:	f10d 020f 	add.w	r2, sp, #15
 80a3528:	ab04      	add	r3, sp, #16
 80a352a:	68b9      	ldr	r1, [r7, #8]
 80a352c:	980a      	ldr	r0, [sp, #40]	; 0x28
 80a352e:	f7ff ffa7 	bl	80a3480 <_ZN8SPIClass19computeClockDividerEjjRhRj>
 80a3532:	793b      	ldrb	r3, [r7, #4]
    return false;
  }

  bool operator<=(const __SPISettings& other) const
  {
    if (default_ && other.default_)
 80a3534:	b105      	cbz	r5, 80a3538 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x8c>
 80a3536:	bb13      	cbnz	r3, 80a357e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd2>
      return true;

    if (default_ == other.default_ &&
 80a3538:	42ab      	cmp	r3, r5
 80a353a:	d009      	beq.n	80a3550 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xa4>

      if (!(current <= settings && clock == current.clock_)) {
        HAL_SPI_Set_Settings(_spi, 0, divisor, settings.bitOrder_, settings.dataMode_, nullptr);
 80a353c:	2100      	movs	r1, #0
 80a353e:	7b3b      	ldrb	r3, [r7, #12]
 80a3540:	9101      	str	r1, [sp, #4]
 80a3542:	7b7c      	ldrb	r4, [r7, #13]
 80a3544:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80a3548:	f898 0004 	ldrb.w	r0, [r8, #4]
 80a354c:	9400      	str	r4, [sp, #0]
 80a354e:	e013      	b.n	80a3578 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xcc>
 80a3550:	68bb      	ldr	r3, [r7, #8]
 80a3552:	42b3      	cmp	r3, r6
 80a3554:	d3f2      	bcc.n	80a353c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x90>
        clock_ <= other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
 80a3556:	f88d 9020 	strb.w	r9, [sp, #32]
 80a355a:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
 80a355e:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 80a3562:	89bb      	ldrh	r3, [r7, #12]
 80a3564:	429a      	cmp	r2, r3
 80a3566:	d1e9      	bne.n	80a353c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x90>
 80a3568:	e009      	b.n	80a357e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd2>
      }
    } else {
      HAL_SPI_Set_Settings(_spi, 1, 0, 0, 0, nullptr);
 80a356a:	2300      	movs	r3, #0
 80a356c:	461a      	mov	r2, r3
 80a356e:	f898 0004 	ldrb.w	r0, [r8, #4]
 80a3572:	9301      	str	r3, [sp, #4]
 80a3574:	9300      	str	r3, [sp, #0]
 80a3576:	2101      	movs	r1, #1
 80a3578:	f7ff fd70 	bl	80a305c <HAL_SPI_Set_Settings>
 80a357c:	e002      	b.n	80a3584 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd8>
    if (!settings.default_) {
      uint8_t divisor = 0;
      unsigned int clock;
      computeClockDivider((unsigned int)info.system_clock, settings.clock_, divisor, clock);

      if (!(current <= settings && clock == current.clock_)) {
 80a357e:	9b04      	ldr	r3, [sp, #16]
 80a3580:	42b3      	cmp	r3, r6
 80a3582:	d1db      	bne.n	80a353c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x90>
      HAL_SPI_Set_Settings(_spi, 1, 0, 0, 0, nullptr);
    }
  }

  return 0;
}
 80a3584:	2000      	movs	r0, #0
 80a3586:	b00f      	add	sp, #60	; 0x3c
 80a3588:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080a358c <_ZN8SPIClass8transferEh>:
    HAL_SPI_Set_Clock_Divider(_spi, rate);
    return clock;
}

byte SPIClass::transfer(byte _data)
{
 80a358c:	b508      	push	{r3, lr}
  return HAL_SPI_Send_Receive_Data(_spi, _data);
 80a358e:	7900      	ldrb	r0, [r0, #4]
 80a3590:	f7ff fd34 	bl	80a2ffc <HAL_SPI_Send_Receive_Data>
}
 80a3594:	b2c0      	uxtb	r0, r0
 80a3596:	bd08      	pop	{r3, pc}

080a3598 <_ZN8SPIClass8transferEPvS0_jPFvvE>:

void SPIClass::transfer(void* tx_buffer, void* rx_buffer, size_t length, wiring_spi_dma_transfercomplete_callback_t user_callback)
{
 80a3598:	b530      	push	{r4, r5, lr}
 80a359a:	b087      	sub	sp, #28
 80a359c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80a359e:	4604      	mov	r4, r0
  HAL_SPI_DMA_Transfer(_spi, tx_buffer, rx_buffer, length, user_callback);
 80a35a0:	7900      	ldrb	r0, [r0, #4]
 80a35a2:	9500      	str	r5, [sp, #0]
 80a35a4:	f7ff fd4a 	bl	80a303c <HAL_SPI_DMA_Transfer>
  if (user_callback == NULL) {
 80a35a8:	b93d      	cbnz	r5, 80a35ba <_ZN8SPIClass8transferEPvS0_jPFvvE+0x22>
    HAL_SPI_TransferStatus st;
    do {
      HAL_SPI_DMA_Transfer_Status(_spi, &st);
 80a35aa:	a902      	add	r1, sp, #8
 80a35ac:	7920      	ldrb	r0, [r4, #4]
 80a35ae:	f7ff fd4d 	bl	80a304c <HAL_SPI_DMA_Transfer_Status>
void SPIClass::transfer(void* tx_buffer, void* rx_buffer, size_t length, wiring_spi_dma_transfercomplete_callback_t user_callback)
{
  HAL_SPI_DMA_Transfer(_spi, tx_buffer, rx_buffer, length, user_callback);
  if (user_callback == NULL) {
    HAL_SPI_TransferStatus st;
    do {
 80a35b2:	f89d 3014 	ldrb.w	r3, [sp, #20]
 80a35b6:	07db      	lsls	r3, r3, #31
 80a35b8:	d4f7      	bmi.n	80a35aa <_ZN8SPIClass8transferEPvS0_jPFvvE+0x12>
      HAL_SPI_DMA_Transfer_Status(_spi, &st);
    } while(st.transfer_ongoing);
  }
}
 80a35ba:	b007      	add	sp, #28
 80a35bc:	bd30      	pop	{r4, r5, pc}

080a35be <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a35be:	7900      	ldrb	r0, [r0, #4]
 80a35c0:	f7ff bd2c 	b.w	80a301c <HAL_SPI_Is_Enabled>

080a35c4 <_GLOBAL__sub_I_System>:
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a35c4:	f64f 739c 	movw	r3, #65436	; 0xff9c
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
}
 80a35c8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a35ca:	4c0d      	ldr	r4, [pc, #52]	; (80a3600 <_GLOBAL__sub_I_System+0x3c>)
 80a35cc:	2500      	movs	r5, #0
 80a35ce:	8063      	strh	r3, [r4, #2]
 80a35d0:	f64f 73ff 	movw	r3, #65535	; 0xffff

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a35d4:	4628      	mov	r0, r5
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a35d6:	80a3      	strh	r3, [r4, #4]
 80a35d8:	7025      	strb	r5, [r4, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a35da:	f7ff fe99 	bl	80a3310 <set_system_mode>
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
 80a35de:	a802      	add	r0, sp, #8
 80a35e0:	f840 5d04 	str.w	r5, [r0, #-4]!
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
 80a35e4:	462a      	mov	r2, r5
 80a35e6:	4629      	mov	r1, r5
 80a35e8:	f7ff fd68 	bl	80a30bc <HAL_Core_Get_Last_Reset_Info>
        return reason;
 80a35ec:	9b01      	ldr	r3, [sp, #4]
class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
        if (resetReason() == RESET_REASON_POWER_MANAGEMENT) {
 80a35ee:	2b1e      	cmp	r3, #30
 80a35f0:	d104      	bne.n	80a35fc <_GLOBAL__sub_I_System+0x38>
            // Woken up from standby mode
            sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
 80a35f2:	2303      	movs	r3, #3
 80a35f4:	7023      	strb	r3, [r4, #0]
 80a35f6:	2311      	movs	r3, #17
 80a35f8:	8065      	strh	r5, [r4, #2]
 80a35fa:	80a3      	strh	r3, [r4, #4]
 80a35fc:	b003      	add	sp, #12
 80a35fe:	bd30      	pop	{r4, r5, pc}
 80a3600:	20000b1e 	.word	0x20000b1e

080a3604 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a3604:	b510      	push	{r4, lr}
 80a3606:	4604      	mov	r4, r0
{
	free(buffer);
 80a3608:	6800      	ldr	r0, [r0, #0]
 80a360a:	f7ff fee5 	bl	80a33d8 <free>
}
 80a360e:	4620      	mov	r0, r4
 80a3610:	bd10      	pop	{r4, pc}

080a3612 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a3612:	b510      	push	{r4, lr}
 80a3614:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a3616:	6800      	ldr	r0, [r0, #0]
 80a3618:	b108      	cbz	r0, 80a361e <_ZN6String10invalidateEv+0xc>
 80a361a:	f7ff fedd 	bl	80a33d8 <free>
	buffer = NULL;
 80a361e:	2300      	movs	r3, #0
 80a3620:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a3622:	60a3      	str	r3, [r4, #8]
 80a3624:	6063      	str	r3, [r4, #4]
 80a3626:	bd10      	pop	{r4, pc}

080a3628 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a3628:	b538      	push	{r3, r4, r5, lr}
 80a362a:	4604      	mov	r4, r0
 80a362c:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a362e:	6800      	ldr	r0, [r0, #0]
 80a3630:	3101      	adds	r1, #1
 80a3632:	f7ff fed9 	bl	80a33e8 <realloc>
	if (newbuffer) {
 80a3636:	b110      	cbz	r0, 80a363e <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a3638:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a363c:	2001      	movs	r0, #1
	}
	return 0;
}
 80a363e:	bd38      	pop	{r3, r4, r5, pc}

080a3640 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a3640:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a3642:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a3644:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a3646:	b113      	cbz	r3, 80a364e <_ZN6String7reserveEj+0xe>
 80a3648:	6843      	ldr	r3, [r0, #4]
 80a364a:	428b      	cmp	r3, r1
 80a364c:	d207      	bcs.n	80a365e <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a364e:	4620      	mov	r0, r4
 80a3650:	f7ff ffea 	bl	80a3628 <_ZN6String12changeBufferEj>
 80a3654:	b120      	cbz	r0, 80a3660 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a3656:	68a3      	ldr	r3, [r4, #8]
 80a3658:	b90b      	cbnz	r3, 80a365e <_ZN6String7reserveEj+0x1e>
 80a365a:	6822      	ldr	r2, [r4, #0]
 80a365c:	7013      	strb	r3, [r2, #0]
 80a365e:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a3660:	bd10      	pop	{r4, pc}

080a3662 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a3662:	b570      	push	{r4, r5, r6, lr}
 80a3664:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a3666:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a3668:	4604      	mov	r4, r0
 80a366a:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a366c:	f7ff ffe8 	bl	80a3640 <_ZN6String7reserveEj>
 80a3670:	b918      	cbnz	r0, 80a367a <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a3672:	4620      	mov	r0, r4
 80a3674:	f7ff ffcd 	bl	80a3612 <_ZN6String10invalidateEv>
		return *this;
 80a3678:	e009      	b.n	80a368e <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
 80a367a:	462a      	mov	r2, r5
 80a367c:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
 80a367e:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a3680:	6820      	ldr	r0, [r4, #0]
 80a3682:	f001 fc3c 	bl	80a4efe <memcpy>
	buffer[len] = 0;
 80a3686:	6822      	ldr	r2, [r4, #0]
 80a3688:	68a3      	ldr	r3, [r4, #8]
 80a368a:	2100      	movs	r1, #0
 80a368c:	54d1      	strb	r1, [r2, r3]
	return *this;
}
 80a368e:	4620      	mov	r0, r4
 80a3690:	bd70      	pop	{r4, r5, r6, pc}

080a3692 <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a3692:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a3694:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a3696:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a3698:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a369a:	6043      	str	r3, [r0, #4]
	len = 0;
 80a369c:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a369e:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
 80a36a0:	460d      	mov	r5, r1
 80a36a2:	b139      	cbz	r1, 80a36b4 <_ZN6StringC1EPK19__FlashStringHelper+0x22>
 80a36a4:	4608      	mov	r0, r1
 80a36a6:	f001 fc85 	bl	80a4fb4 <strlen>
 80a36aa:	4629      	mov	r1, r5
 80a36ac:	4602      	mov	r2, r0
 80a36ae:	4620      	mov	r0, r4
 80a36b0:	f7ff ffd7 	bl	80a3662 <_ZN6String4copyEPKcj>
}
 80a36b4:	4620      	mov	r0, r4
 80a36b6:	bd38      	pop	{r3, r4, r5, pc}

080a36b8 <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a36b8:	4288      	cmp	r0, r1
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
 80a36ba:	b510      	push	{r4, lr}
 80a36bc:	460b      	mov	r3, r1
 80a36be:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a36c0:	d007      	beq.n	80a36d2 <_ZN6StringaSERKS_+0x1a>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a36c2:	6809      	ldr	r1, [r1, #0]
 80a36c4:	b119      	cbz	r1, 80a36ce <_ZN6StringaSERKS_+0x16>
 80a36c6:	689a      	ldr	r2, [r3, #8]
 80a36c8:	f7ff ffcb 	bl	80a3662 <_ZN6String4copyEPKcj>
 80a36cc:	e001      	b.n	80a36d2 <_ZN6StringaSERKS_+0x1a>
	else invalidate();
 80a36ce:	f7ff ffa0 	bl	80a3612 <_ZN6String10invalidateEv>

	return *this;
}
 80a36d2:	4620      	mov	r0, r4
 80a36d4:	bd10      	pop	{r4, pc}

080a36d6 <_ZN6StringC1ERKS_>:
{
	init();
	if (cstr) copy(cstr, length);
}

String::String(const String &value)
 80a36d6:	b510      	push	{r4, lr}
 80a36d8:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a36da:	2300      	movs	r3, #0
 80a36dc:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a36de:	6043      	str	r3, [r0, #4]
	len = 0;
 80a36e0:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a36e2:	7303      	strb	r3, [r0, #12]
}

String::String(const String &value)
{
	init();
	*this = value;
 80a36e4:	f7ff ffe8 	bl	80a36b8 <_ZN6StringaSERKS_>
}
 80a36e8:	4620      	mov	r0, r4
 80a36ea:	bd10      	pop	{r4, pc}

080a36ec <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
 80a36ec:	b538      	push	{r3, r4, r5, lr}
 80a36ee:	4605      	mov	r5, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a36f0:	460c      	mov	r4, r1
 80a36f2:	b141      	cbz	r1, 80a3706 <_ZN6StringaSEPKc+0x1a>
 80a36f4:	4608      	mov	r0, r1
 80a36f6:	f001 fc5d 	bl	80a4fb4 <strlen>
 80a36fa:	4621      	mov	r1, r4
 80a36fc:	4602      	mov	r2, r0
 80a36fe:	4628      	mov	r0, r5
 80a3700:	f7ff ffaf 	bl	80a3662 <_ZN6String4copyEPKcj>
 80a3704:	e001      	b.n	80a370a <_ZN6StringaSEPKc+0x1e>
	else invalidate();
 80a3706:	f7ff ff84 	bl	80a3612 <_ZN6String10invalidateEv>

	return *this;
}
 80a370a:	4628      	mov	r0, r5
 80a370c:	bd38      	pop	{r3, r4, r5, pc}

080a370e <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a370e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3710:	4606      	mov	r6, r0
 80a3712:	460d      	mov	r5, r1
 80a3714:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a3716:	2400      	movs	r4, #0
  while (size--) {
 80a3718:	42bd      	cmp	r5, r7
 80a371a:	d00c      	beq.n	80a3736 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a371c:	6833      	ldr	r3, [r6, #0]
 80a371e:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a3722:	689b      	ldr	r3, [r3, #8]
 80a3724:	4630      	mov	r0, r6
 80a3726:	4798      	blx	r3
     if (chunk>=0)
 80a3728:	2800      	cmp	r0, #0
 80a372a:	db01      	blt.n	80a3730 <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a372c:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 80a372e:	e7f3      	b.n	80a3718 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a3730:	2c00      	cmp	r4, #0
 80a3732:	bf08      	it	eq
 80a3734:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a3736:	4620      	mov	r0, r4
 80a3738:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a373a <_ZN5Print5printEPKc>:
 80a373a:	b508      	push	{r3, lr}
 80a373c:	f7fe fe00 	bl	80a2340 <_ZN5Print5writeEPKc>
 80a3740:	bd08      	pop	{r3, pc}

080a3742 <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a3742:	6803      	ldr	r3, [r0, #0]
 80a3744:	689b      	ldr	r3, [r3, #8]
 80a3746:	4718      	bx	r3

080a3748 <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a3748:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a374a:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a374c:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a374e:	f7ff fff8 	bl	80a3742 <_ZN5Print5printEc>
  n += print('\n');
 80a3752:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
 80a3754:	4604      	mov	r4, r0
  n += print('\n');
 80a3756:	4628      	mov	r0, r5
 80a3758:	f7ff fff3 	bl	80a3742 <_ZN5Print5printEc>
  return n;
}
 80a375c:	4420      	add	r0, r4
 80a375e:	bd38      	pop	{r3, r4, r5, pc}

080a3760 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a3760:	b538      	push	{r3, r4, r5, lr}
 80a3762:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a3764:	f7fe fdec 	bl	80a2340 <_ZN5Print5writeEPKc>
 80a3768:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a376a:	4628      	mov	r0, r5
 80a376c:	f7ff ffec 	bl	80a3748 <_ZN5Print7printlnEv>
  return n;
}
 80a3770:	4420      	add	r0, r4
 80a3772:	bd38      	pop	{r3, r4, r5, pc}

080a3774 <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a3774:	2a01      	cmp	r2, #1
 80a3776:	bf98      	it	ls
 80a3778:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a377a:	b530      	push	{r4, r5, lr}
 80a377c:	460b      	mov	r3, r1
 80a377e:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a3780:	2100      	movs	r1, #0
 80a3782:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a3786:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a378a:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a378e:	fb05 3312 	mls	r3, r5, r2, r3
 80a3792:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a3794:	2b09      	cmp	r3, #9
 80a3796:	bf94      	ite	ls
 80a3798:	3330      	addls	r3, #48	; 0x30
 80a379a:	3337      	addhi	r3, #55	; 0x37
 80a379c:	b2db      	uxtb	r3, r3
 80a379e:	4621      	mov	r1, r4
 80a37a0:	f804 3901 	strb.w	r3, [r4], #-1
 80a37a4:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a37a6:	2d00      	cmp	r5, #0
 80a37a8:	d1ef      	bne.n	80a378a <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a37aa:	f7fe fdc9 	bl	80a2340 <_ZN5Print5writeEPKc>
}
 80a37ae:	b00b      	add	sp, #44	; 0x2c
 80a37b0:	bd30      	pop	{r4, r5, pc}

080a37b2 <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a37b2:	b410      	push	{r4}
  if (base == 0) return write(n);
 80a37b4:	b922      	cbnz	r2, 80a37c0 <_ZN5Print5printEmi+0xe>
 80a37b6:	6803      	ldr	r3, [r0, #0]
 80a37b8:	b2c9      	uxtb	r1, r1
 80a37ba:	689b      	ldr	r3, [r3, #8]
  else return printNumber(n, base);
}
 80a37bc:	bc10      	pop	{r4}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a37be:	4718      	bx	r3
  else return printNumber(n, base);
 80a37c0:	b2d2      	uxtb	r2, r2
}
 80a37c2:	bc10      	pop	{r4}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a37c4:	f7ff bfd6 	b.w	80a3774 <_ZN5Print11printNumberEmh>

080a37c8 <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a37c8:	f7ff bff3 	b.w	80a37b2 <_ZN5Print5printEmi>

080a37cc <_ZN5Print11printf_implEbPKcz>:

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
 80a37cc:	b40c      	push	{r2, r3}
 80a37ce:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a37d2:	b087      	sub	sp, #28
 80a37d4:	af00      	add	r7, sp, #0
 80a37d6:	f107 0438 	add.w	r4, r7, #56	; 0x38
 80a37da:	f854 9b04 	ldr.w	r9, [r4], #4
 80a37de:	4605      	mov	r5, r0
 80a37e0:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a37e2:	4623      	mov	r3, r4
 80a37e4:	464a      	mov	r2, r9
 80a37e6:	2114      	movs	r1, #20
 80a37e8:	1d38      	adds	r0, r7, #4
size_t Print::printf_impl(bool newline, const char* format, ...)
{
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
 80a37ea:	603c      	str	r4, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a37ec:	f7ff fe0c 	bl	80a3408 <vsnprintf>
    va_end(marker);

    if (n<bufsize)
 80a37f0:	2813      	cmp	r0, #19
 80a37f2:	d805      	bhi.n	80a3800 <_ZN5Print11printf_implEbPKcz+0x34>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a37f4:	1d39      	adds	r1, r7, #4
 80a37f6:	4628      	mov	r0, r5
 80a37f8:	f7fe fda2 	bl	80a2340 <_ZN5Print5writeEPKc>
 80a37fc:	4604      	mov	r4, r0
 80a37fe:	e013      	b.n	80a3828 <_ZN5Print11printf_implEbPKcz+0x5c>
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a3800:	f100 0308 	add.w	r3, r0, #8
 80a3804:	f023 0307 	bic.w	r3, r3, #7
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
 80a3808:	46e8      	mov	r8, sp
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a380a:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
 80a380e:	1c41      	adds	r1, r0, #1
 80a3810:	4623      	mov	r3, r4
 80a3812:	464a      	mov	r2, r9
 80a3814:	4668      	mov	r0, sp
        n = print(test);
    }
    else
    {
        char bigger[n+1];
        va_start(marker, format);
 80a3816:	603c      	str	r4, [r7, #0]
        n = vsnprintf(bigger, n+1, format, marker);
 80a3818:	f7ff fdf6 	bl	80a3408 <vsnprintf>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a381c:	4669      	mov	r1, sp
 80a381e:	4628      	mov	r0, r5
 80a3820:	f7fe fd8e 	bl	80a2340 <_ZN5Print5writeEPKc>
 80a3824:	4604      	mov	r4, r0
 80a3826:	46c5      	mov	sp, r8
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
    }
    if (newline)
 80a3828:	b11e      	cbz	r6, 80a3832 <_ZN5Print11printf_implEbPKcz+0x66>
        n += println();
 80a382a:	4628      	mov	r0, r5
 80a382c:	f7ff ff8c 	bl	80a3748 <_ZN5Print7printlnEv>
 80a3830:	4404      	add	r4, r0
    return n;
}
 80a3832:	4620      	mov	r0, r4
 80a3834:	371c      	adds	r7, #28
 80a3836:	46bd      	mov	sp, r7
 80a3838:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a383c:	b002      	add	sp, #8
 80a383e:	4770      	bx	lr

080a3840 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a3840:	4a01      	ldr	r2, [pc, #4]	; (80a3848 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a3842:	4b02      	ldr	r3, [pc, #8]	; (80a384c <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a3844:	601a      	str	r2, [r3, #0]
 80a3846:	4770      	bx	lr
 80a3848:	080a5aab 	.word	0x080a5aab
 80a384c:	20000b24 	.word	0x20000b24

080a3850 <_ZL22Refresh_UnixTime_Cachel>:
}
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
 80a3850:	b5f0      	push	{r4, r5, r6, r7, lr}
    unix_time += time_zone_cache;
 80a3852:	4b14      	ldr	r3, [pc, #80]	; (80a38a4 <_ZL22Refresh_UnixTime_Cachel+0x54>)
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
 80a3854:	4f14      	ldr	r7, [pc, #80]	; (80a38a8 <_ZL22Refresh_UnixTime_Cachel+0x58>)
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
    unix_time += time_zone_cache;
 80a3856:	681e      	ldr	r6, [r3, #0]
    unix_time += dst_current_cache;
 80a3858:	4b14      	ldr	r3, [pc, #80]	; (80a38ac <_ZL22Refresh_UnixTime_Cachel+0x5c>)
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
    unix_time += time_zone_cache;
 80a385a:	4406      	add	r6, r0
    unix_time += dst_current_cache;
 80a385c:	6818      	ldr	r0, [r3, #0]
    if(unix_time != unix_time_cache)
 80a385e:	683b      	ldr	r3, [r7, #0]

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
 80a3860:	4406      	add	r6, r0
    if(unix_time != unix_time_cache)
 80a3862:	429e      	cmp	r6, r3
}
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
 80a3864:	b08b      	sub	sp, #44	; 0x2c
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
 80a3866:	d01b      	beq.n	80a38a0 <_ZL22Refresh_UnixTime_Cachel+0x50>
 80a3868:	a80a      	add	r0, sp, #40	; 0x28
 80a386a:	f840 6d28 	str.w	r6, [r0, #-40]!

/* Convert Unix/RTC time to Calendar time */
static struct tm Convert_UnixTime_To_CalendarTime(time_t unix_time)
{
	struct tm *calendar_time;
	calendar_time = localtime(&unix_time);
 80a386e:	f001 fa3f 	bl	80a4cf0 <localtime>
	calendar_time->tm_year += 1900;
	return *calendar_time;
 80a3872:	4604      	mov	r4, r0
/* Convert Unix/RTC time to Calendar time */
static struct tm Convert_UnixTime_To_CalendarTime(time_t unix_time)
{
	struct tm *calendar_time;
	calendar_time = localtime(&unix_time);
	calendar_time->tm_year += 1900;
 80a3874:	6943      	ldr	r3, [r0, #20]
	return *calendar_time;
 80a3876:	ad01      	add	r5, sp, #4
/* Convert Unix/RTC time to Calendar time */
static struct tm Convert_UnixTime_To_CalendarTime(time_t unix_time)
{
	struct tm *calendar_time;
	calendar_time = localtime(&unix_time);
	calendar_time->tm_year += 1900;
 80a3878:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 80a387c:	6143      	str	r3, [r0, #20]
	return *calendar_time;
 80a387e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a3880:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a3882:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a3884:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a3886:	f8d4 e000 	ldr.w	lr, [r4]
{
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
    {
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
 80a388a:	4c09      	ldr	r4, [pc, #36]	; (80a38b0 <_ZL22Refresh_UnixTime_Cachel+0x60>)
static struct tm Convert_UnixTime_To_CalendarTime(time_t unix_time)
{
	struct tm *calendar_time;
	calendar_time = localtime(&unix_time);
	calendar_time->tm_year += 1900;
	return *calendar_time;
 80a388c:	f8c5 e000 	str.w	lr, [r5]
{
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
    {
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
 80a3890:	ad01      	add	r5, sp, #4
 80a3892:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a3894:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a3896:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a3898:	c40f      	stmia	r4!, {r0, r1, r2, r3}
            unix_time_cache = unix_time;
 80a389a:	603e      	str	r6, [r7, #0]
{
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
    {
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
 80a389c:	f8c4 e000 	str.w	lr, [r4]
            unix_time_cache = unix_time;
    }
}
 80a38a0:	b00b      	add	sp, #44	; 0x2c
 80a38a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a38a4:	20000b58 	.word	0x20000b58
 80a38a8:	20000b54 	.word	0x20000b54
 80a38ac:	20000b50 	.word	0x20000b50
 80a38b0:	20000b28 	.word	0x20000b28

080a38b4 <_ZN10CloudClass12syncTimeDoneEv.isra.1>:
    bool syncTimePending(void)
    {
        return connected() && CLOUD_FN(spark_sync_time_pending(nullptr), false);
    }

    bool syncTimeDone(void)
 80a38b4:	b508      	push	{r3, lr}
    {
        return !CLOUD_FN(spark_sync_time_pending(nullptr), false) || disconnected();
 80a38b6:	2000      	movs	r0, #0
 80a38b8:	f7ff fd76 	bl	80a33a8 <spark_sync_time_pending>
 80a38bc:	b128      	cbz	r0, 80a38ca <_ZN10CloudClass12syncTimeDoneEv.isra.1+0x16>
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
 80a38be:	f7ff fd6b 	bl	80a3398 <spark_cloud_flag_connected>
        return connected() && CLOUD_FN(spark_sync_time_pending(nullptr), false);
    }

    bool syncTimeDone(void)
    {
        return !CLOUD_FN(spark_sync_time_pending(nullptr), false) || disconnected();
 80a38c2:	f080 0001 	eor.w	r0, r0, #1
 80a38c6:	b2c0      	uxtb	r0, r0
 80a38c8:	bd08      	pop	{r3, pc}
 80a38ca:	2001      	movs	r0, #1
    }
 80a38cc:	bd08      	pop	{r3, pc}
	...

080a38d0 <_ZN9TimeClass5monthEl>:
	return month(now());
}

/* the month for the given time */
int TimeClass::month(time_t t)
{
 80a38d0:	b508      	push	{r3, lr}
	Refresh_UnixTime_Cache(t);
 80a38d2:	f7ff ffbd 	bl	80a3850 <_ZL22Refresh_UnixTime_Cachel>
	return (calendar_time_cache.tm_mon + 1);//Arduino's month representation
 80a38d6:	4b02      	ldr	r3, [pc, #8]	; (80a38e0 <_ZN9TimeClass5monthEl+0x10>)
 80a38d8:	6918      	ldr	r0, [r3, #16]
}
 80a38da:	3001      	adds	r0, #1
 80a38dc:	bd08      	pop	{r3, pc}
 80a38de:	bf00      	nop
 80a38e0:	20000b28 	.word	0x20000b28

080a38e4 <_ZN9TimeClass7isValidEv>:
    strftime(buf, 50, format_str, calendar_time);
    return String(buf);
}

bool TimeClass::isValid()
{
 80a38e4:	b510      	push	{r4, lr}
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
 80a38e6:	2000      	movs	r0, #0
 80a38e8:	f7ff fbe0 	bl	80a30ac <HAL_RTC_Time_Is_Valid>
    if (rtcstate)
 80a38ec:	4604      	mov	r4, r0
 80a38ee:	b968      	cbnz	r0, 80a390c <_ZN9TimeClass7isValidEv+0x28>
        }
    }

    static System_Mode_TypeDef mode(void) {
        return system_mode();
 80a38f0:	f7ff fd06 	bl	80a3300 <system_mode>
        return rtcstate;
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
 80a38f4:	2801      	cmp	r0, #1
 80a38f6:	d10b      	bne.n	80a3910 <_ZN9TimeClass7isValidEv+0x2c>
 80a38f8:	4620      	mov	r0, r4
 80a38fa:	f7ff fd21 	bl	80a3340 <system_thread_get_state>
 80a38fe:	b938      	cbnz	r0, 80a3910 <_ZN9TimeClass7isValidEv+0x2c>
    {
        waitUntil(Particle.syncTimeDone);
 80a3900:	f7ff ffd8 	bl	80a38b4 <_ZN10CloudClass12syncTimeDoneEv.isra.1>


    static uint32_t freeMemory();

    template<typename Condition, typename While> static bool waitConditionWhile(Condition _condition, While _while) {
        while (_while() && !_condition()) {
 80a3904:	b930      	cbnz	r0, 80a3914 <_ZN9TimeClass7isValidEv+0x30>
            spark_process();
 80a3906:	f7ff fd3f 	bl	80a3388 <spark_process>
 80a390a:	e7f9      	b.n	80a3900 <_ZN9TimeClass7isValidEv+0x1c>

bool TimeClass::isValid()
{
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
    if (rtcstate)
        return rtcstate;
 80a390c:	2001      	movs	r0, #1
 80a390e:	bd10      	pop	{r4, pc}
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
    {
        waitUntil(Particle.syncTimeDone);
        return HAL_RTC_Time_Is_Valid(nullptr);
    }
    return rtcstate;
 80a3910:	2000      	movs	r0, #0
 80a3912:	bd10      	pop	{r4, pc}
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
    if (rtcstate)
        return rtcstate;
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
    {
        waitUntil(Particle.syncTimeDone);
 80a3914:	f7ff ffce 	bl	80a38b4 <_ZN10CloudClass12syncTimeDoneEv.isra.1>
        return HAL_RTC_Time_Is_Valid(nullptr);
 80a3918:	2000      	movs	r0, #0
 80a391a:	f7ff fbc7 	bl	80a30ac <HAL_RTC_Time_Is_Valid>
 80a391e:	3000      	adds	r0, #0
 80a3920:	bf18      	it	ne
 80a3922:	2001      	movne	r0, #1
    }
    return rtcstate;
}
 80a3924:	bd10      	pop	{r4, pc}

080a3926 <_ZN9TimeClass3nowEv>:
	return calendar_time_cache.tm_year;
}

/* return the current time as seconds since Jan 1 1970 */
time_t TimeClass::now()
{
 80a3926:	b508      	push	{r3, lr}
    (void)isValid();
 80a3928:	f7ff ffdc 	bl	80a38e4 <_ZN9TimeClass7isValidEv>
	return HAL_RTC_Get_UnixTime();
}
 80a392c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

/* return the current time as seconds since Jan 1 1970 */
time_t TimeClass::now()
{
    (void)isValid();
	return HAL_RTC_Get_UnixTime();
 80a3930:	f7ff bbb4 	b.w	80a309c <HAL_RTC_Get_UnixTime>

080a3934 <_ZN9TimeClass4hourEv>:

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;

/* current hour */
int TimeClass::hour()
{
 80a3934:	b508      	push	{r3, lr}
	return hour(now());
 80a3936:	f7ff fff6 	bl	80a3926 <_ZN9TimeClass3nowEv>
}

/* the hour for the given time */
int TimeClass::hour(time_t t)
{
	Refresh_UnixTime_Cache(t);
 80a393a:	f7ff ff89 	bl	80a3850 <_ZL22Refresh_UnixTime_Cachel>

/* current hour */
int TimeClass::hour()
{
	return hour(now());
}
 80a393e:	4b01      	ldr	r3, [pc, #4]	; (80a3944 <_ZN9TimeClass4hourEv+0x10>)
 80a3940:	6898      	ldr	r0, [r3, #8]
 80a3942:	bd08      	pop	{r3, pc}
 80a3944:	20000b28 	.word	0x20000b28

080a3948 <_ZN9TimeClass6minuteEv>:
	return (hour(t) >= 12);
}

/* current minute */
int TimeClass::minute()
{
 80a3948:	b508      	push	{r3, lr}
	return minute(now());
 80a394a:	f7ff ffec 	bl	80a3926 <_ZN9TimeClass3nowEv>
}

/* the minute for the given time */
int TimeClass::minute(time_t t)
{
	Refresh_UnixTime_Cache(t);
 80a394e:	f7ff ff7f 	bl	80a3850 <_ZL22Refresh_UnixTime_Cachel>

/* current minute */
int TimeClass::minute()
{
	return minute(now());
}
 80a3952:	4b01      	ldr	r3, [pc, #4]	; (80a3958 <_ZN9TimeClass6minuteEv+0x10>)
 80a3954:	6858      	ldr	r0, [r3, #4]
 80a3956:	bd08      	pop	{r3, pc}
 80a3958:	20000b28 	.word	0x20000b28

080a395c <_ZN9TimeClass6secondEv>:
	return calendar_time_cache.tm_min;
}

/* current seconds */
int TimeClass::second()
{
 80a395c:	b508      	push	{r3, lr}
	return second(now());
 80a395e:	f7ff ffe2 	bl	80a3926 <_ZN9TimeClass3nowEv>
}

/* the second for the given time */
int TimeClass::second(time_t t)
{
	Refresh_UnixTime_Cache(t);
 80a3962:	f7ff ff75 	bl	80a3850 <_ZL22Refresh_UnixTime_Cachel>

/* current seconds */
int TimeClass::second()
{
	return second(now());
}
 80a3966:	4b01      	ldr	r3, [pc, #4]	; (80a396c <_ZN9TimeClass6secondEv+0x10>)
 80a3968:	6818      	ldr	r0, [r3, #0]
 80a396a:	bd08      	pop	{r3, pc}
 80a396c:	20000b28 	.word	0x20000b28

080a3970 <_ZN9TimeClass3dayEv>:
	return calendar_time_cache.tm_sec;
}

/* current day */
int TimeClass::day()
{
 80a3970:	b508      	push	{r3, lr}
	return day(now());
 80a3972:	f7ff ffd8 	bl	80a3926 <_ZN9TimeClass3nowEv>
}

/* the day for the given time */
int TimeClass::day(time_t t)
{
	Refresh_UnixTime_Cache(t);
 80a3976:	f7ff ff6b 	bl	80a3850 <_ZL22Refresh_UnixTime_Cachel>

/* current day */
int TimeClass::day()
{
	return day(now());
}
 80a397a:	4b01      	ldr	r3, [pc, #4]	; (80a3980 <_ZN9TimeClass3dayEv+0x10>)
 80a397c:	68d8      	ldr	r0, [r3, #12]
 80a397e:	bd08      	pop	{r3, pc}
 80a3980:	20000b28 	.word	0x20000b28

080a3984 <_ZN9TimeClass5monthEv>:
	return (calendar_time_cache.tm_wday + 1);//Arduino's weekday representation
}

/* current month */
int TimeClass::month()
{
 80a3984:	b508      	push	{r3, lr}
	return month(now());
 80a3986:	f7ff ffce 	bl	80a3926 <_ZN9TimeClass3nowEv>
}
 80a398a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
}

/* current month */
int TimeClass::month()
{
	return month(now());
 80a398e:	f7ff bf9f 	b.w	80a38d0 <_ZN9TimeClass5monthEl>
	...

080a3994 <_ZN9TimeClass4yearEv>:
	return (calendar_time_cache.tm_mon + 1);//Arduino's month representation
}

/* current four digit year */
int TimeClass::year()
{
 80a3994:	b508      	push	{r3, lr}
	return year(now());
 80a3996:	f7ff ffc6 	bl	80a3926 <_ZN9TimeClass3nowEv>
}

/* the year for the given time */
int TimeClass::year(time_t t)
{
	Refresh_UnixTime_Cache(t);
 80a399a:	f7ff ff59 	bl	80a3850 <_ZL22Refresh_UnixTime_Cachel>

/* current four digit year */
int TimeClass::year()
{
	return year(now());
}
 80a399e:	4b01      	ldr	r3, [pc, #4]	; (80a39a4 <_ZN9TimeClass4yearEv+0x10>)
 80a39a0:	6958      	ldr	r0, [r3, #20]
 80a39a2:	bd08      	pop	{r3, pc}
 80a39a4:	20000b28 	.word	0x20000b28

080a39a8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a39a8:	4b02      	ldr	r3, [pc, #8]	; (80a39b4 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a39aa:	681a      	ldr	r2, [r3, #0]
 80a39ac:	4b02      	ldr	r3, [pc, #8]	; (80a39b8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a39ae:	601a      	str	r2, [r3, #0]
 80a39b0:	4770      	bx	lr
 80a39b2:	bf00      	nop
 80a39b4:	20000308 	.word	0x20000308
 80a39b8:	20000b4c 	.word	0x20000b4c

080a39bc <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a39bc:	2100      	movs	r1, #0
 80a39be:	f7ff bcaf 	b.w	80a3320 <system_delay_ms>

080a39c2 <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a39c2:	b510      	push	{r4, lr}
 80a39c4:	4604      	mov	r4, r0
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a39c6:	f7fc fd25 	bl	80a0414 <_ZNSt14_Function_baseD1Ev>
 80a39ca:	4620      	mov	r0, r4
 80a39cc:	bd10      	pop	{r4, pc}
	...

080a39d0 <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a39d0:	4803      	ldr	r0, [pc, #12]	; (80a39e0 <_GLOBAL__sub_I_RGB+0x10>)
 80a39d2:	2300      	movs	r3, #0
 80a39d4:	6083      	str	r3, [r0, #8]
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a39d6:	4a03      	ldr	r2, [pc, #12]	; (80a39e4 <_GLOBAL__sub_I_RGB+0x14>)
 80a39d8:	4903      	ldr	r1, [pc, #12]	; (80a39e8 <_GLOBAL__sub_I_RGB+0x18>)
 80a39da:	f000 bb71 	b.w	80a40c0 <__aeabi_atexit>
 80a39de:	bf00      	nop
 80a39e0:	20000b5c 	.word	0x20000b5c
 80a39e4:	200003c0 	.word	0x200003c0
 80a39e8:	080a39c3 	.word	0x080a39c3

080a39ec <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a39ec:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a39ee:	4b14      	ldr	r3, [pc, #80]	; (80a3a40 <serialEventRun+0x54>)
 80a39f0:	b133      	cbz	r3, 80a3a00 <serialEventRun+0x14>
 80a39f2:	f000 f929 	bl	80a3c48 <_Z16_fetch_usbserialv>
 80a39f6:	6803      	ldr	r3, [r0, #0]
 80a39f8:	691b      	ldr	r3, [r3, #16]
 80a39fa:	4798      	blx	r3
 80a39fc:	2800      	cmp	r0, #0
 80a39fe:	dc16      	bgt.n	80a3a2e <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a3a00:	4b10      	ldr	r3, [pc, #64]	; (80a3a44 <serialEventRun+0x58>)
 80a3a02:	b133      	cbz	r3, 80a3a12 <serialEventRun+0x26>
 80a3a04:	f000 fa0a 	bl	80a3e1c <_Z22__fetch_global_Serial1v>
 80a3a08:	6803      	ldr	r3, [r0, #0]
 80a3a0a:	691b      	ldr	r3, [r3, #16]
 80a3a0c:	4798      	blx	r3
 80a3a0e:	2800      	cmp	r0, #0
 80a3a10:	dc10      	bgt.n	80a3a34 <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a3a12:	4b0d      	ldr	r3, [pc, #52]	; (80a3a48 <serialEventRun+0x5c>)
 80a3a14:	b10b      	cbz	r3, 80a3a1a <serialEventRun+0x2e>
 80a3a16:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a3a1a:	4b0c      	ldr	r3, [pc, #48]	; (80a3a4c <serialEventRun+0x60>)
 80a3a1c:	b17b      	cbz	r3, 80a3a3e <serialEventRun+0x52>
 80a3a1e:	f000 f94f 	bl	80a3cc0 <_Z17_fetch_usbserial1v>
 80a3a22:	6803      	ldr	r3, [r0, #0]
 80a3a24:	691b      	ldr	r3, [r3, #16]
 80a3a26:	4798      	blx	r3
 80a3a28:	2800      	cmp	r0, #0
 80a3a2a:	dc06      	bgt.n	80a3a3a <serialEventRun+0x4e>
 80a3a2c:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a3a2e:	f3af 8000 	nop.w
 80a3a32:	e7e5      	b.n	80a3a00 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a3a34:	f3af 8000 	nop.w
 80a3a38:	e7eb      	b.n	80a3a12 <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a3a3a:	f3af 8000 	nop.w
 80a3a3e:	bd08      	pop	{r3, pc}
	...

080a3a50 <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a3a50:	b508      	push	{r3, lr}
	serialEventRun();
 80a3a52:	f7ff ffcb 	bl	80a39ec <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a3a56:	f7ff fb19 	bl	80a308c <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a3a5a:	4b01      	ldr	r3, [pc, #4]	; (80a3a60 <_post_loop+0x10>)
 80a3a5c:	6018      	str	r0, [r3, #0]
 80a3a5e:	bd08      	pop	{r3, pc}
 80a3a60:	20000ff4 	.word	0x20000ff4

080a3a64 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a3a64:	4802      	ldr	r0, [pc, #8]	; (80a3a70 <_Z33system_initialize_user_backup_ramv+0xc>)
 80a3a66:	4a03      	ldr	r2, [pc, #12]	; (80a3a74 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a3a68:	4903      	ldr	r1, [pc, #12]	; (80a3a78 <_Z33system_initialize_user_backup_ramv+0x14>)
 80a3a6a:	1a12      	subs	r2, r2, r0
 80a3a6c:	f001 ba47 	b.w	80a4efe <memcpy>
 80a3a70:	40024000 	.word	0x40024000
 80a3a74:	40024004 	.word	0x40024004
 80a3a78:	080a5e50 	.word	0x080a5e50

080a3a7c <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a3a7c:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a3a7e:	2300      	movs	r3, #0
 80a3a80:	9300      	str	r3, [sp, #0]
 80a3a82:	461a      	mov	r2, r3
 80a3a84:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a3a88:	f7ff fc6c 	bl	80a3364 <system_ctrl_set_result>
}
 80a3a8c:	b003      	add	sp, #12
 80a3a8e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a3a94 <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
 80a3a94:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a3a96:	8843      	ldrh	r3, [r0, #2]
 80a3a98:	2b0a      	cmp	r3, #10
 80a3a9a:	d008      	beq.n	80a3aae <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a3a9c:	2b50      	cmp	r3, #80	; 0x50
 80a3a9e:	d109      	bne.n	80a3ab4 <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
 80a3aa0:	4b09      	ldr	r3, [pc, #36]	; (80a3ac8 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a3aa2:	681b      	ldr	r3, [r3, #0]
 80a3aa4:	b13b      	cbz	r3, 80a3ab6 <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
 80a3aa6:	b003      	add	sp, #12
 80a3aa8:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
 80a3aac:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
 80a3aae:	f7ff ffe5 	bl	80a3a7c <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
 80a3ab2:	e006      	b.n	80a3ac2 <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a3ab4:	2300      	movs	r3, #0
 80a3ab6:	9300      	str	r3, [sp, #0]
 80a3ab8:	461a      	mov	r2, r3
 80a3aba:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a3abe:	f7ff fc51 	bl	80a3364 <system_ctrl_set_result>
        break;
    }
}
 80a3ac2:	b003      	add	sp, #12
 80a3ac4:	f85d fb04 	ldr.w	pc, [sp], #4
 80a3ac8:	20000b6c 	.word	0x20000b6c

080a3acc <module_user_init_hook>:

void module_user_init_hook()
{
 80a3acc:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a3ace:	4c10      	ldr	r4, [pc, #64]	; (80a3b10 <module_user_init_hook+0x44>)
 80a3ad0:	4d10      	ldr	r5, [pc, #64]	; (80a3b14 <module_user_init_hook+0x48>)
 80a3ad2:	6823      	ldr	r3, [r4, #0]
 80a3ad4:	42ab      	cmp	r3, r5
 80a3ad6:	4b10      	ldr	r3, [pc, #64]	; (80a3b18 <module_user_init_hook+0x4c>)
 80a3ad8:	bf0c      	ite	eq
 80a3ada:	2201      	moveq	r2, #1
 80a3adc:	2200      	movne	r2, #0
 80a3ade:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a3ae0:	d002      	beq.n	80a3ae8 <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
 80a3ae2:	f7ff ffbf 	bl	80a3a64 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a3ae6:	6025      	str	r5, [r4, #0]
#endif

    // todo - add a RNG define for that capability
#if defined(STM32F2XX)
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    srand(HAL_RNG_GetRandomNumber());
 80a3ae8:	f7ff fac0 	bl	80a306c <HAL_RNG_GetRandomNumber>
 80a3aec:	f001 fa1a 	bl	80a4f24 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a3af0:	4b0a      	ldr	r3, [pc, #40]	; (80a3b1c <module_user_init_hook+0x50>)
 80a3af2:	b11b      	cbz	r3, 80a3afc <module_user_init_hook+0x30>
        uint32_t seed = HAL_RNG_GetRandomNumber();
 80a3af4:	f7ff faba 	bl	80a306c <HAL_RNG_GetRandomNumber>
        random_seed_from_cloud(seed);
 80a3af8:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a3afc:	2100      	movs	r1, #0
 80a3afe:	4807      	ldr	r0, [pc, #28]	; (80a3b1c <module_user_init_hook+0x50>)
 80a3b00:	f7ff fc5a 	bl	80a33b8 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a3b04:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a3b08:	2100      	movs	r1, #0
 80a3b0a:	4805      	ldr	r0, [pc, #20]	; (80a3b20 <module_user_init_hook+0x54>)
 80a3b0c:	f7ff bc20 	b.w	80a3350 <system_ctrl_set_app_request_handler>
 80a3b10:	40024000 	.word	0x40024000
 80a3b14:	9a271c1e 	.word	0x9a271c1e
 80a3b18:	20000b70 	.word	0x20000b70
 80a3b1c:	00000000 	.word	0x00000000
 80a3b20:	080a3a95 	.word	0x080a3a95

080a3b24 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a3b24:	4770      	bx	lr

080a3b26 <_ZN9IPAddressD0Ev>:
 80a3b26:	b510      	push	{r4, lr}
 80a3b28:	4604      	mov	r4, r0
 80a3b2a:	f7fc fab8 	bl	80a009e <_ZdlPv>
 80a3b2e:	4620      	mov	r0, r4
 80a3b30:	bd10      	pop	{r4, pc}

080a3b32 <_ZNK9IPAddress7printToER5Print>:
#endif
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a3b32:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3b34:	460f      	mov	r7, r1
 80a3b36:	f100 0608 	add.w	r6, r0, #8
 80a3b3a:	1d05      	adds	r5, r0, #4
 80a3b3c:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a3b3e:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a3b42:	220a      	movs	r2, #10
 80a3b44:	4638      	mov	r0, r7
 80a3b46:	f7ff fe3f 	bl	80a37c8 <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a3b4a:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a3b4c:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a3b4e:	d007      	beq.n	80a3b60 <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a3b50:	2c00      	cmp	r4, #0
 80a3b52:	d0f4      	beq.n	80a3b3e <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a3b54:	212e      	movs	r1, #46	; 0x2e
 80a3b56:	4638      	mov	r0, r7
 80a3b58:	f7ff fdf3 	bl	80a3742 <_ZN5Print5printEc>
 80a3b5c:	4404      	add	r4, r0
 80a3b5e:	e7ee      	b.n	80a3b3e <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a3b60:	4620      	mov	r0, r4
 80a3b62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a3b64 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a3b64:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a3b66:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a3b6a:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a3b6e:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80a3b72:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a3b76:	2304      	movs	r3, #4
 80a3b78:	6041      	str	r1, [r0, #4]
 80a3b7a:	7503      	strb	r3, [r0, #20]
 80a3b7c:	bd10      	pop	{r4, pc}
	...

080a3b80 <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a3b80:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a3b82:	4d04      	ldr	r5, [pc, #16]	; (80a3b94 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a3b84:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a3b86:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a3b8a:	9500      	str	r5, [sp, #0]
 80a3b8c:	f7ff ffea 	bl	80a3b64 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a3b90:	b003      	add	sp, #12
 80a3b92:	bd30      	pop	{r4, r5, pc}
 80a3b94:	080a5b04 	.word	0x080a5b04

080a3b98 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a3b98:	7441      	strb	r1, [r0, #17]
 80a3b9a:	4770      	bx	lr

080a3b9c <_ZN9USBSerialD1Ev>:
#include "spark_wiring_platform.h"
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"

class USBSerial : public Stream
 80a3b9c:	4770      	bx	lr

080a3b9e <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return HAL_USB_USART_Receive_Data(_serial, false);
 80a3b9e:	2100      	movs	r1, #0
 80a3ba0:	7c00      	ldrb	r0, [r0, #16]
 80a3ba2:	f7ff bb95 	b.w	80a32d0 <HAL_USB_USART_Receive_Data>

080a3ba6 <_ZN9USBSerial4peekEv>:
  _blocking = block;
}

int USBSerial::peek()
{
	return HAL_USB_USART_Receive_Data(_serial, true);
 80a3ba6:	2101      	movs	r1, #1
 80a3ba8:	7c00      	ldrb	r0, [r0, #16]
 80a3baa:	f7ff bb91 	b.w	80a32d0 <HAL_USB_USART_Receive_Data>

080a3bae <_ZN9USBSerial17availableForWriteEv>:
	return HAL_USB_USART_Receive_Data(_serial, false);
}

int USBSerial::availableForWrite()
{
  return HAL_USB_USART_Available_Data_For_Write(_serial);
 80a3bae:	7c00      	ldrb	r0, [r0, #16]
 80a3bb0:	f7ff bb86 	b.w	80a32c0 <HAL_USB_USART_Available_Data_For_Write>

080a3bb4 <_ZN9USBSerial9availableEv>:
}

int USBSerial::available()
{
	return HAL_USB_USART_Available_Data(_serial);
 80a3bb4:	7c00      	ldrb	r0, [r0, #16]
 80a3bb6:	f7ff bb7b 	b.w	80a32b0 <HAL_USB_USART_Available_Data>

080a3bba <_ZN9USBSerial5writeEh>:
}

size_t USBSerial::write(uint8_t byte)
{
 80a3bba:	b538      	push	{r3, r4, r5, lr}
 80a3bbc:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a3bbe:	7c00      	ldrb	r0, [r0, #16]
{
	return HAL_USB_USART_Available_Data(_serial);
}

size_t USBSerial::write(uint8_t byte)
{
 80a3bc0:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a3bc2:	f7ff fb7d 	bl	80a32c0 <HAL_USB_USART_Available_Data_For_Write>
 80a3bc6:	2800      	cmp	r0, #0
 80a3bc8:	dc01      	bgt.n	80a3bce <_ZN9USBSerial5writeEh+0x14>
 80a3bca:	7c60      	ldrb	r0, [r4, #17]
 80a3bcc:	b120      	cbz	r0, 80a3bd8 <_ZN9USBSerial5writeEh+0x1e>
    HAL_USB_USART_Send_Data(_serial, byte);
 80a3bce:	4629      	mov	r1, r5
 80a3bd0:	7c20      	ldrb	r0, [r4, #16]
 80a3bd2:	f7ff fb85 	bl	80a32e0 <HAL_USB_USART_Send_Data>
    return 1;
 80a3bd6:	2001      	movs	r0, #1
  }
  return 0;
}
 80a3bd8:	bd38      	pop	{r3, r4, r5, pc}

080a3bda <_ZN9USBSerial5flushEv>:

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a3bda:	7c00      	ldrb	r0, [r0, #16]
 80a3bdc:	f7ff bb88 	b.w	80a32f0 <HAL_USB_USART_Flush_Data>

080a3be0 <_ZN9USBSerialD0Ev>:
 80a3be0:	b510      	push	{r4, lr}
 80a3be2:	4604      	mov	r4, r0
 80a3be4:	f7fc fa5b 	bl	80a009e <_ZdlPv>
 80a3be8:	4620      	mov	r0, r4
 80a3bea:	bd10      	pop	{r4, pc}

080a3bec <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a3bec:	b510      	push	{r4, lr}
 80a3bee:	4604      	mov	r4, r0
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a3bf0:	2300      	movs	r3, #0
 80a3bf2:	6063      	str	r3, [r4, #4]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a3bf4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a3bf8:	60a3      	str	r3, [r4, #8]
 80a3bfa:	4b05      	ldr	r3, [pc, #20]	; (80a3c10 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
 80a3bfc:	4608      	mov	r0, r1
 80a3bfe:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
 80a3c00:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
{
  _serial = serial;
 80a3c02:	7421      	strb	r1, [r4, #16]
  _blocking = true;
 80a3c04:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a3c06:	4611      	mov	r1, r2
 80a3c08:	f7ff fb42 	bl	80a3290 <HAL_USB_USART_Init>
}
 80a3c0c:	4620      	mov	r0, r4
 80a3c0e:	bd10      	pop	{r4, pc}
 80a3c10:	080a5b18 	.word	0x080a5b18

080a3c14 <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    HAL_USB_USART_Begin(_serial, speed, NULL);
 80a3c14:	2200      	movs	r2, #0
 80a3c16:	7c00      	ldrb	r0, [r0, #16]
 80a3c18:	f7ff bb42 	b.w	80a32a0 <HAL_USB_USART_Begin>

080a3c1c <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a3c1c:	b510      	push	{r4, lr}
 80a3c1e:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a3c20:	2214      	movs	r2, #20
 80a3c22:	2100      	movs	r1, #0
 80a3c24:	f001 f976 	bl	80a4f14 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a3c28:	4b05      	ldr	r3, [pc, #20]	; (80a3c40 <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a3c2a:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a3c2c:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a3c2e:	4b05      	ldr	r3, [pc, #20]	; (80a3c44 <_Z19acquireSerialBufferv+0x28>)
 80a3c30:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a3c32:	f240 1301 	movw	r3, #257	; 0x101
 80a3c36:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a3c38:	2381      	movs	r3, #129	; 0x81
 80a3c3a:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a3c3c:	bd10      	pop	{r4, pc}
 80a3c3e:	bf00      	nop
 80a3c40:	20000bf9 	.word	0x20000bf9
 80a3c44:	20000b78 	.word	0x20000b78

080a3c48 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a3c48:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a3c4a:	4d0e      	ldr	r5, [pc, #56]	; (80a3c84 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a3c4c:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a3c4e:	a801      	add	r0, sp, #4
 80a3c50:	f7ff ffe4 	bl	80a3c1c <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a3c54:	6829      	ldr	r1, [r5, #0]
 80a3c56:	f011 0401 	ands.w	r4, r1, #1
 80a3c5a:	d110      	bne.n	80a3c7e <_Z16_fetch_usbserialv+0x36>
 80a3c5c:	4628      	mov	r0, r5
 80a3c5e:	f7fc fa20 	bl	80a00a2 <__cxa_guard_acquire>
 80a3c62:	b160      	cbz	r0, 80a3c7e <_Z16_fetch_usbserialv+0x36>
 80a3c64:	aa01      	add	r2, sp, #4
 80a3c66:	4621      	mov	r1, r4
 80a3c68:	4807      	ldr	r0, [pc, #28]	; (80a3c88 <_Z16_fetch_usbserialv+0x40>)
 80a3c6a:	f7ff ffbf 	bl	80a3bec <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a3c6e:	4628      	mov	r0, r5
 80a3c70:	f7fc fa1c 	bl	80a00ac <__cxa_guard_release>
 80a3c74:	4a05      	ldr	r2, [pc, #20]	; (80a3c8c <_Z16_fetch_usbserialv+0x44>)
 80a3c76:	4906      	ldr	r1, [pc, #24]	; (80a3c90 <_Z16_fetch_usbserialv+0x48>)
 80a3c78:	4803      	ldr	r0, [pc, #12]	; (80a3c88 <_Z16_fetch_usbserialv+0x40>)
 80a3c7a:	f000 fa21 	bl	80a40c0 <__aeabi_atexit>
	return _usbserial;
}
 80a3c7e:	4802      	ldr	r0, [pc, #8]	; (80a3c88 <_Z16_fetch_usbserialv+0x40>)
 80a3c80:	b007      	add	sp, #28
 80a3c82:	bd30      	pop	{r4, r5, pc}
 80a3c84:	20000b74 	.word	0x20000b74
 80a3c88:	20000cfc 	.word	0x20000cfc
 80a3c8c:	200003c0 	.word	0x200003c0
 80a3c90:	080a3b9d 	.word	0x080a3b9d

080a3c94 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a3c94:	b510      	push	{r4, lr}
 80a3c96:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a3c98:	2214      	movs	r2, #20
 80a3c9a:	2100      	movs	r1, #0
 80a3c9c:	f001 f93a 	bl	80a4f14 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a3ca0:	4b05      	ldr	r3, [pc, #20]	; (80a3cb8 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a3ca2:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a3ca4:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a3ca6:	4b05      	ldr	r3, [pc, #20]	; (80a3cbc <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a3ca8:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a3caa:	f240 1301 	movw	r3, #257	; 0x101
 80a3cae:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a3cb0:	2381      	movs	r3, #129	; 0x81
 80a3cb2:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a3cb4:	bd10      	pop	{r4, pc}
 80a3cb6:	bf00      	nop
 80a3cb8:	20000dac 	.word	0x20000dac
 80a3cbc:	20000d14 	.word	0x20000d14

080a3cc0 <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a3cc0:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a3cc2:	4c0e      	ldr	r4, [pc, #56]	; (80a3cfc <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a3cc4:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a3cc6:	a801      	add	r0, sp, #4
 80a3cc8:	f7ff ffe4 	bl	80a3c94 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a3ccc:	6823      	ldr	r3, [r4, #0]
 80a3cce:	07db      	lsls	r3, r3, #31
 80a3cd0:	d410      	bmi.n	80a3cf4 <_Z17_fetch_usbserial1v+0x34>
 80a3cd2:	4620      	mov	r0, r4
 80a3cd4:	f7fc f9e5 	bl	80a00a2 <__cxa_guard_acquire>
 80a3cd8:	b160      	cbz	r0, 80a3cf4 <_Z17_fetch_usbserial1v+0x34>
 80a3cda:	aa01      	add	r2, sp, #4
 80a3cdc:	2101      	movs	r1, #1
 80a3cde:	4808      	ldr	r0, [pc, #32]	; (80a3d00 <_Z17_fetch_usbserial1v+0x40>)
 80a3ce0:	f7ff ff84 	bl	80a3bec <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a3ce4:	4620      	mov	r0, r4
 80a3ce6:	f7fc f9e1 	bl	80a00ac <__cxa_guard_release>
 80a3cea:	4a06      	ldr	r2, [pc, #24]	; (80a3d04 <_Z17_fetch_usbserial1v+0x44>)
 80a3cec:	4906      	ldr	r1, [pc, #24]	; (80a3d08 <_Z17_fetch_usbserial1v+0x48>)
 80a3cee:	4804      	ldr	r0, [pc, #16]	; (80a3d00 <_Z17_fetch_usbserial1v+0x40>)
 80a3cf0:	f000 f9e6 	bl	80a40c0 <__aeabi_atexit>
  return _usbserial1;
}
 80a3cf4:	4802      	ldr	r0, [pc, #8]	; (80a3d00 <_Z17_fetch_usbserial1v+0x40>)
 80a3cf6:	b006      	add	sp, #24
 80a3cf8:	bd10      	pop	{r4, pc}
 80a3cfa:	bf00      	nop
 80a3cfc:	20000d10 	.word	0x20000d10
 80a3d00:	20000d98 	.word	0x20000d98
 80a3d04:	200003c0 	.word	0x200003c0
 80a3d08:	080a3b9d 	.word	0x080a3b9d

080a3d0c <_Z29call_wiring_interrupt_handlerPv>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a3d0c:	6882      	ldr	r2, [r0, #8]
    delete handlers[pin];
    return handlers[pin] = new wiring_interrupt_handler_t(fn);
}

void call_wiring_interrupt_handler(void* data)
{
 80a3d0e:	b510      	push	{r4, lr}
 80a3d10:	b90a      	cbnz	r2, 80a3d16 <_Z29call_wiring_interrupt_handlerPv+0xa>
	__throw_bad_function_call();
 80a3d12:	f000 f9f2 	bl	80a40fa <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a3d16:	68c3      	ldr	r3, [r0, #12]
    wiring_interrupt_handler_t* handler = (wiring_interrupt_handler_t*)data;
    (*handler)();
}
 80a3d18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a3d1c:	4718      	bx	r3

080a3d1e <_ZNSt8functionIFvvEEC1ERKS1_>:
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a3d1e:	b538      	push	{r3, r4, r5, lr}
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a3d20:	2300      	movs	r3, #0
 80a3d22:	6083      	str	r3, [r0, #8]
 80a3d24:	688b      	ldr	r3, [r1, #8]
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a3d26:	4604      	mov	r4, r0
 80a3d28:	460d      	mov	r5, r1
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 80a3d2a:	b12b      	cbz	r3, 80a3d38 <_ZNSt8functionIFvvEEC1ERKS1_+0x1a>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a3d2c:	2202      	movs	r2, #2
 80a3d2e:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a3d30:	68eb      	ldr	r3, [r5, #12]
 80a3d32:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a3d34:	68ab      	ldr	r3, [r5, #8]
 80a3d36:	60a3      	str	r3, [r4, #8]
	}
    }
 80a3d38:	4620      	mov	r0, r4
 80a3d3a:	bd38      	pop	{r3, r4, r5, pc}

080a3d3c <_Z21attachSystemInterrupt9hal_irq_tSt8functionIFvvEE>:

/*
 * System Interrupts
 */
bool attachSystemInterrupt(hal_irq_t irq, wiring_interrupt_handler_t handler)
{
 80a3d3c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    HAL_InterruptCallback callback;
    callback.handler = call_wiring_interrupt_handler;
 80a3d3e:	4b11      	ldr	r3, [pc, #68]	; (80a3d84 <_Z21attachSystemInterrupt9hal_irq_tSt8functionIFvvEE+0x48>)

/*
 * System Interrupts
 */
bool attachSystemInterrupt(hal_irq_t irq, wiring_interrupt_handler_t handler)
{
 80a3d40:	4604      	mov	r4, r0
    HAL_InterruptCallback callback;
    callback.handler = call_wiring_interrupt_handler;
    wiring_interrupt_handler_t& h = handler;
    callback.data = new wiring_interrupt_handler_t(h);
 80a3d42:	2010      	movs	r0, #16

/*
 * System Interrupts
 */
bool attachSystemInterrupt(hal_irq_t irq, wiring_interrupt_handler_t handler)
{
 80a3d44:	460e      	mov	r6, r1
    HAL_InterruptCallback callback;
    callback.handler = call_wiring_interrupt_handler;
 80a3d46:	9300      	str	r3, [sp, #0]
    wiring_interrupt_handler_t& h = handler;
    callback.data = new wiring_interrupt_handler_t(h);
 80a3d48:	f7fc f9a7 	bl	80a009a <_Znwj>
 80a3d4c:	4605      	mov	r5, r0
 80a3d4e:	b110      	cbz	r0, 80a3d56 <_Z21attachSystemInterrupt9hal_irq_tSt8functionIFvvEE+0x1a>
 80a3d50:	4631      	mov	r1, r6
 80a3d52:	f7ff ffe4 	bl	80a3d1e <_ZNSt8functionIFvvEEC1ERKS1_>
    HAL_InterruptCallback prev = { 0 };
 80a3d56:	2300      	movs	r3, #0
    const bool ok = HAL_Set_System_Interrupt_Handler(irq, &callback, &prev, NULL);
 80a3d58:	4620      	mov	r0, r4
 80a3d5a:	aa02      	add	r2, sp, #8
 80a3d5c:	4669      	mov	r1, sp
bool attachSystemInterrupt(hal_irq_t irq, wiring_interrupt_handler_t handler)
{
    HAL_InterruptCallback callback;
    callback.handler = call_wiring_interrupt_handler;
    wiring_interrupt_handler_t& h = handler;
    callback.data = new wiring_interrupt_handler_t(h);
 80a3d5e:	9501      	str	r5, [sp, #4]
    HAL_InterruptCallback prev = { 0 };
 80a3d60:	9302      	str	r3, [sp, #8]
 80a3d62:	9303      	str	r3, [sp, #12]
    const bool ok = HAL_Set_System_Interrupt_Handler(irq, &callback, &prev, NULL);
 80a3d64:	f7ff f93a 	bl	80a2fdc <HAL_Set_System_Interrupt_Handler>
    delete (wiring_interrupt_handler_t*)prev.data;
 80a3d68:	9c03      	ldr	r4, [sp, #12]
    HAL_InterruptCallback callback;
    callback.handler = call_wiring_interrupt_handler;
    wiring_interrupt_handler_t& h = handler;
    callback.data = new wiring_interrupt_handler_t(h);
    HAL_InterruptCallback prev = { 0 };
    const bool ok = HAL_Set_System_Interrupt_Handler(irq, &callback, &prev, NULL);
 80a3d6a:	1c05      	adds	r5, r0, #0
 80a3d6c:	bf18      	it	ne
 80a3d6e:	2501      	movne	r5, #1
    delete (wiring_interrupt_handler_t*)prev.data;
 80a3d70:	b12c      	cbz	r4, 80a3d7e <_Z21attachSystemInterrupt9hal_irq_tSt8functionIFvvEE+0x42>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a3d72:	4620      	mov	r0, r4
 80a3d74:	f7fc fb4e 	bl	80a0414 <_ZNSt14_Function_baseD1Ev>
 80a3d78:	4620      	mov	r0, r4
 80a3d7a:	f7fc f990 	bl	80a009e <_ZdlPv>
    return ok;
}
 80a3d7e:	4628      	mov	r0, r5
 80a3d80:	b004      	add	sp, #16
 80a3d82:	bd70      	pop	{r4, r5, r6, pc}
 80a3d84:	080a3d0d 	.word	0x080a3d0d

080a3d88 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a3d88:	4770      	bx	lr

080a3d8a <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a3d8a:	7441      	strb	r1, [r0, #17]
 80a3d8c:	4770      	bx	lr

080a3d8e <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
  return HAL_USART_Available_Data_For_Write(_serial);
 80a3d8e:	7c00      	ldrb	r0, [r0, #16]
 80a3d90:	f7ff ba1c 	b.w	80a31cc <HAL_USART_Available_Data_For_Write>

080a3d94 <_ZN11USARTSerial9availableEv>:
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a3d94:	7c00      	ldrb	r0, [r0, #16]
 80a3d96:	f7ff b9f1 	b.w	80a317c <HAL_USART_Available_Data>

080a3d9a <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a3d9a:	7c00      	ldrb	r0, [r0, #16]
 80a3d9c:	f7ff b9fe 	b.w	80a319c <HAL_USART_Peek_Data>

080a3da0 <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a3da0:	7c00      	ldrb	r0, [r0, #16]
 80a3da2:	f7ff b9f3 	b.w	80a318c <HAL_USART_Read_Data>

080a3da6 <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a3da6:	7c00      	ldrb	r0, [r0, #16]
 80a3da8:	f7ff ba00 	b.w	80a31ac <HAL_USART_Flush_Data>

080a3dac <_ZN11USARTSerialD0Ev>:
 80a3dac:	b510      	push	{r4, lr}
 80a3dae:	4604      	mov	r4, r0
 80a3db0:	f7fc f975 	bl	80a009e <_ZdlPv>
 80a3db4:	4620      	mov	r0, r4
 80a3db6:	bd10      	pop	{r4, pc}

080a3db8 <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a3db8:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a3dba:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a3dbc:	4604      	mov	r4, r0
 80a3dbe:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a3dc0:	b925      	cbnz	r5, 80a3dcc <_ZN11USARTSerial5writeEh+0x14>
 80a3dc2:	7c00      	ldrb	r0, [r0, #16]
 80a3dc4:	f7ff fa02 	bl	80a31cc <HAL_USART_Available_Data_For_Write>
 80a3dc8:	2800      	cmp	r0, #0
 80a3dca:	dd05      	ble.n	80a3dd8 <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a3dcc:	4631      	mov	r1, r6
 80a3dce:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a3dd0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a3dd4:	f7ff b9ca 	b.w	80a316c <HAL_USART_Write_Data>
  }
  return 0;
}
 80a3dd8:	4628      	mov	r0, r5
 80a3dda:	bd70      	pop	{r4, r5, r6, pc}

080a3ddc <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a3ddc:	b510      	push	{r4, lr}
 80a3dde:	4604      	mov	r4, r0
 80a3de0:	4608      	mov	r0, r1
 80a3de2:	4611      	mov	r1, r2
 80a3de4:	2200      	movs	r2, #0
 80a3de6:	6062      	str	r2, [r4, #4]
 80a3de8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a3dec:	60a2      	str	r2, [r4, #8]
 80a3dee:	4a05      	ldr	r2, [pc, #20]	; (80a3e04 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a3df0:	7420      	strb	r0, [r4, #16]
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a3df2:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a3df4:	2201      	movs	r2, #1
 80a3df6:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a3df8:	461a      	mov	r2, r3
 80a3dfa:	f7ff f9af 	bl	80a315c <HAL_USART_Init>
}
 80a3dfe:	4620      	mov	r0, r4
 80a3e00:	bd10      	pop	{r4, pc}
 80a3e02:	bf00      	nop
 80a3e04:	080a5b48 	.word	0x080a5b48

080a3e08 <_ZN11USARTSerial5beginEmm>:
  begin(baud, SERIAL_8N1);
}

void USARTSerial::begin(unsigned long baud, uint32_t config)
{
  HAL_USART_BeginConfig(_serial, baud, config, 0);
 80a3e08:	2300      	movs	r3, #0
 80a3e0a:	7c00      	ldrb	r0, [r0, #16]
 80a3e0c:	f7ff b9e6 	b.w	80a31dc <HAL_USART_BeginConfig>

080a3e10 <_ZN11USARTSerial5beginEm>:
}
// Public Methods //////////////////////////////////////////////////////////////

void USARTSerial::begin(unsigned long baud)
{
  begin(baud, SERIAL_8N1);
 80a3e10:	2200      	movs	r2, #0
 80a3e12:	f7ff bff9 	b.w	80a3e08 <_ZN11USARTSerial5beginEmm>

080a3e16 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a3e16:	7c00      	ldrb	r0, [r0, #16]
 80a3e18:	f7ff b9d0 	b.w	80a31bc <HAL_USART_Is_Enabled>

080a3e1c <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a3e1c:	b538      	push	{r3, r4, r5, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a3e1e:	4d0c      	ldr	r5, [pc, #48]	; (80a3e50 <_Z22__fetch_global_Serial1v+0x34>)
 80a3e20:	6829      	ldr	r1, [r5, #0]
 80a3e22:	f011 0401 	ands.w	r4, r1, #1
 80a3e26:	d111      	bne.n	80a3e4c <_Z22__fetch_global_Serial1v+0x30>
 80a3e28:	4628      	mov	r0, r5
 80a3e2a:	f7fc f93a 	bl	80a00a2 <__cxa_guard_acquire>
 80a3e2e:	b168      	cbz	r0, 80a3e4c <_Z22__fetch_global_Serial1v+0x30>
 80a3e30:	4a08      	ldr	r2, [pc, #32]	; (80a3e54 <_Z22__fetch_global_Serial1v+0x38>)
 80a3e32:	4621      	mov	r1, r4
 80a3e34:	4b08      	ldr	r3, [pc, #32]	; (80a3e58 <_Z22__fetch_global_Serial1v+0x3c>)
 80a3e36:	4809      	ldr	r0, [pc, #36]	; (80a3e5c <_Z22__fetch_global_Serial1v+0x40>)
 80a3e38:	f7ff ffd0 	bl	80a3ddc <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a3e3c:	4628      	mov	r0, r5
 80a3e3e:	f7fc f935 	bl	80a00ac <__cxa_guard_release>
 80a3e42:	4a07      	ldr	r2, [pc, #28]	; (80a3e60 <_Z22__fetch_global_Serial1v+0x44>)
 80a3e44:	4907      	ldr	r1, [pc, #28]	; (80a3e64 <_Z22__fetch_global_Serial1v+0x48>)
 80a3e46:	4805      	ldr	r0, [pc, #20]	; (80a3e5c <_Z22__fetch_global_Serial1v+0x40>)
 80a3e48:	f000 f93a 	bl	80a40c0 <__aeabi_atexit>
    serial1_tx_buffer = new Ring_Buffer();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a3e4c:	4803      	ldr	r0, [pc, #12]	; (80a3e5c <_Z22__fetch_global_Serial1v+0x40>)
 80a3e4e:	bd38      	pop	{r3, r4, r5, pc}
 80a3e50:	20000f48 	.word	0x20000f48
 80a3e54:	20000f4c 	.word	0x20000f4c
 80a3e58:	20000ec4 	.word	0x20000ec4
 80a3e5c:	20000eb0 	.word	0x20000eb0
 80a3e60:	200003c0 	.word	0x200003c0
 80a3e64:	080a3d89 	.word	0x080a3d89

080a3e68 <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a3e68:	4770      	bx	lr

080a3e6a <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a3e6a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3e6c:	4606      	mov	r6, r0
 80a3e6e:	4615      	mov	r5, r2
 80a3e70:	460c      	mov	r4, r1
 80a3e72:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a3e74:	42bc      	cmp	r4, r7
 80a3e76:	d006      	beq.n	80a3e86 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a3e78:	6833      	ldr	r3, [r6, #0]
 80a3e7a:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a3e7e:	689b      	ldr	r3, [r3, #8]
 80a3e80:	4630      	mov	r0, r6
 80a3e82:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a3e84:	e7f6      	b.n	80a3e74 <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
 80a3e86:	4628      	mov	r0, r5
 80a3e88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a3e8a <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a3e8a:	2200      	movs	r2, #0
 80a3e8c:	7c00      	ldrb	r0, [r0, #16]
 80a3e8e:	f7ff b9ad 	b.w	80a31ec <HAL_I2C_Write_Data>

080a3e92 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a3e92:	2100      	movs	r1, #0
 80a3e94:	7c00      	ldrb	r0, [r0, #16]
 80a3e96:	f7ff b9b1 	b.w	80a31fc <HAL_I2C_Available_Data>

080a3e9a <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a3e9a:	2100      	movs	r1, #0
 80a3e9c:	7c00      	ldrb	r0, [r0, #16]
 80a3e9e:	f7ff b9b5 	b.w	80a320c <HAL_I2C_Read_Data>

080a3ea2 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a3ea2:	2100      	movs	r1, #0
 80a3ea4:	7c00      	ldrb	r0, [r0, #16]
 80a3ea6:	f7ff b9b9 	b.w	80a321c <HAL_I2C_Peek_Data>

080a3eaa <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a3eaa:	2100      	movs	r1, #0
 80a3eac:	7c00      	ldrb	r0, [r0, #16]
 80a3eae:	f7ff b9bd 	b.w	80a322c <HAL_I2C_Flush_Data>

080a3eb2 <_ZN7TwoWireD0Ev>:
 80a3eb2:	b510      	push	{r4, lr}
 80a3eb4:	4604      	mov	r4, r0
 80a3eb6:	f7fc f8f2 	bl	80a009e <_ZdlPv>
 80a3eba:	4620      	mov	r0, r4
 80a3ebc:	bd10      	pop	{r4, pc}
	...

080a3ec0 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a3ec0:	b510      	push	{r4, lr}
 80a3ec2:	4604      	mov	r4, r0
 80a3ec4:	4608      	mov	r0, r1
 80a3ec6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a3eca:	60a3      	str	r3, [r4, #8]
 80a3ecc:	4b04      	ldr	r3, [pc, #16]	; (80a3ee0 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
 80a3ece:	2100      	movs	r1, #0
{
  _i2c = i2c;
 80a3ed0:	7420      	strb	r0, [r4, #16]
 80a3ed2:	6061      	str	r1, [r4, #4]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a3ed4:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, NULL);
 80a3ed6:	f7ff f9b9 	bl	80a324c <HAL_I2C_Init>

}
 80a3eda:	4620      	mov	r0, r4
 80a3edc:	bd10      	pop	{r4, pc}
 80a3ede:	bf00      	nop
 80a3ee0:	080a5b78 	.word	0x080a5b78

080a3ee4 <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a3ee4:	2100      	movs	r1, #0
 80a3ee6:	7c00      	ldrb	r0, [r0, #16]
 80a3ee8:	f7ff b9a8 	b.w	80a323c <HAL_I2C_Is_Enabled>

080a3eec <_ZN10CANChannelC1E15HAL_CAN_Channeltt>:
#include "spark_wiring_can.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

CANChannel::CANChannel(HAL_CAN_Channel channel,
 80a3eec:	b510      	push	{r4, lr}
 80a3eee:	4604      	mov	r4, r0
 80a3ef0:	4608      	mov	r0, r1
 80a3ef2:	4611      	mov	r1, r2
        uint16_t rxQueueSize, uint16_t txQueueSize)
{
    _channel = channel;
 80a3ef4:	7020      	strb	r0, [r4, #0]
#include "spark_wiring_can.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

CANChannel::CANChannel(HAL_CAN_Channel channel,
 80a3ef6:	461a      	mov	r2, r3
        uint16_t rxQueueSize, uint16_t txQueueSize)
{
    _channel = channel;
    HAL_CAN_Init(_channel, rxQueueSize, txQueueSize, NULL);
 80a3ef8:	2300      	movs	r3, #0
 80a3efa:	f7ff f9b1 	bl	80a3260 <HAL_CAN_Init>
}
 80a3efe:	4620      	mov	r0, r4
 80a3f00:	bd10      	pop	{r4, pc}

080a3f02 <_ZN10CANChannel5beginEmm>:
// Public Methods //////////////////////////////////////////////////////////////

void CANChannel::begin(unsigned long baud, uint32_t flags)
{
    HAL_CAN_Begin(_channel, baud, flags, NULL);
 80a3f02:	2300      	movs	r3, #0
 80a3f04:	7800      	ldrb	r0, [r0, #0]
 80a3f06:	f7ff b9b3 	b.w	80a3270 <HAL_CAN_Begin>

080a3f0a <_ZN10CANChannel7receiveER10CANMessage>:
    return HAL_CAN_Available_Messages(_channel, NULL);
}

bool CANChannel::receive(CANMessage &message)
{
    return HAL_CAN_Receive(_channel, &message, NULL);
 80a3f0a:	2200      	movs	r2, #0
 80a3f0c:	7800      	ldrb	r0, [r0, #0]
 80a3f0e:	f7ff b9b7 	b.w	80a3280 <HAL_CAN_Receive>

080a3f12 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a3f12:	4770      	bx	lr

080a3f14 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a3f14:	2200      	movs	r2, #0
 80a3f16:	4611      	mov	r1, r2
 80a3f18:	4610      	mov	r0, r2
 80a3f1a:	f7ff ba2d 	b.w	80a3378 <network_ready>
	...

080a3f20 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a3f20:	4803      	ldr	r0, [pc, #12]	; (80a3f30 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a3f22:	4b04      	ldr	r3, [pc, #16]	; (80a3f34 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a3f24:	4a04      	ldr	r2, [pc, #16]	; (80a3f38 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x18>)
 80a3f26:	4905      	ldr	r1, [pc, #20]	; (80a3f3c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x1c>)
 80a3f28:	6003      	str	r3, [r0, #0]
 80a3f2a:	f000 b8c9 	b.w	80a40c0 <__aeabi_atexit>
 80a3f2e:	bf00      	nop
 80a3f30:	20000fd0 	.word	0x20000fd0
 80a3f34:	080a5ba0 	.word	0x080a5ba0
 80a3f38:	200003c0 	.word	0x200003c0
 80a3f3c:	080a3f13 	.word	0x080a3f13

080a3f40 <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a3f40:	b510      	push	{r4, lr}
 80a3f42:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a3f44:	480f      	ldr	r0, [pc, #60]	; (80a3f84 <pinAvailable+0x44>)
 80a3f46:	f7ff fb3a 	bl	80a35be <_ZN8SPIClass9isEnabledEv>
 80a3f4a:	b128      	cbz	r0, 80a3f58 <pinAvailable+0x18>
 80a3f4c:	f1a4 030d 	sub.w	r3, r4, #13
 80a3f50:	2b02      	cmp	r3, #2
 80a3f52:	d801      	bhi.n	80a3f58 <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a3f54:	2000      	movs	r0, #0
 80a3f56:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a3f58:	f000 f892 	bl	80a4080 <_Z19__fetch_global_Wirev>
 80a3f5c:	f7ff ffc2 	bl	80a3ee4 <_ZN7TwoWire9isEnabledEv>
 80a3f60:	b108      	cbz	r0, 80a3f66 <pinAvailable+0x26>
 80a3f62:	2c01      	cmp	r4, #1
 80a3f64:	d9f6      	bls.n	80a3f54 <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a3f66:	f7ff ff59 	bl	80a3e1c <_Z22__fetch_global_Serial1v>
 80a3f6a:	f7ff ff54 	bl	80a3e16 <_ZN11USARTSerial9isEnabledEv>
 80a3f6e:	b118      	cbz	r0, 80a3f78 <pinAvailable+0x38>
 80a3f70:	f1a4 0312 	sub.w	r3, r4, #18
 80a3f74:	2b01      	cmp	r3, #1
 80a3f76:	d9ed      	bls.n	80a3f54 <pinAvailable+0x14>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a3f78:	2c17      	cmp	r4, #23
 80a3f7a:	bf8c      	ite	hi
 80a3f7c:	2000      	movhi	r0, #0
 80a3f7e:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a3f80:	bd10      	pop	{r4, pc}
 80a3f82:	bf00      	nop
 80a3f84:	20000fd4 	.word	0x20000fd4

080a3f88 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a3f88:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a3f8a:	b538      	push	{r3, r4, r5, lr}
 80a3f8c:	4604      	mov	r4, r0
 80a3f8e:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a3f90:	d80a      	bhi.n	80a3fa8 <pinMode+0x20>
 80a3f92:	29ff      	cmp	r1, #255	; 0xff
 80a3f94:	d008      	beq.n	80a3fa8 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a3f96:	f7ff ffd3 	bl	80a3f40 <pinAvailable>
 80a3f9a:	b128      	cbz	r0, 80a3fa8 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a3f9c:	4629      	mov	r1, r5
 80a3f9e:	4620      	mov	r0, r4
}
 80a3fa0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a3fa4:	f7fe bffa 	b.w	80a2f9c <HAL_Pin_Mode>
 80a3fa8:	bd38      	pop	{r3, r4, r5, pc}

080a3faa <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a3faa:	b538      	push	{r3, r4, r5, lr}
 80a3fac:	4604      	mov	r4, r0
 80a3fae:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a3fb0:	f7fe fffc 	bl	80a2fac <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a3fb4:	28ff      	cmp	r0, #255	; 0xff
 80a3fb6:	d010      	beq.n	80a3fda <digitalWrite+0x30>
}

inline bool is_input_mode(PinMode mode) {
    return  mode == INPUT ||
            mode == INPUT_PULLUP ||
            mode == INPUT_PULLDOWN ||
 80a3fb8:	2806      	cmp	r0, #6
 80a3fba:	d804      	bhi.n	80a3fc6 <digitalWrite+0x1c>
 80a3fbc:	234d      	movs	r3, #77	; 0x4d
 80a3fbe:	fa23 f000 	lsr.w	r0, r3, r0
 80a3fc2:	07c3      	lsls	r3, r0, #31
 80a3fc4:	d409      	bmi.n	80a3fda <digitalWrite+0x30>
{
    PinMode mode = HAL_Get_Pin_Mode(pin);
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a3fc6:	4620      	mov	r0, r4
 80a3fc8:	f7ff ffba 	bl	80a3f40 <pinAvailable>
 80a3fcc:	b128      	cbz	r0, 80a3fda <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a3fce:	4629      	mov	r1, r5
 80a3fd0:	4620      	mov	r0, r4
}
 80a3fd2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a3fd6:	f7fe bff1 	b.w	80a2fbc <HAL_GPIO_Write>
 80a3fda:	bd38      	pop	{r3, r4, r5, pc}

080a3fdc <analogRead>:
 * @brief Read the analog value of a pin.
 * Should return a 16-bit value, 0-65536 (0 = LOW, 65536 = HIGH)
 * Note: ADC is 12-bit. Currently it returns 0-4095
 */
int32_t analogRead(pin_t pin)
{
 80a3fdc:	b510      	push	{r4, lr}
 80a3fde:	4604      	mov	r4, r0
  // Allow people to use 0-7 to define analog pins by checking to see if the values are too low.
  if(pin < FIRST_ANALOG_PIN)
 80a3fe0:	2809      	cmp	r0, #9
  {
    pin = pin + FIRST_ANALOG_PIN;
 80a3fe2:	bf9c      	itt	ls
 80a3fe4:	340a      	addls	r4, #10
 80a3fe6:	b2a4      	uxthls	r4, r4
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a3fe8:	4620      	mov	r0, r4
 80a3fea:	f7ff ffa9 	bl	80a3f40 <pinAvailable>
 80a3fee:	b150      	cbz	r0, 80a4006 <analogRead+0x2a>
    return LOW;
  }

  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
 80a3ff0:	2103      	movs	r1, #3
 80a3ff2:	4620      	mov	r0, r4
 80a3ff4:	f7fe ffca 	bl	80a2f8c <HAL_Validate_Pin_Function>
 80a3ff8:	2803      	cmp	r0, #3
 80a3ffa:	d104      	bne.n	80a4006 <analogRead+0x2a>
  {
    return LOW;
  }

  return HAL_ADC_Read(pin);
 80a3ffc:	4620      	mov	r0, r4
}
 80a3ffe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
  {
    return LOW;
  }

  return HAL_ADC_Read(pin);
 80a4002:	f7fe bfe3 	b.w	80a2fcc <HAL_ADC_Read>
}
 80a4006:	2000      	movs	r0, #0
 80a4008:	bd10      	pop	{r4, pc}
	...

080a400c <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a400c:	b570      	push	{r4, r5, r6, lr}
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a400e:	4c0c      	ldr	r4, [pc, #48]	; (80a4040 <_GLOBAL__sub_I_SPI+0x34>)
 80a4010:	4e0c      	ldr	r6, [pc, #48]	; (80a4044 <_GLOBAL__sub_I_SPI+0x38>)
 80a4012:	4d0d      	ldr	r5, [pc, #52]	; (80a4048 <_GLOBAL__sub_I_SPI+0x3c>)
 80a4014:	2100      	movs	r1, #0
 80a4016:	4620      	mov	r0, r4
 80a4018:	f7ff fa16 	bl	80a3448 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a401c:	4620      	mov	r0, r4

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a401e:	4c0b      	ldr	r4, [pc, #44]	; (80a404c <_GLOBAL__sub_I_SPI+0x40>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a4020:	4632      	mov	r2, r6
 80a4022:	4629      	mov	r1, r5
 80a4024:	f000 f84c 	bl	80a40c0 <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a4028:	2101      	movs	r1, #1
 80a402a:	4620      	mov	r0, r4
 80a402c:	f7ff fa0c 	bl	80a3448 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a4030:	4632      	mov	r2, r6
 80a4032:	4629      	mov	r1, r5
 80a4034:	4620      	mov	r0, r4
 80a4036:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80a403a:	f000 b841 	b.w	80a40c0 <__aeabi_atexit>
 80a403e:	bf00      	nop
 80a4040:	20000fd4 	.word	0x20000fd4
 80a4044:	200003c0 	.word	0x200003c0
 80a4048:	080a3439 	.word	0x080a3439
 80a404c:	20000fe4 	.word	0x20000fe4

080a4050 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a4050:	b513      	push	{r0, r1, r4, lr}
 80a4052:	4c08      	ldr	r4, [pc, #32]	; (80a4074 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a4054:	2300      	movs	r3, #0
 80a4056:	461a      	mov	r2, r3
 80a4058:	4619      	mov	r1, r3
 80a405a:	9300      	str	r3, [sp, #0]
 80a405c:	4620      	mov	r0, r4
 80a405e:	f7ff fd8f 	bl	80a3b80 <_ZN9IPAddressC1Ehhhh>
 80a4062:	4620      	mov	r0, r4
 80a4064:	4a04      	ldr	r2, [pc, #16]	; (80a4078 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a4066:	4905      	ldr	r1, [pc, #20]	; (80a407c <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a4068:	b002      	add	sp, #8
 80a406a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a406e:	f000 b827 	b.w	80a40c0 <__aeabi_atexit>
 80a4072:	bf00      	nop
 80a4074:	20000ff8 	.word	0x20000ff8
 80a4078:	200003c0 	.word	0x200003c0
 80a407c:	080a3b25 	.word	0x080a3b25

080a4080 <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a4080:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a4082:	4d0b      	ldr	r5, [pc, #44]	; (80a40b0 <_Z19__fetch_global_Wirev+0x30>)
 80a4084:	6829      	ldr	r1, [r5, #0]
 80a4086:	f011 0401 	ands.w	r4, r1, #1
 80a408a:	d10f      	bne.n	80a40ac <_Z19__fetch_global_Wirev+0x2c>
 80a408c:	4628      	mov	r0, r5
 80a408e:	f7fc f808 	bl	80a00a2 <__cxa_guard_acquire>
 80a4092:	b158      	cbz	r0, 80a40ac <_Z19__fetch_global_Wirev+0x2c>
 80a4094:	4621      	mov	r1, r4
 80a4096:	4807      	ldr	r0, [pc, #28]	; (80a40b4 <_Z19__fetch_global_Wirev+0x34>)
 80a4098:	f7ff ff12 	bl	80a3ec0 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a409c:	4628      	mov	r0, r5
 80a409e:	f7fc f805 	bl	80a00ac <__cxa_guard_release>
 80a40a2:	4a05      	ldr	r2, [pc, #20]	; (80a40b8 <_Z19__fetch_global_Wirev+0x38>)
 80a40a4:	4905      	ldr	r1, [pc, #20]	; (80a40bc <_Z19__fetch_global_Wirev+0x3c>)
 80a40a6:	4803      	ldr	r0, [pc, #12]	; (80a40b4 <_Z19__fetch_global_Wirev+0x34>)
 80a40a8:	f000 f80a 	bl	80a40c0 <__aeabi_atexit>
	return wire;
}
 80a40ac:	4801      	ldr	r0, [pc, #4]	; (80a40b4 <_Z19__fetch_global_Wirev+0x34>)
 80a40ae:	bd38      	pop	{r3, r4, r5, pc}
 80a40b0:	20001010 	.word	0x20001010
 80a40b4:	20001014 	.word	0x20001014
 80a40b8:	200003c0 	.word	0x200003c0
 80a40bc:	080a3e69 	.word	0x080a3e69

080a40c0 <__aeabi_atexit>:
 80a40c0:	460b      	mov	r3, r1
 80a40c2:	4601      	mov	r1, r0
 80a40c4:	4618      	mov	r0, r3
 80a40c6:	f000 be05 	b.w	80a4cd4 <__cxa_atexit>
	...

080a40cc <_ZSt15get_new_handlerv>:
 80a40cc:	4b02      	ldr	r3, [pc, #8]	; (80a40d8 <_ZSt15get_new_handlerv+0xc>)
 80a40ce:	6818      	ldr	r0, [r3, #0]
 80a40d0:	f3bf 8f5f 	dmb	sy
 80a40d4:	4770      	bx	lr
 80a40d6:	bf00      	nop
 80a40d8:	20001028 	.word	0x20001028

080a40dc <_ZnwjRKSt9nothrow_t>:
 80a40dc:	b510      	push	{r4, lr}
 80a40de:	2800      	cmp	r0, #0
 80a40e0:	bf14      	ite	ne
 80a40e2:	4604      	movne	r4, r0
 80a40e4:	2401      	moveq	r4, #1
 80a40e6:	4620      	mov	r0, r4
 80a40e8:	f7ff f96e 	bl	80a33c8 <malloc>
 80a40ec:	b920      	cbnz	r0, 80a40f8 <_ZnwjRKSt9nothrow_t+0x1c>
 80a40ee:	f7ff ffed 	bl	80a40cc <_ZSt15get_new_handlerv>
 80a40f2:	b108      	cbz	r0, 80a40f8 <_ZnwjRKSt9nothrow_t+0x1c>
 80a40f4:	4780      	blx	r0
 80a40f6:	e7f6      	b.n	80a40e6 <_ZnwjRKSt9nothrow_t+0xa>
 80a40f8:	bd10      	pop	{r4, pc}

080a40fa <_ZSt25__throw_bad_function_callv>:
 80a40fa:	b508      	push	{r3, lr}
 80a40fc:	f7ff f98c 	bl	80a3418 <abort>

080a4100 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a4100:	4b18      	ldr	r3, [pc, #96]	; (80a4164 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a4102:	681a      	ldr	r2, [r3, #0]
 80a4104:	07d1      	lsls	r1, r2, #31
 80a4106:	bf5c      	itt	pl
 80a4108:	2201      	movpl	r2, #1
 80a410a:	601a      	strpl	r2, [r3, #0]
 80a410c:	4b16      	ldr	r3, [pc, #88]	; (80a4168 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a410e:	681a      	ldr	r2, [r3, #0]
 80a4110:	07d2      	lsls	r2, r2, #31
 80a4112:	bf5c      	itt	pl
 80a4114:	2201      	movpl	r2, #1
 80a4116:	601a      	strpl	r2, [r3, #0]
 80a4118:	4b14      	ldr	r3, [pc, #80]	; (80a416c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a411a:	681a      	ldr	r2, [r3, #0]
 80a411c:	07d0      	lsls	r0, r2, #31
 80a411e:	bf5c      	itt	pl
 80a4120:	2201      	movpl	r2, #1
 80a4122:	601a      	strpl	r2, [r3, #0]
 80a4124:	4b12      	ldr	r3, [pc, #72]	; (80a4170 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a4126:	681a      	ldr	r2, [r3, #0]
 80a4128:	07d1      	lsls	r1, r2, #31
 80a412a:	bf5c      	itt	pl
 80a412c:	2201      	movpl	r2, #1
 80a412e:	601a      	strpl	r2, [r3, #0]
 80a4130:	4b10      	ldr	r3, [pc, #64]	; (80a4174 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a4132:	681a      	ldr	r2, [r3, #0]
 80a4134:	07d2      	lsls	r2, r2, #31
 80a4136:	bf5c      	itt	pl
 80a4138:	2201      	movpl	r2, #1
 80a413a:	601a      	strpl	r2, [r3, #0]
 80a413c:	4b0e      	ldr	r3, [pc, #56]	; (80a4178 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a413e:	681a      	ldr	r2, [r3, #0]
 80a4140:	07d0      	lsls	r0, r2, #31
 80a4142:	bf5c      	itt	pl
 80a4144:	2201      	movpl	r2, #1
 80a4146:	601a      	strpl	r2, [r3, #0]
 80a4148:	4b0c      	ldr	r3, [pc, #48]	; (80a417c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a414a:	681a      	ldr	r2, [r3, #0]
 80a414c:	07d1      	lsls	r1, r2, #31
 80a414e:	bf5c      	itt	pl
 80a4150:	2201      	movpl	r2, #1
 80a4152:	601a      	strpl	r2, [r3, #0]
 80a4154:	4b0a      	ldr	r3, [pc, #40]	; (80a4180 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a4156:	681a      	ldr	r2, [r3, #0]
 80a4158:	07d2      	lsls	r2, r2, #31
 80a415a:	bf5c      	itt	pl
 80a415c:	2201      	movpl	r2, #1
 80a415e:	601a      	strpl	r2, [r3, #0]
 80a4160:	4770      	bx	lr
 80a4162:	bf00      	nop
 80a4164:	20001048 	.word	0x20001048
 80a4168:	20001044 	.word	0x20001044
 80a416c:	20001040 	.word	0x20001040
 80a4170:	2000103c 	.word	0x2000103c
 80a4174:	20001038 	.word	0x20001038
 80a4178:	20001034 	.word	0x20001034
 80a417c:	20001030 	.word	0x20001030
 80a4180:	2000102c 	.word	0x2000102c

080a4184 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
 80a4184:	4b24      	ldr	r3, [pc, #144]	; (80a4218 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
 80a4186:	681a      	ldr	r2, [r3, #0]
 80a4188:	07d0      	lsls	r0, r2, #31
 80a418a:	bf5c      	itt	pl
 80a418c:	2201      	movpl	r2, #1
 80a418e:	601a      	strpl	r2, [r3, #0]
 80a4190:	4b22      	ldr	r3, [pc, #136]	; (80a421c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
 80a4192:	681a      	ldr	r2, [r3, #0]
 80a4194:	07d1      	lsls	r1, r2, #31
 80a4196:	bf5c      	itt	pl
 80a4198:	2201      	movpl	r2, #1
 80a419a:	601a      	strpl	r2, [r3, #0]
 80a419c:	4b20      	ldr	r3, [pc, #128]	; (80a4220 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
 80a419e:	681a      	ldr	r2, [r3, #0]
 80a41a0:	07d2      	lsls	r2, r2, #31
 80a41a2:	bf5c      	itt	pl
 80a41a4:	2201      	movpl	r2, #1
 80a41a6:	601a      	strpl	r2, [r3, #0]
 80a41a8:	4b1e      	ldr	r3, [pc, #120]	; (80a4224 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
 80a41aa:	681a      	ldr	r2, [r3, #0]
 80a41ac:	07d0      	lsls	r0, r2, #31
 80a41ae:	bf5c      	itt	pl
 80a41b0:	2201      	movpl	r2, #1
 80a41b2:	601a      	strpl	r2, [r3, #0]
 80a41b4:	4b1c      	ldr	r3, [pc, #112]	; (80a4228 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
 80a41b6:	681a      	ldr	r2, [r3, #0]
 80a41b8:	07d1      	lsls	r1, r2, #31
 80a41ba:	bf5c      	itt	pl
 80a41bc:	2201      	movpl	r2, #1
 80a41be:	601a      	strpl	r2, [r3, #0]
 80a41c0:	4b1a      	ldr	r3, [pc, #104]	; (80a422c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
 80a41c2:	681a      	ldr	r2, [r3, #0]
 80a41c4:	07d2      	lsls	r2, r2, #31
 80a41c6:	bf5c      	itt	pl
 80a41c8:	2201      	movpl	r2, #1
 80a41ca:	601a      	strpl	r2, [r3, #0]
 80a41cc:	4b18      	ldr	r3, [pc, #96]	; (80a4230 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
 80a41ce:	681a      	ldr	r2, [r3, #0]
 80a41d0:	07d0      	lsls	r0, r2, #31
 80a41d2:	bf5c      	itt	pl
 80a41d4:	2201      	movpl	r2, #1
 80a41d6:	601a      	strpl	r2, [r3, #0]
 80a41d8:	4b16      	ldr	r3, [pc, #88]	; (80a4234 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
 80a41da:	681a      	ldr	r2, [r3, #0]
 80a41dc:	07d1      	lsls	r1, r2, #31
 80a41de:	bf5c      	itt	pl
 80a41e0:	2201      	movpl	r2, #1
 80a41e2:	601a      	strpl	r2, [r3, #0]
 80a41e4:	4b14      	ldr	r3, [pc, #80]	; (80a4238 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
 80a41e6:	681a      	ldr	r2, [r3, #0]
 80a41e8:	07d2      	lsls	r2, r2, #31
 80a41ea:	bf5c      	itt	pl
 80a41ec:	2201      	movpl	r2, #1
 80a41ee:	601a      	strpl	r2, [r3, #0]
 80a41f0:	4b12      	ldr	r3, [pc, #72]	; (80a423c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
 80a41f2:	681a      	ldr	r2, [r3, #0]
 80a41f4:	07d0      	lsls	r0, r2, #31
 80a41f6:	bf5c      	itt	pl
 80a41f8:	2201      	movpl	r2, #1
 80a41fa:	601a      	strpl	r2, [r3, #0]
 80a41fc:	4b10      	ldr	r3, [pc, #64]	; (80a4240 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
 80a41fe:	681a      	ldr	r2, [r3, #0]
 80a4200:	07d1      	lsls	r1, r2, #31
 80a4202:	bf5c      	itt	pl
 80a4204:	2201      	movpl	r2, #1
 80a4206:	601a      	strpl	r2, [r3, #0]
 80a4208:	4b0e      	ldr	r3, [pc, #56]	; (80a4244 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
 80a420a:	681a      	ldr	r2, [r3, #0]
 80a420c:	07d2      	lsls	r2, r2, #31
 80a420e:	bf5c      	itt	pl
 80a4210:	2201      	movpl	r2, #1
 80a4212:	601a      	strpl	r2, [r3, #0]
 80a4214:	4770      	bx	lr
 80a4216:	bf00      	nop
 80a4218:	20001078 	.word	0x20001078
 80a421c:	20001074 	.word	0x20001074
 80a4220:	20001070 	.word	0x20001070
 80a4224:	2000106c 	.word	0x2000106c
 80a4228:	20001068 	.word	0x20001068
 80a422c:	20001064 	.word	0x20001064
 80a4230:	20001060 	.word	0x20001060
 80a4234:	2000105c 	.word	0x2000105c
 80a4238:	20001058 	.word	0x20001058
 80a423c:	20001054 	.word	0x20001054
 80a4240:	20001050 	.word	0x20001050
 80a4244:	2000104c 	.word	0x2000104c

080a4248 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
 80a4248:	4b24      	ldr	r3, [pc, #144]	; (80a42dc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
 80a424a:	681a      	ldr	r2, [r3, #0]
 80a424c:	07d0      	lsls	r0, r2, #31
 80a424e:	bf5c      	itt	pl
 80a4250:	2201      	movpl	r2, #1
 80a4252:	601a      	strpl	r2, [r3, #0]
 80a4254:	4b22      	ldr	r3, [pc, #136]	; (80a42e0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
 80a4256:	681a      	ldr	r2, [r3, #0]
 80a4258:	07d1      	lsls	r1, r2, #31
 80a425a:	bf5c      	itt	pl
 80a425c:	2201      	movpl	r2, #1
 80a425e:	601a      	strpl	r2, [r3, #0]
 80a4260:	4b20      	ldr	r3, [pc, #128]	; (80a42e4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
 80a4262:	681a      	ldr	r2, [r3, #0]
 80a4264:	07d2      	lsls	r2, r2, #31
 80a4266:	bf5c      	itt	pl
 80a4268:	2201      	movpl	r2, #1
 80a426a:	601a      	strpl	r2, [r3, #0]
 80a426c:	4b1e      	ldr	r3, [pc, #120]	; (80a42e8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
 80a426e:	681a      	ldr	r2, [r3, #0]
 80a4270:	07d0      	lsls	r0, r2, #31
 80a4272:	bf5c      	itt	pl
 80a4274:	2201      	movpl	r2, #1
 80a4276:	601a      	strpl	r2, [r3, #0]
 80a4278:	4b1c      	ldr	r3, [pc, #112]	; (80a42ec <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
 80a427a:	681a      	ldr	r2, [r3, #0]
 80a427c:	07d1      	lsls	r1, r2, #31
 80a427e:	bf5c      	itt	pl
 80a4280:	2201      	movpl	r2, #1
 80a4282:	601a      	strpl	r2, [r3, #0]
 80a4284:	4b1a      	ldr	r3, [pc, #104]	; (80a42f0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
 80a4286:	681a      	ldr	r2, [r3, #0]
 80a4288:	07d2      	lsls	r2, r2, #31
 80a428a:	bf5c      	itt	pl
 80a428c:	2201      	movpl	r2, #1
 80a428e:	601a      	strpl	r2, [r3, #0]
 80a4290:	4b18      	ldr	r3, [pc, #96]	; (80a42f4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
 80a4292:	681a      	ldr	r2, [r3, #0]
 80a4294:	07d0      	lsls	r0, r2, #31
 80a4296:	bf5c      	itt	pl
 80a4298:	2201      	movpl	r2, #1
 80a429a:	601a      	strpl	r2, [r3, #0]
 80a429c:	4b16      	ldr	r3, [pc, #88]	; (80a42f8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
 80a429e:	681a      	ldr	r2, [r3, #0]
 80a42a0:	07d1      	lsls	r1, r2, #31
 80a42a2:	bf5c      	itt	pl
 80a42a4:	2201      	movpl	r2, #1
 80a42a6:	601a      	strpl	r2, [r3, #0]
 80a42a8:	4b14      	ldr	r3, [pc, #80]	; (80a42fc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
 80a42aa:	681a      	ldr	r2, [r3, #0]
 80a42ac:	07d2      	lsls	r2, r2, #31
 80a42ae:	bf5c      	itt	pl
 80a42b0:	2201      	movpl	r2, #1
 80a42b2:	601a      	strpl	r2, [r3, #0]
 80a42b4:	4b12      	ldr	r3, [pc, #72]	; (80a4300 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
 80a42b6:	681a      	ldr	r2, [r3, #0]
 80a42b8:	07d0      	lsls	r0, r2, #31
 80a42ba:	bf5c      	itt	pl
 80a42bc:	2201      	movpl	r2, #1
 80a42be:	601a      	strpl	r2, [r3, #0]
 80a42c0:	4b10      	ldr	r3, [pc, #64]	; (80a4304 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
 80a42c2:	681a      	ldr	r2, [r3, #0]
 80a42c4:	07d1      	lsls	r1, r2, #31
 80a42c6:	bf5c      	itt	pl
 80a42c8:	2201      	movpl	r2, #1
 80a42ca:	601a      	strpl	r2, [r3, #0]
 80a42cc:	4b0e      	ldr	r3, [pc, #56]	; (80a4308 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
 80a42ce:	681a      	ldr	r2, [r3, #0]
 80a42d0:	07d2      	lsls	r2, r2, #31
 80a42d2:	bf5c      	itt	pl
 80a42d4:	2201      	movpl	r2, #1
 80a42d6:	601a      	strpl	r2, [r3, #0]
 80a42d8:	4770      	bx	lr
 80a42da:	bf00      	nop
 80a42dc:	200010a8 	.word	0x200010a8
 80a42e0:	200010a4 	.word	0x200010a4
 80a42e4:	200010a0 	.word	0x200010a0
 80a42e8:	2000109c 	.word	0x2000109c
 80a42ec:	20001098 	.word	0x20001098
 80a42f0:	20001094 	.word	0x20001094
 80a42f4:	20001090 	.word	0x20001090
 80a42f8:	2000108c 	.word	0x2000108c
 80a42fc:	20001088 	.word	0x20001088
 80a4300:	20001084 	.word	0x20001084
 80a4304:	20001080 	.word	0x20001080
 80a4308:	2000107c 	.word	0x2000107c

080a430c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a430c:	4b18      	ldr	r3, [pc, #96]	; (80a4370 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a430e:	681a      	ldr	r2, [r3, #0]
 80a4310:	07d1      	lsls	r1, r2, #31
 80a4312:	bf5c      	itt	pl
 80a4314:	2201      	movpl	r2, #1
 80a4316:	601a      	strpl	r2, [r3, #0]
 80a4318:	4b16      	ldr	r3, [pc, #88]	; (80a4374 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a431a:	681a      	ldr	r2, [r3, #0]
 80a431c:	07d2      	lsls	r2, r2, #31
 80a431e:	bf5c      	itt	pl
 80a4320:	2201      	movpl	r2, #1
 80a4322:	601a      	strpl	r2, [r3, #0]
 80a4324:	4b14      	ldr	r3, [pc, #80]	; (80a4378 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a4326:	681a      	ldr	r2, [r3, #0]
 80a4328:	07d0      	lsls	r0, r2, #31
 80a432a:	bf5c      	itt	pl
 80a432c:	2201      	movpl	r2, #1
 80a432e:	601a      	strpl	r2, [r3, #0]
 80a4330:	4b12      	ldr	r3, [pc, #72]	; (80a437c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a4332:	681a      	ldr	r2, [r3, #0]
 80a4334:	07d1      	lsls	r1, r2, #31
 80a4336:	bf5c      	itt	pl
 80a4338:	2201      	movpl	r2, #1
 80a433a:	601a      	strpl	r2, [r3, #0]
 80a433c:	4b10      	ldr	r3, [pc, #64]	; (80a4380 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a433e:	681a      	ldr	r2, [r3, #0]
 80a4340:	07d2      	lsls	r2, r2, #31
 80a4342:	bf5c      	itt	pl
 80a4344:	2201      	movpl	r2, #1
 80a4346:	601a      	strpl	r2, [r3, #0]
 80a4348:	4b0e      	ldr	r3, [pc, #56]	; (80a4384 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a434a:	681a      	ldr	r2, [r3, #0]
 80a434c:	07d0      	lsls	r0, r2, #31
 80a434e:	bf5c      	itt	pl
 80a4350:	2201      	movpl	r2, #1
 80a4352:	601a      	strpl	r2, [r3, #0]
 80a4354:	4b0c      	ldr	r3, [pc, #48]	; (80a4388 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a4356:	681a      	ldr	r2, [r3, #0]
 80a4358:	07d1      	lsls	r1, r2, #31
 80a435a:	bf5c      	itt	pl
 80a435c:	2201      	movpl	r2, #1
 80a435e:	601a      	strpl	r2, [r3, #0]
 80a4360:	4b0a      	ldr	r3, [pc, #40]	; (80a438c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a4362:	681a      	ldr	r2, [r3, #0]
 80a4364:	07d2      	lsls	r2, r2, #31
 80a4366:	bf5c      	itt	pl
 80a4368:	2201      	movpl	r2, #1
 80a436a:	601a      	strpl	r2, [r3, #0]
 80a436c:	4770      	bx	lr
 80a436e:	bf00      	nop
 80a4370:	200010c8 	.word	0x200010c8
 80a4374:	200010c4 	.word	0x200010c4
 80a4378:	200010c0 	.word	0x200010c0
 80a437c:	200010bc 	.word	0x200010bc
 80a4380:	200010b8 	.word	0x200010b8
 80a4384:	200010b4 	.word	0x200010b4
 80a4388:	200010b0 	.word	0x200010b0
 80a438c:	200010ac 	.word	0x200010ac

080a4390 <__aeabi_drsub>:
 80a4390:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80a4394:	e002      	b.n	80a439c <__adddf3>
 80a4396:	bf00      	nop

080a4398 <__aeabi_dsub>:
 80a4398:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080a439c <__adddf3>:
 80a439c:	b530      	push	{r4, r5, lr}
 80a439e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80a43a2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80a43a6:	ea94 0f05 	teq	r4, r5
 80a43aa:	bf08      	it	eq
 80a43ac:	ea90 0f02 	teqeq	r0, r2
 80a43b0:	bf1f      	itttt	ne
 80a43b2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80a43b6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80a43ba:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80a43be:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a43c2:	f000 80e2 	beq.w	80a458a <__adddf3+0x1ee>
 80a43c6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80a43ca:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80a43ce:	bfb8      	it	lt
 80a43d0:	426d      	neglt	r5, r5
 80a43d2:	dd0c      	ble.n	80a43ee <__adddf3+0x52>
 80a43d4:	442c      	add	r4, r5
 80a43d6:	ea80 0202 	eor.w	r2, r0, r2
 80a43da:	ea81 0303 	eor.w	r3, r1, r3
 80a43de:	ea82 0000 	eor.w	r0, r2, r0
 80a43e2:	ea83 0101 	eor.w	r1, r3, r1
 80a43e6:	ea80 0202 	eor.w	r2, r0, r2
 80a43ea:	ea81 0303 	eor.w	r3, r1, r3
 80a43ee:	2d36      	cmp	r5, #54	; 0x36
 80a43f0:	bf88      	it	hi
 80a43f2:	bd30      	pophi	{r4, r5, pc}
 80a43f4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a43f8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a43fc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80a4400:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80a4404:	d002      	beq.n	80a440c <__adddf3+0x70>
 80a4406:	4240      	negs	r0, r0
 80a4408:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a440c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80a4410:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a4414:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80a4418:	d002      	beq.n	80a4420 <__adddf3+0x84>
 80a441a:	4252      	negs	r2, r2
 80a441c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a4420:	ea94 0f05 	teq	r4, r5
 80a4424:	f000 80a7 	beq.w	80a4576 <__adddf3+0x1da>
 80a4428:	f1a4 0401 	sub.w	r4, r4, #1
 80a442c:	f1d5 0e20 	rsbs	lr, r5, #32
 80a4430:	db0d      	blt.n	80a444e <__adddf3+0xb2>
 80a4432:	fa02 fc0e 	lsl.w	ip, r2, lr
 80a4436:	fa22 f205 	lsr.w	r2, r2, r5
 80a443a:	1880      	adds	r0, r0, r2
 80a443c:	f141 0100 	adc.w	r1, r1, #0
 80a4440:	fa03 f20e 	lsl.w	r2, r3, lr
 80a4444:	1880      	adds	r0, r0, r2
 80a4446:	fa43 f305 	asr.w	r3, r3, r5
 80a444a:	4159      	adcs	r1, r3
 80a444c:	e00e      	b.n	80a446c <__adddf3+0xd0>
 80a444e:	f1a5 0520 	sub.w	r5, r5, #32
 80a4452:	f10e 0e20 	add.w	lr, lr, #32
 80a4456:	2a01      	cmp	r2, #1
 80a4458:	fa03 fc0e 	lsl.w	ip, r3, lr
 80a445c:	bf28      	it	cs
 80a445e:	f04c 0c02 	orrcs.w	ip, ip, #2
 80a4462:	fa43 f305 	asr.w	r3, r3, r5
 80a4466:	18c0      	adds	r0, r0, r3
 80a4468:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80a446c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a4470:	d507      	bpl.n	80a4482 <__adddf3+0xe6>
 80a4472:	f04f 0e00 	mov.w	lr, #0
 80a4476:	f1dc 0c00 	rsbs	ip, ip, #0
 80a447a:	eb7e 0000 	sbcs.w	r0, lr, r0
 80a447e:	eb6e 0101 	sbc.w	r1, lr, r1
 80a4482:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80a4486:	d31b      	bcc.n	80a44c0 <__adddf3+0x124>
 80a4488:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80a448c:	d30c      	bcc.n	80a44a8 <__adddf3+0x10c>
 80a448e:	0849      	lsrs	r1, r1, #1
 80a4490:	ea5f 0030 	movs.w	r0, r0, rrx
 80a4494:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80a4498:	f104 0401 	add.w	r4, r4, #1
 80a449c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80a44a0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80a44a4:	f080 809a 	bcs.w	80a45dc <__adddf3+0x240>
 80a44a8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a44ac:	bf08      	it	eq
 80a44ae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a44b2:	f150 0000 	adcs.w	r0, r0, #0
 80a44b6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a44ba:	ea41 0105 	orr.w	r1, r1, r5
 80a44be:	bd30      	pop	{r4, r5, pc}
 80a44c0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80a44c4:	4140      	adcs	r0, r0
 80a44c6:	eb41 0101 	adc.w	r1, r1, r1
 80a44ca:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a44ce:	f1a4 0401 	sub.w	r4, r4, #1
 80a44d2:	d1e9      	bne.n	80a44a8 <__adddf3+0x10c>
 80a44d4:	f091 0f00 	teq	r1, #0
 80a44d8:	bf04      	itt	eq
 80a44da:	4601      	moveq	r1, r0
 80a44dc:	2000      	moveq	r0, #0
 80a44de:	fab1 f381 	clz	r3, r1
 80a44e2:	bf08      	it	eq
 80a44e4:	3320      	addeq	r3, #32
 80a44e6:	f1a3 030b 	sub.w	r3, r3, #11
 80a44ea:	f1b3 0220 	subs.w	r2, r3, #32
 80a44ee:	da0c      	bge.n	80a450a <__adddf3+0x16e>
 80a44f0:	320c      	adds	r2, #12
 80a44f2:	dd08      	ble.n	80a4506 <__adddf3+0x16a>
 80a44f4:	f102 0c14 	add.w	ip, r2, #20
 80a44f8:	f1c2 020c 	rsb	r2, r2, #12
 80a44fc:	fa01 f00c 	lsl.w	r0, r1, ip
 80a4500:	fa21 f102 	lsr.w	r1, r1, r2
 80a4504:	e00c      	b.n	80a4520 <__adddf3+0x184>
 80a4506:	f102 0214 	add.w	r2, r2, #20
 80a450a:	bfd8      	it	le
 80a450c:	f1c2 0c20 	rsble	ip, r2, #32
 80a4510:	fa01 f102 	lsl.w	r1, r1, r2
 80a4514:	fa20 fc0c 	lsr.w	ip, r0, ip
 80a4518:	bfdc      	itt	le
 80a451a:	ea41 010c 	orrle.w	r1, r1, ip
 80a451e:	4090      	lslle	r0, r2
 80a4520:	1ae4      	subs	r4, r4, r3
 80a4522:	bfa2      	ittt	ge
 80a4524:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80a4528:	4329      	orrge	r1, r5
 80a452a:	bd30      	popge	{r4, r5, pc}
 80a452c:	ea6f 0404 	mvn.w	r4, r4
 80a4530:	3c1f      	subs	r4, #31
 80a4532:	da1c      	bge.n	80a456e <__adddf3+0x1d2>
 80a4534:	340c      	adds	r4, #12
 80a4536:	dc0e      	bgt.n	80a4556 <__adddf3+0x1ba>
 80a4538:	f104 0414 	add.w	r4, r4, #20
 80a453c:	f1c4 0220 	rsb	r2, r4, #32
 80a4540:	fa20 f004 	lsr.w	r0, r0, r4
 80a4544:	fa01 f302 	lsl.w	r3, r1, r2
 80a4548:	ea40 0003 	orr.w	r0, r0, r3
 80a454c:	fa21 f304 	lsr.w	r3, r1, r4
 80a4550:	ea45 0103 	orr.w	r1, r5, r3
 80a4554:	bd30      	pop	{r4, r5, pc}
 80a4556:	f1c4 040c 	rsb	r4, r4, #12
 80a455a:	f1c4 0220 	rsb	r2, r4, #32
 80a455e:	fa20 f002 	lsr.w	r0, r0, r2
 80a4562:	fa01 f304 	lsl.w	r3, r1, r4
 80a4566:	ea40 0003 	orr.w	r0, r0, r3
 80a456a:	4629      	mov	r1, r5
 80a456c:	bd30      	pop	{r4, r5, pc}
 80a456e:	fa21 f004 	lsr.w	r0, r1, r4
 80a4572:	4629      	mov	r1, r5
 80a4574:	bd30      	pop	{r4, r5, pc}
 80a4576:	f094 0f00 	teq	r4, #0
 80a457a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80a457e:	bf06      	itte	eq
 80a4580:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80a4584:	3401      	addeq	r4, #1
 80a4586:	3d01      	subne	r5, #1
 80a4588:	e74e      	b.n	80a4428 <__adddf3+0x8c>
 80a458a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a458e:	bf18      	it	ne
 80a4590:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a4594:	d029      	beq.n	80a45ea <__adddf3+0x24e>
 80a4596:	ea94 0f05 	teq	r4, r5
 80a459a:	bf08      	it	eq
 80a459c:	ea90 0f02 	teqeq	r0, r2
 80a45a0:	d005      	beq.n	80a45ae <__adddf3+0x212>
 80a45a2:	ea54 0c00 	orrs.w	ip, r4, r0
 80a45a6:	bf04      	itt	eq
 80a45a8:	4619      	moveq	r1, r3
 80a45aa:	4610      	moveq	r0, r2
 80a45ac:	bd30      	pop	{r4, r5, pc}
 80a45ae:	ea91 0f03 	teq	r1, r3
 80a45b2:	bf1e      	ittt	ne
 80a45b4:	2100      	movne	r1, #0
 80a45b6:	2000      	movne	r0, #0
 80a45b8:	bd30      	popne	{r4, r5, pc}
 80a45ba:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80a45be:	d105      	bne.n	80a45cc <__adddf3+0x230>
 80a45c0:	0040      	lsls	r0, r0, #1
 80a45c2:	4149      	adcs	r1, r1
 80a45c4:	bf28      	it	cs
 80a45c6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80a45ca:	bd30      	pop	{r4, r5, pc}
 80a45cc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80a45d0:	bf3c      	itt	cc
 80a45d2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80a45d6:	bd30      	popcc	{r4, r5, pc}
 80a45d8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a45dc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80a45e0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a45e4:	f04f 0000 	mov.w	r0, #0
 80a45e8:	bd30      	pop	{r4, r5, pc}
 80a45ea:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a45ee:	bf1a      	itte	ne
 80a45f0:	4619      	movne	r1, r3
 80a45f2:	4610      	movne	r0, r2
 80a45f4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80a45f8:	bf1c      	itt	ne
 80a45fa:	460b      	movne	r3, r1
 80a45fc:	4602      	movne	r2, r0
 80a45fe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a4602:	bf06      	itte	eq
 80a4604:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80a4608:	ea91 0f03 	teqeq	r1, r3
 80a460c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80a4610:	bd30      	pop	{r4, r5, pc}
 80a4612:	bf00      	nop

080a4614 <__aeabi_ui2d>:
 80a4614:	f090 0f00 	teq	r0, #0
 80a4618:	bf04      	itt	eq
 80a461a:	2100      	moveq	r1, #0
 80a461c:	4770      	bxeq	lr
 80a461e:	b530      	push	{r4, r5, lr}
 80a4620:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a4624:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a4628:	f04f 0500 	mov.w	r5, #0
 80a462c:	f04f 0100 	mov.w	r1, #0
 80a4630:	e750      	b.n	80a44d4 <__adddf3+0x138>
 80a4632:	bf00      	nop

080a4634 <__aeabi_i2d>:
 80a4634:	f090 0f00 	teq	r0, #0
 80a4638:	bf04      	itt	eq
 80a463a:	2100      	moveq	r1, #0
 80a463c:	4770      	bxeq	lr
 80a463e:	b530      	push	{r4, r5, lr}
 80a4640:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a4644:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a4648:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80a464c:	bf48      	it	mi
 80a464e:	4240      	negmi	r0, r0
 80a4650:	f04f 0100 	mov.w	r1, #0
 80a4654:	e73e      	b.n	80a44d4 <__adddf3+0x138>
 80a4656:	bf00      	nop

080a4658 <__aeabi_f2d>:
 80a4658:	0042      	lsls	r2, r0, #1
 80a465a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80a465e:	ea4f 0131 	mov.w	r1, r1, rrx
 80a4662:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80a4666:	bf1f      	itttt	ne
 80a4668:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80a466c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a4670:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80a4674:	4770      	bxne	lr
 80a4676:	f092 0f00 	teq	r2, #0
 80a467a:	bf14      	ite	ne
 80a467c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a4680:	4770      	bxeq	lr
 80a4682:	b530      	push	{r4, r5, lr}
 80a4684:	f44f 7460 	mov.w	r4, #896	; 0x380
 80a4688:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a468c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a4690:	e720      	b.n	80a44d4 <__adddf3+0x138>
 80a4692:	bf00      	nop

080a4694 <__aeabi_ul2d>:
 80a4694:	ea50 0201 	orrs.w	r2, r0, r1
 80a4698:	bf08      	it	eq
 80a469a:	4770      	bxeq	lr
 80a469c:	b530      	push	{r4, r5, lr}
 80a469e:	f04f 0500 	mov.w	r5, #0
 80a46a2:	e00a      	b.n	80a46ba <__aeabi_l2d+0x16>

080a46a4 <__aeabi_l2d>:
 80a46a4:	ea50 0201 	orrs.w	r2, r0, r1
 80a46a8:	bf08      	it	eq
 80a46aa:	4770      	bxeq	lr
 80a46ac:	b530      	push	{r4, r5, lr}
 80a46ae:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80a46b2:	d502      	bpl.n	80a46ba <__aeabi_l2d+0x16>
 80a46b4:	4240      	negs	r0, r0
 80a46b6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a46ba:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a46be:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a46c2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80a46c6:	f43f aedc 	beq.w	80a4482 <__adddf3+0xe6>
 80a46ca:	f04f 0203 	mov.w	r2, #3
 80a46ce:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a46d2:	bf18      	it	ne
 80a46d4:	3203      	addne	r2, #3
 80a46d6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a46da:	bf18      	it	ne
 80a46dc:	3203      	addne	r2, #3
 80a46de:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80a46e2:	f1c2 0320 	rsb	r3, r2, #32
 80a46e6:	fa00 fc03 	lsl.w	ip, r0, r3
 80a46ea:	fa20 f002 	lsr.w	r0, r0, r2
 80a46ee:	fa01 fe03 	lsl.w	lr, r1, r3
 80a46f2:	ea40 000e 	orr.w	r0, r0, lr
 80a46f6:	fa21 f102 	lsr.w	r1, r1, r2
 80a46fa:	4414      	add	r4, r2
 80a46fc:	e6c1      	b.n	80a4482 <__adddf3+0xe6>
 80a46fe:	bf00      	nop

080a4700 <__gedf2>:
 80a4700:	f04f 3cff 	mov.w	ip, #4294967295
 80a4704:	e006      	b.n	80a4714 <__cmpdf2+0x4>
 80a4706:	bf00      	nop

080a4708 <__ledf2>:
 80a4708:	f04f 0c01 	mov.w	ip, #1
 80a470c:	e002      	b.n	80a4714 <__cmpdf2+0x4>
 80a470e:	bf00      	nop

080a4710 <__cmpdf2>:
 80a4710:	f04f 0c01 	mov.w	ip, #1
 80a4714:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a4718:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a471c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a4720:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a4724:	bf18      	it	ne
 80a4726:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80a472a:	d01b      	beq.n	80a4764 <__cmpdf2+0x54>
 80a472c:	b001      	add	sp, #4
 80a472e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80a4732:	bf0c      	ite	eq
 80a4734:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80a4738:	ea91 0f03 	teqne	r1, r3
 80a473c:	bf02      	ittt	eq
 80a473e:	ea90 0f02 	teqeq	r0, r2
 80a4742:	2000      	moveq	r0, #0
 80a4744:	4770      	bxeq	lr
 80a4746:	f110 0f00 	cmn.w	r0, #0
 80a474a:	ea91 0f03 	teq	r1, r3
 80a474e:	bf58      	it	pl
 80a4750:	4299      	cmppl	r1, r3
 80a4752:	bf08      	it	eq
 80a4754:	4290      	cmpeq	r0, r2
 80a4756:	bf2c      	ite	cs
 80a4758:	17d8      	asrcs	r0, r3, #31
 80a475a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80a475e:	f040 0001 	orr.w	r0, r0, #1
 80a4762:	4770      	bx	lr
 80a4764:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a4768:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a476c:	d102      	bne.n	80a4774 <__cmpdf2+0x64>
 80a476e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80a4772:	d107      	bne.n	80a4784 <__cmpdf2+0x74>
 80a4774:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a4778:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a477c:	d1d6      	bne.n	80a472c <__cmpdf2+0x1c>
 80a477e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80a4782:	d0d3      	beq.n	80a472c <__cmpdf2+0x1c>
 80a4784:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a4788:	4770      	bx	lr
 80a478a:	bf00      	nop

080a478c <__aeabi_cdrcmple>:
 80a478c:	4684      	mov	ip, r0
 80a478e:	4610      	mov	r0, r2
 80a4790:	4662      	mov	r2, ip
 80a4792:	468c      	mov	ip, r1
 80a4794:	4619      	mov	r1, r3
 80a4796:	4663      	mov	r3, ip
 80a4798:	e000      	b.n	80a479c <__aeabi_cdcmpeq>
 80a479a:	bf00      	nop

080a479c <__aeabi_cdcmpeq>:
 80a479c:	b501      	push	{r0, lr}
 80a479e:	f7ff ffb7 	bl	80a4710 <__cmpdf2>
 80a47a2:	2800      	cmp	r0, #0
 80a47a4:	bf48      	it	mi
 80a47a6:	f110 0f00 	cmnmi.w	r0, #0
 80a47aa:	bd01      	pop	{r0, pc}

080a47ac <__aeabi_dcmpeq>:
 80a47ac:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a47b0:	f7ff fff4 	bl	80a479c <__aeabi_cdcmpeq>
 80a47b4:	bf0c      	ite	eq
 80a47b6:	2001      	moveq	r0, #1
 80a47b8:	2000      	movne	r0, #0
 80a47ba:	f85d fb08 	ldr.w	pc, [sp], #8
 80a47be:	bf00      	nop

080a47c0 <__aeabi_dcmplt>:
 80a47c0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a47c4:	f7ff ffea 	bl	80a479c <__aeabi_cdcmpeq>
 80a47c8:	bf34      	ite	cc
 80a47ca:	2001      	movcc	r0, #1
 80a47cc:	2000      	movcs	r0, #0
 80a47ce:	f85d fb08 	ldr.w	pc, [sp], #8
 80a47d2:	bf00      	nop

080a47d4 <__aeabi_dcmple>:
 80a47d4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a47d8:	f7ff ffe0 	bl	80a479c <__aeabi_cdcmpeq>
 80a47dc:	bf94      	ite	ls
 80a47de:	2001      	movls	r0, #1
 80a47e0:	2000      	movhi	r0, #0
 80a47e2:	f85d fb08 	ldr.w	pc, [sp], #8
 80a47e6:	bf00      	nop

080a47e8 <__aeabi_dcmpge>:
 80a47e8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a47ec:	f7ff ffce 	bl	80a478c <__aeabi_cdrcmple>
 80a47f0:	bf94      	ite	ls
 80a47f2:	2001      	movls	r0, #1
 80a47f4:	2000      	movhi	r0, #0
 80a47f6:	f85d fb08 	ldr.w	pc, [sp], #8
 80a47fa:	bf00      	nop

080a47fc <__aeabi_dcmpgt>:
 80a47fc:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a4800:	f7ff ffc4 	bl	80a478c <__aeabi_cdrcmple>
 80a4804:	bf34      	ite	cc
 80a4806:	2001      	movcc	r0, #1
 80a4808:	2000      	movcs	r0, #0
 80a480a:	f85d fb08 	ldr.w	pc, [sp], #8
 80a480e:	bf00      	nop

080a4810 <__aeabi_frsub>:
 80a4810:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 80a4814:	e002      	b.n	80a481c <__addsf3>
 80a4816:	bf00      	nop

080a4818 <__aeabi_fsub>:
 80a4818:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080a481c <__addsf3>:
 80a481c:	0042      	lsls	r2, r0, #1
 80a481e:	bf1f      	itttt	ne
 80a4820:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80a4824:	ea92 0f03 	teqne	r2, r3
 80a4828:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80a482c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a4830:	d06a      	beq.n	80a4908 <__addsf3+0xec>
 80a4832:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80a4836:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80a483a:	bfc1      	itttt	gt
 80a483c:	18d2      	addgt	r2, r2, r3
 80a483e:	4041      	eorgt	r1, r0
 80a4840:	4048      	eorgt	r0, r1
 80a4842:	4041      	eorgt	r1, r0
 80a4844:	bfb8      	it	lt
 80a4846:	425b      	neglt	r3, r3
 80a4848:	2b19      	cmp	r3, #25
 80a484a:	bf88      	it	hi
 80a484c:	4770      	bxhi	lr
 80a484e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a4852:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a4856:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80a485a:	bf18      	it	ne
 80a485c:	4240      	negne	r0, r0
 80a485e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a4862:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80a4866:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80a486a:	bf18      	it	ne
 80a486c:	4249      	negne	r1, r1
 80a486e:	ea92 0f03 	teq	r2, r3
 80a4872:	d03f      	beq.n	80a48f4 <__addsf3+0xd8>
 80a4874:	f1a2 0201 	sub.w	r2, r2, #1
 80a4878:	fa41 fc03 	asr.w	ip, r1, r3
 80a487c:	eb10 000c 	adds.w	r0, r0, ip
 80a4880:	f1c3 0320 	rsb	r3, r3, #32
 80a4884:	fa01 f103 	lsl.w	r1, r1, r3
 80a4888:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a488c:	d502      	bpl.n	80a4894 <__addsf3+0x78>
 80a488e:	4249      	negs	r1, r1
 80a4890:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80a4894:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80a4898:	d313      	bcc.n	80a48c2 <__addsf3+0xa6>
 80a489a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80a489e:	d306      	bcc.n	80a48ae <__addsf3+0x92>
 80a48a0:	0840      	lsrs	r0, r0, #1
 80a48a2:	ea4f 0131 	mov.w	r1, r1, rrx
 80a48a6:	f102 0201 	add.w	r2, r2, #1
 80a48aa:	2afe      	cmp	r2, #254	; 0xfe
 80a48ac:	d251      	bcs.n	80a4952 <__addsf3+0x136>
 80a48ae:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 80a48b2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a48b6:	bf08      	it	eq
 80a48b8:	f020 0001 	biceq.w	r0, r0, #1
 80a48bc:	ea40 0003 	orr.w	r0, r0, r3
 80a48c0:	4770      	bx	lr
 80a48c2:	0049      	lsls	r1, r1, #1
 80a48c4:	eb40 0000 	adc.w	r0, r0, r0
 80a48c8:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 80a48cc:	f1a2 0201 	sub.w	r2, r2, #1
 80a48d0:	d1ed      	bne.n	80a48ae <__addsf3+0x92>
 80a48d2:	fab0 fc80 	clz	ip, r0
 80a48d6:	f1ac 0c08 	sub.w	ip, ip, #8
 80a48da:	ebb2 020c 	subs.w	r2, r2, ip
 80a48de:	fa00 f00c 	lsl.w	r0, r0, ip
 80a48e2:	bfaa      	itet	ge
 80a48e4:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80a48e8:	4252      	neglt	r2, r2
 80a48ea:	4318      	orrge	r0, r3
 80a48ec:	bfbc      	itt	lt
 80a48ee:	40d0      	lsrlt	r0, r2
 80a48f0:	4318      	orrlt	r0, r3
 80a48f2:	4770      	bx	lr
 80a48f4:	f092 0f00 	teq	r2, #0
 80a48f8:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80a48fc:	bf06      	itte	eq
 80a48fe:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80a4902:	3201      	addeq	r2, #1
 80a4904:	3b01      	subne	r3, #1
 80a4906:	e7b5      	b.n	80a4874 <__addsf3+0x58>
 80a4908:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a490c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a4910:	bf18      	it	ne
 80a4912:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a4916:	d021      	beq.n	80a495c <__addsf3+0x140>
 80a4918:	ea92 0f03 	teq	r2, r3
 80a491c:	d004      	beq.n	80a4928 <__addsf3+0x10c>
 80a491e:	f092 0f00 	teq	r2, #0
 80a4922:	bf08      	it	eq
 80a4924:	4608      	moveq	r0, r1
 80a4926:	4770      	bx	lr
 80a4928:	ea90 0f01 	teq	r0, r1
 80a492c:	bf1c      	itt	ne
 80a492e:	2000      	movne	r0, #0
 80a4930:	4770      	bxne	lr
 80a4932:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80a4936:	d104      	bne.n	80a4942 <__addsf3+0x126>
 80a4938:	0040      	lsls	r0, r0, #1
 80a493a:	bf28      	it	cs
 80a493c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80a4940:	4770      	bx	lr
 80a4942:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80a4946:	bf3c      	itt	cc
 80a4948:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80a494c:	4770      	bxcc	lr
 80a494e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a4952:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80a4956:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a495a:	4770      	bx	lr
 80a495c:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80a4960:	bf16      	itet	ne
 80a4962:	4608      	movne	r0, r1
 80a4964:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80a4968:	4601      	movne	r1, r0
 80a496a:	0242      	lsls	r2, r0, #9
 80a496c:	bf06      	itte	eq
 80a496e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80a4972:	ea90 0f01 	teqeq	r0, r1
 80a4976:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 80a497a:	4770      	bx	lr

080a497c <__aeabi_ui2f>:
 80a497c:	f04f 0300 	mov.w	r3, #0
 80a4980:	e004      	b.n	80a498c <__aeabi_i2f+0x8>
 80a4982:	bf00      	nop

080a4984 <__aeabi_i2f>:
 80a4984:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 80a4988:	bf48      	it	mi
 80a498a:	4240      	negmi	r0, r0
 80a498c:	ea5f 0c00 	movs.w	ip, r0
 80a4990:	bf08      	it	eq
 80a4992:	4770      	bxeq	lr
 80a4994:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 80a4998:	4601      	mov	r1, r0
 80a499a:	f04f 0000 	mov.w	r0, #0
 80a499e:	e01c      	b.n	80a49da <__aeabi_l2f+0x2a>

080a49a0 <__aeabi_ul2f>:
 80a49a0:	ea50 0201 	orrs.w	r2, r0, r1
 80a49a4:	bf08      	it	eq
 80a49a6:	4770      	bxeq	lr
 80a49a8:	f04f 0300 	mov.w	r3, #0
 80a49ac:	e00a      	b.n	80a49c4 <__aeabi_l2f+0x14>
 80a49ae:	bf00      	nop

080a49b0 <__aeabi_l2f>:
 80a49b0:	ea50 0201 	orrs.w	r2, r0, r1
 80a49b4:	bf08      	it	eq
 80a49b6:	4770      	bxeq	lr
 80a49b8:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 80a49bc:	d502      	bpl.n	80a49c4 <__aeabi_l2f+0x14>
 80a49be:	4240      	negs	r0, r0
 80a49c0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a49c4:	ea5f 0c01 	movs.w	ip, r1
 80a49c8:	bf02      	ittt	eq
 80a49ca:	4684      	moveq	ip, r0
 80a49cc:	4601      	moveq	r1, r0
 80a49ce:	2000      	moveq	r0, #0
 80a49d0:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 80a49d4:	bf08      	it	eq
 80a49d6:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 80a49da:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 80a49de:	fabc f28c 	clz	r2, ip
 80a49e2:	3a08      	subs	r2, #8
 80a49e4:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 80a49e8:	db10      	blt.n	80a4a0c <__aeabi_l2f+0x5c>
 80a49ea:	fa01 fc02 	lsl.w	ip, r1, r2
 80a49ee:	4463      	add	r3, ip
 80a49f0:	fa00 fc02 	lsl.w	ip, r0, r2
 80a49f4:	f1c2 0220 	rsb	r2, r2, #32
 80a49f8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a49fc:	fa20 f202 	lsr.w	r2, r0, r2
 80a4a00:	eb43 0002 	adc.w	r0, r3, r2
 80a4a04:	bf08      	it	eq
 80a4a06:	f020 0001 	biceq.w	r0, r0, #1
 80a4a0a:	4770      	bx	lr
 80a4a0c:	f102 0220 	add.w	r2, r2, #32
 80a4a10:	fa01 fc02 	lsl.w	ip, r1, r2
 80a4a14:	f1c2 0220 	rsb	r2, r2, #32
 80a4a18:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 80a4a1c:	fa21 f202 	lsr.w	r2, r1, r2
 80a4a20:	eb43 0002 	adc.w	r0, r3, r2
 80a4a24:	bf08      	it	eq
 80a4a26:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a4a2a:	4770      	bx	lr

080a4a2c <__aeabi_fmul>:
 80a4a2c:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a4a30:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a4a34:	bf1e      	ittt	ne
 80a4a36:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a4a3a:	ea92 0f0c 	teqne	r2, ip
 80a4a3e:	ea93 0f0c 	teqne	r3, ip
 80a4a42:	d06f      	beq.n	80a4b24 <__aeabi_fmul+0xf8>
 80a4a44:	441a      	add	r2, r3
 80a4a46:	ea80 0c01 	eor.w	ip, r0, r1
 80a4a4a:	0240      	lsls	r0, r0, #9
 80a4a4c:	bf18      	it	ne
 80a4a4e:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80a4a52:	d01e      	beq.n	80a4a92 <__aeabi_fmul+0x66>
 80a4a54:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80a4a58:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80a4a5c:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80a4a60:	fba0 3101 	umull	r3, r1, r0, r1
 80a4a64:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a4a68:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80a4a6c:	bf3e      	ittt	cc
 80a4a6e:	0049      	lslcc	r1, r1, #1
 80a4a70:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80a4a74:	005b      	lslcc	r3, r3, #1
 80a4a76:	ea40 0001 	orr.w	r0, r0, r1
 80a4a7a:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80a4a7e:	2afd      	cmp	r2, #253	; 0xfd
 80a4a80:	d81d      	bhi.n	80a4abe <__aeabi_fmul+0x92>
 80a4a82:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80a4a86:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a4a8a:	bf08      	it	eq
 80a4a8c:	f020 0001 	biceq.w	r0, r0, #1
 80a4a90:	4770      	bx	lr
 80a4a92:	f090 0f00 	teq	r0, #0
 80a4a96:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a4a9a:	bf08      	it	eq
 80a4a9c:	0249      	lsleq	r1, r1, #9
 80a4a9e:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a4aa2:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80a4aa6:	3a7f      	subs	r2, #127	; 0x7f
 80a4aa8:	bfc2      	ittt	gt
 80a4aaa:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a4aae:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a4ab2:	4770      	bxgt	lr
 80a4ab4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a4ab8:	f04f 0300 	mov.w	r3, #0
 80a4abc:	3a01      	subs	r2, #1
 80a4abe:	dc5d      	bgt.n	80a4b7c <__aeabi_fmul+0x150>
 80a4ac0:	f112 0f19 	cmn.w	r2, #25
 80a4ac4:	bfdc      	itt	le
 80a4ac6:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80a4aca:	4770      	bxle	lr
 80a4acc:	f1c2 0200 	rsb	r2, r2, #0
 80a4ad0:	0041      	lsls	r1, r0, #1
 80a4ad2:	fa21 f102 	lsr.w	r1, r1, r2
 80a4ad6:	f1c2 0220 	rsb	r2, r2, #32
 80a4ada:	fa00 fc02 	lsl.w	ip, r0, r2
 80a4ade:	ea5f 0031 	movs.w	r0, r1, rrx
 80a4ae2:	f140 0000 	adc.w	r0, r0, #0
 80a4ae6:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 80a4aea:	bf08      	it	eq
 80a4aec:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a4af0:	4770      	bx	lr
 80a4af2:	f092 0f00 	teq	r2, #0
 80a4af6:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a4afa:	bf02      	ittt	eq
 80a4afc:	0040      	lsleq	r0, r0, #1
 80a4afe:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a4b02:	3a01      	subeq	r2, #1
 80a4b04:	d0f9      	beq.n	80a4afa <__aeabi_fmul+0xce>
 80a4b06:	ea40 000c 	orr.w	r0, r0, ip
 80a4b0a:	f093 0f00 	teq	r3, #0
 80a4b0e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a4b12:	bf02      	ittt	eq
 80a4b14:	0049      	lsleq	r1, r1, #1
 80a4b16:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a4b1a:	3b01      	subeq	r3, #1
 80a4b1c:	d0f9      	beq.n	80a4b12 <__aeabi_fmul+0xe6>
 80a4b1e:	ea41 010c 	orr.w	r1, r1, ip
 80a4b22:	e78f      	b.n	80a4a44 <__aeabi_fmul+0x18>
 80a4b24:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a4b28:	ea92 0f0c 	teq	r2, ip
 80a4b2c:	bf18      	it	ne
 80a4b2e:	ea93 0f0c 	teqne	r3, ip
 80a4b32:	d00a      	beq.n	80a4b4a <__aeabi_fmul+0x11e>
 80a4b34:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a4b38:	bf18      	it	ne
 80a4b3a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a4b3e:	d1d8      	bne.n	80a4af2 <__aeabi_fmul+0xc6>
 80a4b40:	ea80 0001 	eor.w	r0, r0, r1
 80a4b44:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a4b48:	4770      	bx	lr
 80a4b4a:	f090 0f00 	teq	r0, #0
 80a4b4e:	bf17      	itett	ne
 80a4b50:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80a4b54:	4608      	moveq	r0, r1
 80a4b56:	f091 0f00 	teqne	r1, #0
 80a4b5a:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80a4b5e:	d014      	beq.n	80a4b8a <__aeabi_fmul+0x15e>
 80a4b60:	ea92 0f0c 	teq	r2, ip
 80a4b64:	d101      	bne.n	80a4b6a <__aeabi_fmul+0x13e>
 80a4b66:	0242      	lsls	r2, r0, #9
 80a4b68:	d10f      	bne.n	80a4b8a <__aeabi_fmul+0x15e>
 80a4b6a:	ea93 0f0c 	teq	r3, ip
 80a4b6e:	d103      	bne.n	80a4b78 <__aeabi_fmul+0x14c>
 80a4b70:	024b      	lsls	r3, r1, #9
 80a4b72:	bf18      	it	ne
 80a4b74:	4608      	movne	r0, r1
 80a4b76:	d108      	bne.n	80a4b8a <__aeabi_fmul+0x15e>
 80a4b78:	ea80 0001 	eor.w	r0, r0, r1
 80a4b7c:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a4b80:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a4b84:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a4b88:	4770      	bx	lr
 80a4b8a:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a4b8e:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80a4b92:	4770      	bx	lr

080a4b94 <__aeabi_fdiv>:
 80a4b94:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a4b98:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a4b9c:	bf1e      	ittt	ne
 80a4b9e:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a4ba2:	ea92 0f0c 	teqne	r2, ip
 80a4ba6:	ea93 0f0c 	teqne	r3, ip
 80a4baa:	d069      	beq.n	80a4c80 <__aeabi_fdiv+0xec>
 80a4bac:	eba2 0203 	sub.w	r2, r2, r3
 80a4bb0:	ea80 0c01 	eor.w	ip, r0, r1
 80a4bb4:	0249      	lsls	r1, r1, #9
 80a4bb6:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80a4bba:	d037      	beq.n	80a4c2c <__aeabi_fdiv+0x98>
 80a4bbc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80a4bc0:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 80a4bc4:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80a4bc8:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a4bcc:	428b      	cmp	r3, r1
 80a4bce:	bf38      	it	cc
 80a4bd0:	005b      	lslcc	r3, r3, #1
 80a4bd2:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80a4bd6:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80a4bda:	428b      	cmp	r3, r1
 80a4bdc:	bf24      	itt	cs
 80a4bde:	1a5b      	subcs	r3, r3, r1
 80a4be0:	ea40 000c 	orrcs.w	r0, r0, ip
 80a4be4:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 80a4be8:	bf24      	itt	cs
 80a4bea:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 80a4bee:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a4bf2:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 80a4bf6:	bf24      	itt	cs
 80a4bf8:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 80a4bfc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a4c00:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 80a4c04:	bf24      	itt	cs
 80a4c06:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 80a4c0a:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a4c0e:	011b      	lsls	r3, r3, #4
 80a4c10:	bf18      	it	ne
 80a4c12:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80a4c16:	d1e0      	bne.n	80a4bda <__aeabi_fdiv+0x46>
 80a4c18:	2afd      	cmp	r2, #253	; 0xfd
 80a4c1a:	f63f af50 	bhi.w	80a4abe <__aeabi_fmul+0x92>
 80a4c1e:	428b      	cmp	r3, r1
 80a4c20:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a4c24:	bf08      	it	eq
 80a4c26:	f020 0001 	biceq.w	r0, r0, #1
 80a4c2a:	4770      	bx	lr
 80a4c2c:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a4c30:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a4c34:	327f      	adds	r2, #127	; 0x7f
 80a4c36:	bfc2      	ittt	gt
 80a4c38:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a4c3c:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a4c40:	4770      	bxgt	lr
 80a4c42:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a4c46:	f04f 0300 	mov.w	r3, #0
 80a4c4a:	3a01      	subs	r2, #1
 80a4c4c:	e737      	b.n	80a4abe <__aeabi_fmul+0x92>
 80a4c4e:	f092 0f00 	teq	r2, #0
 80a4c52:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a4c56:	bf02      	ittt	eq
 80a4c58:	0040      	lsleq	r0, r0, #1
 80a4c5a:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a4c5e:	3a01      	subeq	r2, #1
 80a4c60:	d0f9      	beq.n	80a4c56 <__aeabi_fdiv+0xc2>
 80a4c62:	ea40 000c 	orr.w	r0, r0, ip
 80a4c66:	f093 0f00 	teq	r3, #0
 80a4c6a:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a4c6e:	bf02      	ittt	eq
 80a4c70:	0049      	lsleq	r1, r1, #1
 80a4c72:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a4c76:	3b01      	subeq	r3, #1
 80a4c78:	d0f9      	beq.n	80a4c6e <__aeabi_fdiv+0xda>
 80a4c7a:	ea41 010c 	orr.w	r1, r1, ip
 80a4c7e:	e795      	b.n	80a4bac <__aeabi_fdiv+0x18>
 80a4c80:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a4c84:	ea92 0f0c 	teq	r2, ip
 80a4c88:	d108      	bne.n	80a4c9c <__aeabi_fdiv+0x108>
 80a4c8a:	0242      	lsls	r2, r0, #9
 80a4c8c:	f47f af7d 	bne.w	80a4b8a <__aeabi_fmul+0x15e>
 80a4c90:	ea93 0f0c 	teq	r3, ip
 80a4c94:	f47f af70 	bne.w	80a4b78 <__aeabi_fmul+0x14c>
 80a4c98:	4608      	mov	r0, r1
 80a4c9a:	e776      	b.n	80a4b8a <__aeabi_fmul+0x15e>
 80a4c9c:	ea93 0f0c 	teq	r3, ip
 80a4ca0:	d104      	bne.n	80a4cac <__aeabi_fdiv+0x118>
 80a4ca2:	024b      	lsls	r3, r1, #9
 80a4ca4:	f43f af4c 	beq.w	80a4b40 <__aeabi_fmul+0x114>
 80a4ca8:	4608      	mov	r0, r1
 80a4caa:	e76e      	b.n	80a4b8a <__aeabi_fmul+0x15e>
 80a4cac:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a4cb0:	bf18      	it	ne
 80a4cb2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a4cb6:	d1ca      	bne.n	80a4c4e <__aeabi_fdiv+0xba>
 80a4cb8:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80a4cbc:	f47f af5c 	bne.w	80a4b78 <__aeabi_fmul+0x14c>
 80a4cc0:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80a4cc4:	f47f af3c 	bne.w	80a4b40 <__aeabi_fmul+0x114>
 80a4cc8:	e75f      	b.n	80a4b8a <__aeabi_fmul+0x15e>
 80a4cca:	bf00      	nop

080a4ccc <atol>:
 80a4ccc:	220a      	movs	r2, #10
 80a4cce:	2100      	movs	r1, #0
 80a4cd0:	f000 ba26 	b.w	80a5120 <strtol>

080a4cd4 <__cxa_atexit>:
 80a4cd4:	b510      	push	{r4, lr}
 80a4cd6:	4c05      	ldr	r4, [pc, #20]	; (80a4cec <__cxa_atexit+0x18>)
 80a4cd8:	4613      	mov	r3, r2
 80a4cda:	b12c      	cbz	r4, 80a4ce8 <__cxa_atexit+0x14>
 80a4cdc:	460a      	mov	r2, r1
 80a4cde:	4601      	mov	r1, r0
 80a4ce0:	2002      	movs	r0, #2
 80a4ce2:	f3af 8000 	nop.w
 80a4ce6:	bd10      	pop	{r4, pc}
 80a4ce8:	4620      	mov	r0, r4
 80a4cea:	bd10      	pop	{r4, pc}
 80a4cec:	00000000 	.word	0x00000000

080a4cf0 <localtime>:
 80a4cf0:	b538      	push	{r3, r4, r5, lr}
 80a4cf2:	4b07      	ldr	r3, [pc, #28]	; (80a4d10 <localtime+0x20>)
 80a4cf4:	4605      	mov	r5, r0
 80a4cf6:	681c      	ldr	r4, [r3, #0]
 80a4cf8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80a4cfa:	b91b      	cbnz	r3, 80a4d04 <localtime+0x14>
 80a4cfc:	2024      	movs	r0, #36	; 0x24
 80a4cfe:	f7fe fb63 	bl	80a33c8 <malloc>
 80a4d02:	63e0      	str	r0, [r4, #60]	; 0x3c
 80a4d04:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80a4d06:	4628      	mov	r0, r5
 80a4d08:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a4d0c:	f000 b802 	b.w	80a4d14 <localtime_r>
 80a4d10:	20000370 	.word	0x20000370

080a4d14 <localtime_r>:
 80a4d14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a4d18:	460c      	mov	r4, r1
 80a4d1a:	4680      	mov	r8, r0
 80a4d1c:	f000 fd06 	bl	80a572c <__gettzinfo>
 80a4d20:	4621      	mov	r1, r4
 80a4d22:	4607      	mov	r7, r0
 80a4d24:	4640      	mov	r0, r8
 80a4d26:	f000 fd05 	bl	80a5734 <gmtime_r>
 80a4d2a:	6946      	ldr	r6, [r0, #20]
 80a4d2c:	4604      	mov	r4, r0
 80a4d2e:	f206 766c 	addw	r6, r6, #1900	; 0x76c
 80a4d32:	07b3      	lsls	r3, r6, #30
 80a4d34:	d105      	bne.n	80a4d42 <localtime_r+0x2e>
 80a4d36:	2264      	movs	r2, #100	; 0x64
 80a4d38:	fb96 f3f2 	sdiv	r3, r6, r2
 80a4d3c:	fb02 6313 	mls	r3, r2, r3, r6
 80a4d40:	b94b      	cbnz	r3, 80a4d56 <localtime_r+0x42>
 80a4d42:	f44f 75c8 	mov.w	r5, #400	; 0x190
 80a4d46:	fb96 f3f5 	sdiv	r3, r6, r5
 80a4d4a:	fb05 6513 	mls	r5, r5, r3, r6
 80a4d4e:	fab5 f385 	clz	r3, r5
 80a4d52:	095b      	lsrs	r3, r3, #5
 80a4d54:	e000      	b.n	80a4d58 <localtime_r+0x44>
 80a4d56:	2301      	movs	r3, #1
 80a4d58:	4a5f      	ldr	r2, [pc, #380]	; (80a4ed8 <localtime_r+0x1c4>)
 80a4d5a:	2530      	movs	r5, #48	; 0x30
 80a4d5c:	fb05 2503 	mla	r5, r5, r3, r2
 80a4d60:	f000 fb18 	bl	80a5394 <__tz_lock>
 80a4d64:	f000 fb18 	bl	80a5398 <_tzset_unlocked>
 80a4d68:	4b5c      	ldr	r3, [pc, #368]	; (80a4edc <localtime_r+0x1c8>)
 80a4d6a:	681b      	ldr	r3, [r3, #0]
 80a4d6c:	b1f3      	cbz	r3, 80a4dac <localtime_r+0x98>
 80a4d6e:	687b      	ldr	r3, [r7, #4]
 80a4d70:	429e      	cmp	r6, r3
 80a4d72:	d105      	bne.n	80a4d80 <localtime_r+0x6c>
 80a4d74:	6839      	ldr	r1, [r7, #0]
 80a4d76:	f8d8 3000 	ldr.w	r3, [r8]
 80a4d7a:	69fa      	ldr	r2, [r7, #28]
 80a4d7c:	b941      	cbnz	r1, 80a4d90 <localtime_r+0x7c>
 80a4d7e:	e00a      	b.n	80a4d96 <localtime_r+0x82>
 80a4d80:	4630      	mov	r0, r6
 80a4d82:	f000 fa5f 	bl	80a5244 <__tzcalc_limits>
 80a4d86:	2800      	cmp	r0, #0
 80a4d88:	d1f4      	bne.n	80a4d74 <localtime_r+0x60>
 80a4d8a:	f04f 33ff 	mov.w	r3, #4294967295
 80a4d8e:	e00d      	b.n	80a4dac <localtime_r+0x98>
 80a4d90:	4293      	cmp	r3, r2
 80a4d92:	db08      	blt.n	80a4da6 <localtime_r+0x92>
 80a4d94:	e001      	b.n	80a4d9a <localtime_r+0x86>
 80a4d96:	4293      	cmp	r3, r2
 80a4d98:	da07      	bge.n	80a4daa <localtime_r+0x96>
 80a4d9a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80a4d9c:	4293      	cmp	r3, r2
 80a4d9e:	bfac      	ite	ge
 80a4da0:	2300      	movge	r3, #0
 80a4da2:	2301      	movlt	r3, #1
 80a4da4:	e002      	b.n	80a4dac <localtime_r+0x98>
 80a4da6:	2300      	movs	r3, #0
 80a4da8:	e000      	b.n	80a4dac <localtime_r+0x98>
 80a4daa:	2301      	movs	r3, #1
 80a4dac:	6223      	str	r3, [r4, #32]
 80a4dae:	6a23      	ldr	r3, [r4, #32]
 80a4db0:	203c      	movs	r0, #60	; 0x3c
 80a4db2:	2b01      	cmp	r3, #1
 80a4db4:	bf0c      	ite	eq
 80a4db6:	6bf9      	ldreq	r1, [r7, #60]	; 0x3c
 80a4db8:	6a39      	ldrne	r1, [r7, #32]
 80a4dba:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 80a4dbe:	fb91 f6f3 	sdiv	r6, r1, r3
 80a4dc2:	fb03 1316 	mls	r3, r3, r6, r1
 80a4dc6:	fb93 f2f0 	sdiv	r2, r3, r0
 80a4dca:	fb00 3012 	mls	r0, r0, r2, r3
 80a4dce:	6861      	ldr	r1, [r4, #4]
 80a4dd0:	6823      	ldr	r3, [r4, #0]
 80a4dd2:	1a89      	subs	r1, r1, r2
 80a4dd4:	68a2      	ldr	r2, [r4, #8]
 80a4dd6:	1a1b      	subs	r3, r3, r0
 80a4dd8:	1b92      	subs	r2, r2, r6
 80a4dda:	2b3b      	cmp	r3, #59	; 0x3b
 80a4ddc:	6023      	str	r3, [r4, #0]
 80a4dde:	6061      	str	r1, [r4, #4]
 80a4de0:	60a2      	str	r2, [r4, #8]
 80a4de2:	dd03      	ble.n	80a4dec <localtime_r+0xd8>
 80a4de4:	3101      	adds	r1, #1
 80a4de6:	6061      	str	r1, [r4, #4]
 80a4de8:	3b3c      	subs	r3, #60	; 0x3c
 80a4dea:	e004      	b.n	80a4df6 <localtime_r+0xe2>
 80a4dec:	2b00      	cmp	r3, #0
 80a4dee:	da03      	bge.n	80a4df8 <localtime_r+0xe4>
 80a4df0:	3901      	subs	r1, #1
 80a4df2:	6061      	str	r1, [r4, #4]
 80a4df4:	333c      	adds	r3, #60	; 0x3c
 80a4df6:	6023      	str	r3, [r4, #0]
 80a4df8:	6863      	ldr	r3, [r4, #4]
 80a4dfa:	2b3b      	cmp	r3, #59	; 0x3b
 80a4dfc:	dd03      	ble.n	80a4e06 <localtime_r+0xf2>
 80a4dfe:	3201      	adds	r2, #1
 80a4e00:	60a2      	str	r2, [r4, #8]
 80a4e02:	3b3c      	subs	r3, #60	; 0x3c
 80a4e04:	e004      	b.n	80a4e10 <localtime_r+0xfc>
 80a4e06:	2b00      	cmp	r3, #0
 80a4e08:	da03      	bge.n	80a4e12 <localtime_r+0xfe>
 80a4e0a:	3a01      	subs	r2, #1
 80a4e0c:	60a2      	str	r2, [r4, #8]
 80a4e0e:	333c      	adds	r3, #60	; 0x3c
 80a4e10:	6063      	str	r3, [r4, #4]
 80a4e12:	68a3      	ldr	r3, [r4, #8]
 80a4e14:	2b17      	cmp	r3, #23
 80a4e16:	dd22      	ble.n	80a4e5e <localtime_r+0x14a>
 80a4e18:	69e2      	ldr	r2, [r4, #28]
 80a4e1a:	3b18      	subs	r3, #24
 80a4e1c:	3201      	adds	r2, #1
 80a4e1e:	61e2      	str	r2, [r4, #28]
 80a4e20:	69a2      	ldr	r2, [r4, #24]
 80a4e22:	60a3      	str	r3, [r4, #8]
 80a4e24:	3201      	adds	r2, #1
 80a4e26:	2a06      	cmp	r2, #6
 80a4e28:	bfc8      	it	gt
 80a4e2a:	2200      	movgt	r2, #0
 80a4e2c:	61a2      	str	r2, [r4, #24]
 80a4e2e:	68e2      	ldr	r2, [r4, #12]
 80a4e30:	6923      	ldr	r3, [r4, #16]
 80a4e32:	3201      	adds	r2, #1
 80a4e34:	60e2      	str	r2, [r4, #12]
 80a4e36:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 80a4e3a:	428a      	cmp	r2, r1
 80a4e3c:	dd46      	ble.n	80a4ecc <localtime_r+0x1b8>
 80a4e3e:	3301      	adds	r3, #1
 80a4e40:	2b0c      	cmp	r3, #12
 80a4e42:	bf08      	it	eq
 80a4e44:	6963      	ldreq	r3, [r4, #20]
 80a4e46:	eba2 0201 	sub.w	r2, r2, r1
 80a4e4a:	60e2      	str	r2, [r4, #12]
 80a4e4c:	bf05      	ittet	eq
 80a4e4e:	3301      	addeq	r3, #1
 80a4e50:	2200      	moveq	r2, #0
 80a4e52:	6123      	strne	r3, [r4, #16]
 80a4e54:	6122      	streq	r2, [r4, #16]
 80a4e56:	bf04      	itt	eq
 80a4e58:	6163      	streq	r3, [r4, #20]
 80a4e5a:	61e2      	streq	r2, [r4, #28]
 80a4e5c:	e036      	b.n	80a4ecc <localtime_r+0x1b8>
 80a4e5e:	2b00      	cmp	r3, #0
 80a4e60:	da34      	bge.n	80a4ecc <localtime_r+0x1b8>
 80a4e62:	69e2      	ldr	r2, [r4, #28]
 80a4e64:	3318      	adds	r3, #24
 80a4e66:	3a01      	subs	r2, #1
 80a4e68:	61e2      	str	r2, [r4, #28]
 80a4e6a:	69a2      	ldr	r2, [r4, #24]
 80a4e6c:	60a3      	str	r3, [r4, #8]
 80a4e6e:	3a01      	subs	r2, #1
 80a4e70:	bf48      	it	mi
 80a4e72:	2206      	movmi	r2, #6
 80a4e74:	61a2      	str	r2, [r4, #24]
 80a4e76:	68e2      	ldr	r2, [r4, #12]
 80a4e78:	3a01      	subs	r2, #1
 80a4e7a:	60e2      	str	r2, [r4, #12]
 80a4e7c:	bb32      	cbnz	r2, 80a4ecc <localtime_r+0x1b8>
 80a4e7e:	6923      	ldr	r3, [r4, #16]
 80a4e80:	3b01      	subs	r3, #1
 80a4e82:	d401      	bmi.n	80a4e88 <localtime_r+0x174>
 80a4e84:	6123      	str	r3, [r4, #16]
 80a4e86:	e01d      	b.n	80a4ec4 <localtime_r+0x1b0>
 80a4e88:	230b      	movs	r3, #11
 80a4e8a:	6123      	str	r3, [r4, #16]
 80a4e8c:	6963      	ldr	r3, [r4, #20]
 80a4e8e:	1e5a      	subs	r2, r3, #1
 80a4e90:	f012 0f03 	tst.w	r2, #3
 80a4e94:	6162      	str	r2, [r4, #20]
 80a4e96:	f203 736b 	addw	r3, r3, #1899	; 0x76b
 80a4e9a:	d105      	bne.n	80a4ea8 <localtime_r+0x194>
 80a4e9c:	2164      	movs	r1, #100	; 0x64
 80a4e9e:	fb93 f2f1 	sdiv	r2, r3, r1
 80a4ea2:	fb01 3212 	mls	r2, r1, r2, r3
 80a4ea6:	b94a      	cbnz	r2, 80a4ebc <localtime_r+0x1a8>
 80a4ea8:	f44f 71c8 	mov.w	r1, #400	; 0x190
 80a4eac:	fb93 f2f1 	sdiv	r2, r3, r1
 80a4eb0:	fb01 3312 	mls	r3, r1, r2, r3
 80a4eb4:	fab3 f383 	clz	r3, r3
 80a4eb8:	095b      	lsrs	r3, r3, #5
 80a4eba:	e000      	b.n	80a4ebe <localtime_r+0x1aa>
 80a4ebc:	2301      	movs	r3, #1
 80a4ebe:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 80a4ec2:	61e3      	str	r3, [r4, #28]
 80a4ec4:	6923      	ldr	r3, [r4, #16]
 80a4ec6:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80a4eca:	60e3      	str	r3, [r4, #12]
 80a4ecc:	f000 fa63 	bl	80a5396 <__tz_unlock>
 80a4ed0:	4620      	mov	r0, r4
 80a4ed2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a4ed6:	bf00      	nop
 80a4ed8:	080a5d08 	.word	0x080a5d08
 80a4edc:	200010e8 	.word	0x200010e8

080a4ee0 <memcmp>:
 80a4ee0:	b510      	push	{r4, lr}
 80a4ee2:	3901      	subs	r1, #1
 80a4ee4:	4402      	add	r2, r0
 80a4ee6:	4290      	cmp	r0, r2
 80a4ee8:	d007      	beq.n	80a4efa <memcmp+0x1a>
 80a4eea:	f810 3b01 	ldrb.w	r3, [r0], #1
 80a4eee:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80a4ef2:	42a3      	cmp	r3, r4
 80a4ef4:	d0f7      	beq.n	80a4ee6 <memcmp+0x6>
 80a4ef6:	1b18      	subs	r0, r3, r4
 80a4ef8:	bd10      	pop	{r4, pc}
 80a4efa:	2000      	movs	r0, #0
 80a4efc:	bd10      	pop	{r4, pc}

080a4efe <memcpy>:
 80a4efe:	b510      	push	{r4, lr}
 80a4f00:	1e43      	subs	r3, r0, #1
 80a4f02:	440a      	add	r2, r1
 80a4f04:	4291      	cmp	r1, r2
 80a4f06:	d004      	beq.n	80a4f12 <memcpy+0x14>
 80a4f08:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a4f0c:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a4f10:	e7f8      	b.n	80a4f04 <memcpy+0x6>
 80a4f12:	bd10      	pop	{r4, pc}

080a4f14 <memset>:
 80a4f14:	4603      	mov	r3, r0
 80a4f16:	4402      	add	r2, r0
 80a4f18:	4293      	cmp	r3, r2
 80a4f1a:	d002      	beq.n	80a4f22 <memset+0xe>
 80a4f1c:	f803 1b01 	strb.w	r1, [r3], #1
 80a4f20:	e7fa      	b.n	80a4f18 <memset+0x4>
 80a4f22:	4770      	bx	lr

080a4f24 <srand>:
 80a4f24:	b538      	push	{r3, r4, r5, lr}
 80a4f26:	4b12      	ldr	r3, [pc, #72]	; (80a4f70 <srand+0x4c>)
 80a4f28:	4605      	mov	r5, r0
 80a4f2a:	681c      	ldr	r4, [r3, #0]
 80a4f2c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a4f2e:	b9d3      	cbnz	r3, 80a4f66 <srand+0x42>
 80a4f30:	2018      	movs	r0, #24
 80a4f32:	f7fe fa49 	bl	80a33c8 <malloc>
 80a4f36:	f243 330e 	movw	r3, #13070	; 0x330e
 80a4f3a:	63a0      	str	r0, [r4, #56]	; 0x38
 80a4f3c:	8003      	strh	r3, [r0, #0]
 80a4f3e:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a4f42:	8043      	strh	r3, [r0, #2]
 80a4f44:	f241 2334 	movw	r3, #4660	; 0x1234
 80a4f48:	8083      	strh	r3, [r0, #4]
 80a4f4a:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a4f4e:	80c3      	strh	r3, [r0, #6]
 80a4f50:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a4f54:	8103      	strh	r3, [r0, #8]
 80a4f56:	2305      	movs	r3, #5
 80a4f58:	8143      	strh	r3, [r0, #10]
 80a4f5a:	230b      	movs	r3, #11
 80a4f5c:	8183      	strh	r3, [r0, #12]
 80a4f5e:	2201      	movs	r2, #1
 80a4f60:	2300      	movs	r3, #0
 80a4f62:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a4f66:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a4f68:	2200      	movs	r2, #0
 80a4f6a:	611d      	str	r5, [r3, #16]
 80a4f6c:	615a      	str	r2, [r3, #20]
 80a4f6e:	bd38      	pop	{r3, r4, r5, pc}
 80a4f70:	20000370 	.word	0x20000370

080a4f74 <strchr>:
 80a4f74:	b2c9      	uxtb	r1, r1
 80a4f76:	4603      	mov	r3, r0
 80a4f78:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a4f7c:	b11a      	cbz	r2, 80a4f86 <strchr+0x12>
 80a4f7e:	4291      	cmp	r1, r2
 80a4f80:	d1f9      	bne.n	80a4f76 <strchr+0x2>
 80a4f82:	4618      	mov	r0, r3
 80a4f84:	4770      	bx	lr
 80a4f86:	2900      	cmp	r1, #0
 80a4f88:	bf0c      	ite	eq
 80a4f8a:	4618      	moveq	r0, r3
 80a4f8c:	2000      	movne	r0, #0
 80a4f8e:	4770      	bx	lr

080a4f90 <strcmp>:
 80a4f90:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a4f94:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a4f98:	2a01      	cmp	r2, #1
 80a4f9a:	bf28      	it	cs
 80a4f9c:	429a      	cmpcs	r2, r3
 80a4f9e:	d0f7      	beq.n	80a4f90 <strcmp>
 80a4fa0:	1ad0      	subs	r0, r2, r3
 80a4fa2:	4770      	bx	lr

080a4fa4 <strcpy>:
 80a4fa4:	4603      	mov	r3, r0
 80a4fa6:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a4faa:	f803 2b01 	strb.w	r2, [r3], #1
 80a4fae:	2a00      	cmp	r2, #0
 80a4fb0:	d1f9      	bne.n	80a4fa6 <strcpy+0x2>
 80a4fb2:	4770      	bx	lr

080a4fb4 <strlen>:
 80a4fb4:	4603      	mov	r3, r0
 80a4fb6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a4fba:	2a00      	cmp	r2, #0
 80a4fbc:	d1fb      	bne.n	80a4fb6 <strlen+0x2>
 80a4fbe:	1a18      	subs	r0, r3, r0
 80a4fc0:	3801      	subs	r0, #1
 80a4fc2:	4770      	bx	lr

080a4fc4 <strncmp>:
 80a4fc4:	b530      	push	{r4, r5, lr}
 80a4fc6:	b182      	cbz	r2, 80a4fea <strncmp+0x26>
 80a4fc8:	1e45      	subs	r5, r0, #1
 80a4fca:	3901      	subs	r1, #1
 80a4fcc:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 80a4fd0:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80a4fd4:	42a3      	cmp	r3, r4
 80a4fd6:	d106      	bne.n	80a4fe6 <strncmp+0x22>
 80a4fd8:	43ec      	mvns	r4, r5
 80a4fda:	4414      	add	r4, r2
 80a4fdc:	42e0      	cmn	r0, r4
 80a4fde:	d001      	beq.n	80a4fe4 <strncmp+0x20>
 80a4fe0:	2b00      	cmp	r3, #0
 80a4fe2:	d1f3      	bne.n	80a4fcc <strncmp+0x8>
 80a4fe4:	461c      	mov	r4, r3
 80a4fe6:	1b18      	subs	r0, r3, r4
 80a4fe8:	bd30      	pop	{r4, r5, pc}
 80a4fea:	4610      	mov	r0, r2
 80a4fec:	bd30      	pop	{r4, r5, pc}

080a4fee <strncpy>:
 80a4fee:	4603      	mov	r3, r0
 80a4ff0:	b510      	push	{r4, lr}
 80a4ff2:	b142      	cbz	r2, 80a5006 <strncpy+0x18>
 80a4ff4:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a4ff8:	3a01      	subs	r2, #1
 80a4ffa:	f803 4b01 	strb.w	r4, [r3], #1
 80a4ffe:	2c00      	cmp	r4, #0
 80a5000:	d1f7      	bne.n	80a4ff2 <strncpy+0x4>
 80a5002:	441a      	add	r2, r3
 80a5004:	e000      	b.n	80a5008 <strncpy+0x1a>
 80a5006:	bd10      	pop	{r4, pc}
 80a5008:	4293      	cmp	r3, r2
 80a500a:	d002      	beq.n	80a5012 <strncpy+0x24>
 80a500c:	f803 4b01 	strb.w	r4, [r3], #1
 80a5010:	e7fa      	b.n	80a5008 <strncpy+0x1a>
 80a5012:	bd10      	pop	{r4, pc}

080a5014 <_strtol_r>:
 80a5014:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a5018:	460f      	mov	r7, r1
 80a501a:	4680      	mov	r8, r0
 80a501c:	483f      	ldr	r0, [pc, #252]	; (80a511c <_strtol_r+0x108>)
 80a501e:	f8d0 9000 	ldr.w	r9, [r0]
 80a5022:	463d      	mov	r5, r7
 80a5024:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a5028:	eb09 0004 	add.w	r0, r9, r4
 80a502c:	7840      	ldrb	r0, [r0, #1]
 80a502e:	f000 0008 	and.w	r0, r0, #8
 80a5032:	f000 06ff 	and.w	r6, r0, #255	; 0xff
 80a5036:	b108      	cbz	r0, 80a503c <_strtol_r+0x28>
 80a5038:	462f      	mov	r7, r5
 80a503a:	e7f2      	b.n	80a5022 <_strtol_r+0xe>
 80a503c:	2c2d      	cmp	r4, #45	; 0x2d
 80a503e:	d103      	bne.n	80a5048 <_strtol_r+0x34>
 80a5040:	1cbd      	adds	r5, r7, #2
 80a5042:	787c      	ldrb	r4, [r7, #1]
 80a5044:	2601      	movs	r6, #1
 80a5046:	e003      	b.n	80a5050 <_strtol_r+0x3c>
 80a5048:	2c2b      	cmp	r4, #43	; 0x2b
 80a504a:	bf04      	itt	eq
 80a504c:	787c      	ldrbeq	r4, [r7, #1]
 80a504e:	1cbd      	addeq	r5, r7, #2
 80a5050:	b113      	cbz	r3, 80a5058 <_strtol_r+0x44>
 80a5052:	2b10      	cmp	r3, #16
 80a5054:	d10a      	bne.n	80a506c <_strtol_r+0x58>
 80a5056:	e05b      	b.n	80a5110 <_strtol_r+0xfc>
 80a5058:	2c30      	cmp	r4, #48	; 0x30
 80a505a:	d157      	bne.n	80a510c <_strtol_r+0xf8>
 80a505c:	7828      	ldrb	r0, [r5, #0]
 80a505e:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a5062:	2858      	cmp	r0, #88	; 0x58
 80a5064:	d14d      	bne.n	80a5102 <_strtol_r+0xee>
 80a5066:	786c      	ldrb	r4, [r5, #1]
 80a5068:	2310      	movs	r3, #16
 80a506a:	3502      	adds	r5, #2
 80a506c:	2e00      	cmp	r6, #0
 80a506e:	bf14      	ite	ne
 80a5070:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
 80a5074:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
 80a5078:	fbbc faf3 	udiv	sl, ip, r3
 80a507c:	2700      	movs	r7, #0
 80a507e:	4638      	mov	r0, r7
 80a5080:	fb03 cc1a 	mls	ip, r3, sl, ip
 80a5084:	eb09 0e04 	add.w	lr, r9, r4
 80a5088:	f89e e001 	ldrb.w	lr, [lr, #1]
 80a508c:	f01e 0f04 	tst.w	lr, #4
 80a5090:	d001      	beq.n	80a5096 <_strtol_r+0x82>
 80a5092:	3c30      	subs	r4, #48	; 0x30
 80a5094:	e00b      	b.n	80a50ae <_strtol_r+0x9a>
 80a5096:	f01e 0e03 	ands.w	lr, lr, #3
 80a509a:	d01b      	beq.n	80a50d4 <_strtol_r+0xc0>
 80a509c:	f1be 0f01 	cmp.w	lr, #1
 80a50a0:	bf0c      	ite	eq
 80a50a2:	f04f 0e37 	moveq.w	lr, #55	; 0x37
 80a50a6:	f04f 0e57 	movne.w	lr, #87	; 0x57
 80a50aa:	ebce 0404 	rsb	r4, lr, r4
 80a50ae:	42a3      	cmp	r3, r4
 80a50b0:	dd10      	ble.n	80a50d4 <_strtol_r+0xc0>
 80a50b2:	f1b7 3fff 	cmp.w	r7, #4294967295
 80a50b6:	d00a      	beq.n	80a50ce <_strtol_r+0xba>
 80a50b8:	4550      	cmp	r0, sl
 80a50ba:	d806      	bhi.n	80a50ca <_strtol_r+0xb6>
 80a50bc:	d101      	bne.n	80a50c2 <_strtol_r+0xae>
 80a50be:	4564      	cmp	r4, ip
 80a50c0:	dc03      	bgt.n	80a50ca <_strtol_r+0xb6>
 80a50c2:	fb03 4000 	mla	r0, r3, r0, r4
 80a50c6:	2701      	movs	r7, #1
 80a50c8:	e001      	b.n	80a50ce <_strtol_r+0xba>
 80a50ca:	f04f 37ff 	mov.w	r7, #4294967295
 80a50ce:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a50d2:	e7d7      	b.n	80a5084 <_strtol_r+0x70>
 80a50d4:	1c7b      	adds	r3, r7, #1
 80a50d6:	d10c      	bne.n	80a50f2 <_strtol_r+0xde>
 80a50d8:	2e00      	cmp	r6, #0
 80a50da:	f04f 0322 	mov.w	r3, #34	; 0x22
 80a50de:	bf14      	ite	ne
 80a50e0:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 80a50e4:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a50e8:	f8c8 3000 	str.w	r3, [r8]
 80a50ec:	b92a      	cbnz	r2, 80a50fa <_strtol_r+0xe6>
 80a50ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a50f2:	b106      	cbz	r6, 80a50f6 <_strtol_r+0xe2>
 80a50f4:	4240      	negs	r0, r0
 80a50f6:	b172      	cbz	r2, 80a5116 <_strtol_r+0x102>
 80a50f8:	b107      	cbz	r7, 80a50fc <_strtol_r+0xe8>
 80a50fa:	1e69      	subs	r1, r5, #1
 80a50fc:	6011      	str	r1, [r2, #0]
 80a50fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a5102:	2430      	movs	r4, #48	; 0x30
 80a5104:	2b00      	cmp	r3, #0
 80a5106:	d1b1      	bne.n	80a506c <_strtol_r+0x58>
 80a5108:	2308      	movs	r3, #8
 80a510a:	e7af      	b.n	80a506c <_strtol_r+0x58>
 80a510c:	230a      	movs	r3, #10
 80a510e:	e7ad      	b.n	80a506c <_strtol_r+0x58>
 80a5110:	2c30      	cmp	r4, #48	; 0x30
 80a5112:	d0a3      	beq.n	80a505c <_strtol_r+0x48>
 80a5114:	e7aa      	b.n	80a506c <_strtol_r+0x58>
 80a5116:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a511a:	bf00      	nop
 80a511c:	2000030c 	.word	0x2000030c

080a5120 <strtol>:
 80a5120:	4613      	mov	r3, r2
 80a5122:	460a      	mov	r2, r1
 80a5124:	4601      	mov	r1, r0
 80a5126:	4802      	ldr	r0, [pc, #8]	; (80a5130 <strtol+0x10>)
 80a5128:	6800      	ldr	r0, [r0, #0]
 80a512a:	f7ff bf73 	b.w	80a5014 <_strtol_r>
 80a512e:	bf00      	nop
 80a5130:	20000370 	.word	0x20000370

080a5134 <_strtoul_r>:
 80a5134:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a5138:	460e      	mov	r6, r1
 80a513a:	4680      	mov	r8, r0
 80a513c:	483b      	ldr	r0, [pc, #236]	; (80a522c <_strtoul_r+0xf8>)
 80a513e:	f8d0 9000 	ldr.w	r9, [r0]
 80a5142:	4635      	mov	r5, r6
 80a5144:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a5148:	eb09 0004 	add.w	r0, r9, r4
 80a514c:	7840      	ldrb	r0, [r0, #1]
 80a514e:	f000 0008 	and.w	r0, r0, #8
 80a5152:	f000 07ff 	and.w	r7, r0, #255	; 0xff
 80a5156:	b108      	cbz	r0, 80a515c <_strtoul_r+0x28>
 80a5158:	462e      	mov	r6, r5
 80a515a:	e7f2      	b.n	80a5142 <_strtoul_r+0xe>
 80a515c:	2c2d      	cmp	r4, #45	; 0x2d
 80a515e:	d103      	bne.n	80a5168 <_strtoul_r+0x34>
 80a5160:	1cb5      	adds	r5, r6, #2
 80a5162:	7874      	ldrb	r4, [r6, #1]
 80a5164:	2701      	movs	r7, #1
 80a5166:	e003      	b.n	80a5170 <_strtoul_r+0x3c>
 80a5168:	2c2b      	cmp	r4, #43	; 0x2b
 80a516a:	bf04      	itt	eq
 80a516c:	7874      	ldrbeq	r4, [r6, #1]
 80a516e:	1cb5      	addeq	r5, r6, #2
 80a5170:	b113      	cbz	r3, 80a5178 <_strtoul_r+0x44>
 80a5172:	2b10      	cmp	r3, #16
 80a5174:	d10a      	bne.n	80a518c <_strtoul_r+0x58>
 80a5176:	e053      	b.n	80a5220 <_strtoul_r+0xec>
 80a5178:	2c30      	cmp	r4, #48	; 0x30
 80a517a:	d14f      	bne.n	80a521c <_strtoul_r+0xe8>
 80a517c:	7828      	ldrb	r0, [r5, #0]
 80a517e:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a5182:	2858      	cmp	r0, #88	; 0x58
 80a5184:	d145      	bne.n	80a5212 <_strtoul_r+0xde>
 80a5186:	786c      	ldrb	r4, [r5, #1]
 80a5188:	2310      	movs	r3, #16
 80a518a:	3502      	adds	r5, #2
 80a518c:	f04f 3cff 	mov.w	ip, #4294967295
 80a5190:	fbbc fcf3 	udiv	ip, ip, r3
 80a5194:	fb03 fa0c 	mul.w	sl, r3, ip
 80a5198:	2600      	movs	r6, #0
 80a519a:	ea6f 0a0a 	mvn.w	sl, sl
 80a519e:	4630      	mov	r0, r6
 80a51a0:	eb09 0e04 	add.w	lr, r9, r4
 80a51a4:	f89e e001 	ldrb.w	lr, [lr, #1]
 80a51a8:	f01e 0f04 	tst.w	lr, #4
 80a51ac:	d001      	beq.n	80a51b2 <_strtoul_r+0x7e>
 80a51ae:	3c30      	subs	r4, #48	; 0x30
 80a51b0:	e00b      	b.n	80a51ca <_strtoul_r+0x96>
 80a51b2:	f01e 0e03 	ands.w	lr, lr, #3
 80a51b6:	d01a      	beq.n	80a51ee <_strtoul_r+0xba>
 80a51b8:	f1be 0f01 	cmp.w	lr, #1
 80a51bc:	bf0c      	ite	eq
 80a51be:	f04f 0e37 	moveq.w	lr, #55	; 0x37
 80a51c2:	f04f 0e57 	movne.w	lr, #87	; 0x57
 80a51c6:	ebce 0404 	rsb	r4, lr, r4
 80a51ca:	42a3      	cmp	r3, r4
 80a51cc:	dd0f      	ble.n	80a51ee <_strtoul_r+0xba>
 80a51ce:	2e00      	cmp	r6, #0
 80a51d0:	db08      	blt.n	80a51e4 <_strtoul_r+0xb0>
 80a51d2:	4560      	cmp	r0, ip
 80a51d4:	d806      	bhi.n	80a51e4 <_strtoul_r+0xb0>
 80a51d6:	d101      	bne.n	80a51dc <_strtoul_r+0xa8>
 80a51d8:	4554      	cmp	r4, sl
 80a51da:	dc03      	bgt.n	80a51e4 <_strtoul_r+0xb0>
 80a51dc:	fb03 4000 	mla	r0, r3, r0, r4
 80a51e0:	2601      	movs	r6, #1
 80a51e2:	e001      	b.n	80a51e8 <_strtoul_r+0xb4>
 80a51e4:	f04f 36ff 	mov.w	r6, #4294967295
 80a51e8:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a51ec:	e7d8      	b.n	80a51a0 <_strtoul_r+0x6c>
 80a51ee:	2e00      	cmp	r6, #0
 80a51f0:	da07      	bge.n	80a5202 <_strtoul_r+0xce>
 80a51f2:	2322      	movs	r3, #34	; 0x22
 80a51f4:	f8c8 3000 	str.w	r3, [r8]
 80a51f8:	f04f 30ff 	mov.w	r0, #4294967295
 80a51fc:	b92a      	cbnz	r2, 80a520a <_strtoul_r+0xd6>
 80a51fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a5202:	b107      	cbz	r7, 80a5206 <_strtoul_r+0xd2>
 80a5204:	4240      	negs	r0, r0
 80a5206:	b172      	cbz	r2, 80a5226 <_strtoul_r+0xf2>
 80a5208:	b106      	cbz	r6, 80a520c <_strtoul_r+0xd8>
 80a520a:	1e69      	subs	r1, r5, #1
 80a520c:	6011      	str	r1, [r2, #0]
 80a520e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a5212:	2430      	movs	r4, #48	; 0x30
 80a5214:	2b00      	cmp	r3, #0
 80a5216:	d1b9      	bne.n	80a518c <_strtoul_r+0x58>
 80a5218:	2308      	movs	r3, #8
 80a521a:	e7b7      	b.n	80a518c <_strtoul_r+0x58>
 80a521c:	230a      	movs	r3, #10
 80a521e:	e7b5      	b.n	80a518c <_strtoul_r+0x58>
 80a5220:	2c30      	cmp	r4, #48	; 0x30
 80a5222:	d0ab      	beq.n	80a517c <_strtoul_r+0x48>
 80a5224:	e7b2      	b.n	80a518c <_strtoul_r+0x58>
 80a5226:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a522a:	bf00      	nop
 80a522c:	2000030c 	.word	0x2000030c

080a5230 <strtoul>:
 80a5230:	4613      	mov	r3, r2
 80a5232:	460a      	mov	r2, r1
 80a5234:	4601      	mov	r1, r0
 80a5236:	4802      	ldr	r0, [pc, #8]	; (80a5240 <strtoul+0x10>)
 80a5238:	6800      	ldr	r0, [r0, #0]
 80a523a:	f7ff bf7b 	b.w	80a5134 <_strtoul_r>
 80a523e:	bf00      	nop
 80a5240:	20000370 	.word	0x20000370

080a5244 <__tzcalc_limits>:
 80a5244:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a5248:	4604      	mov	r4, r0
 80a524a:	f000 fa6f 	bl	80a572c <__gettzinfo>
 80a524e:	f240 73b1 	movw	r3, #1969	; 0x7b1
 80a5252:	429c      	cmp	r4, r3
 80a5254:	f340 8096 	ble.w	80a5384 <__tzcalc_limits+0x140>
 80a5258:	f240 156d 	movw	r5, #365	; 0x16d
 80a525c:	f46f 63f6 	mvn.w	r3, #1968	; 0x7b0
 80a5260:	18e3      	adds	r3, r4, r3
 80a5262:	f2a4 72b2 	subw	r2, r4, #1970	; 0x7b2
 80a5266:	109b      	asrs	r3, r3, #2
 80a5268:	fb05 3502 	mla	r5, r5, r2, r3
 80a526c:	f2a4 726d 	subw	r2, r4, #1901	; 0x76d
 80a5270:	f06f 0363 	mvn.w	r3, #99	; 0x63
 80a5274:	fb92 f3f3 	sdiv	r3, r2, r3
 80a5278:	f46f 62c8 	mvn.w	r2, #1600	; 0x640
 80a527c:	442b      	add	r3, r5
 80a527e:	18a5      	adds	r5, r4, r2
 80a5280:	f44f 72c8 	mov.w	r2, #400	; 0x190
 80a5284:	fb94 f7f2 	sdiv	r7, r4, r2
 80a5288:	fb95 f5f2 	sdiv	r5, r5, r2
 80a528c:	fb02 4717 	mls	r7, r2, r7, r4
 80a5290:	441d      	add	r5, r3
 80a5292:	2364      	movs	r3, #100	; 0x64
 80a5294:	fb94 f6f3 	sdiv	r6, r4, r3
 80a5298:	fab7 fe87 	clz	lr, r7
 80a529c:	4601      	mov	r1, r0
 80a529e:	fb03 4616 	mls	r6, r3, r6, r4
 80a52a2:	f100 0338 	add.w	r3, r0, #56	; 0x38
 80a52a6:	9301      	str	r3, [sp, #4]
 80a52a8:	f004 0303 	and.w	r3, r4, #3
 80a52ac:	6044      	str	r4, [r0, #4]
 80a52ae:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 80a52b2:	9300      	str	r3, [sp, #0]
 80a52b4:	f04f 0c07 	mov.w	ip, #7
 80a52b8:	7a0b      	ldrb	r3, [r1, #8]
 80a52ba:	2b4a      	cmp	r3, #74	; 0x4a
 80a52bc:	d10e      	bne.n	80a52dc <__tzcalc_limits+0x98>
 80a52be:	694b      	ldr	r3, [r1, #20]
 80a52c0:	9a00      	ldr	r2, [sp, #0]
 80a52c2:	18ec      	adds	r4, r5, r3
 80a52c4:	b902      	cbnz	r2, 80a52c8 <__tzcalc_limits+0x84>
 80a52c6:	b906      	cbnz	r6, 80a52ca <__tzcalc_limits+0x86>
 80a52c8:	b927      	cbnz	r7, 80a52d4 <__tzcalc_limits+0x90>
 80a52ca:	2b3b      	cmp	r3, #59	; 0x3b
 80a52cc:	bfd4      	ite	le
 80a52ce:	2300      	movle	r3, #0
 80a52d0:	2301      	movgt	r3, #1
 80a52d2:	e000      	b.n	80a52d6 <__tzcalc_limits+0x92>
 80a52d4:	2300      	movs	r3, #0
 80a52d6:	4423      	add	r3, r4
 80a52d8:	3b01      	subs	r3, #1
 80a52da:	e03f      	b.n	80a535c <__tzcalc_limits+0x118>
 80a52dc:	2b44      	cmp	r3, #68	; 0x44
 80a52de:	d102      	bne.n	80a52e6 <__tzcalc_limits+0xa2>
 80a52e0:	694b      	ldr	r3, [r1, #20]
 80a52e2:	442b      	add	r3, r5
 80a52e4:	e03a      	b.n	80a535c <__tzcalc_limits+0x118>
 80a52e6:	9b00      	ldr	r3, [sp, #0]
 80a52e8:	b92b      	cbnz	r3, 80a52f6 <__tzcalc_limits+0xb2>
 80a52ea:	2e00      	cmp	r6, #0
 80a52ec:	bf0c      	ite	eq
 80a52ee:	46f0      	moveq	r8, lr
 80a52f0:	f04f 0801 	movne.w	r8, #1
 80a52f4:	e000      	b.n	80a52f8 <__tzcalc_limits+0xb4>
 80a52f6:	46f0      	mov	r8, lr
 80a52f8:	46a9      	mov	r9, r5
 80a52fa:	4b24      	ldr	r3, [pc, #144]	; (80a538c <__tzcalc_limits+0x148>)
 80a52fc:	2230      	movs	r2, #48	; 0x30
 80a52fe:	fb02 3808 	mla	r8, r2, r8, r3
 80a5302:	68cc      	ldr	r4, [r1, #12]
 80a5304:	f1a8 0a04 	sub.w	sl, r8, #4
 80a5308:	2301      	movs	r3, #1
 80a530a:	42a3      	cmp	r3, r4
 80a530c:	da04      	bge.n	80a5318 <__tzcalc_limits+0xd4>
 80a530e:	f85a bf04 	ldr.w	fp, [sl, #4]!
 80a5312:	3301      	adds	r3, #1
 80a5314:	44d9      	add	r9, fp
 80a5316:	e7f8      	b.n	80a530a <__tzcalc_limits+0xc6>
 80a5318:	f109 0304 	add.w	r3, r9, #4
 80a531c:	fb93 fbfc 	sdiv	fp, r3, ip
 80a5320:	ebcb 0acb 	rsb	sl, fp, fp, lsl #3
 80a5324:	ebca 0a03 	rsb	sl, sl, r3
 80a5328:	694b      	ldr	r3, [r1, #20]
 80a532a:	2c01      	cmp	r4, #1
 80a532c:	bfb8      	it	lt
 80a532e:	2401      	movlt	r4, #1
 80a5330:	ebb3 0a0a 	subs.w	sl, r3, sl
 80a5334:	690b      	ldr	r3, [r1, #16]
 80a5336:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 80a533a:	f103 33ff 	add.w	r3, r3, #4294967295
 80a533e:	f104 34ff 	add.w	r4, r4, #4294967295
 80a5342:	bf48      	it	mi
 80a5344:	f10a 0a07 	addmi.w	sl, sl, #7
 80a5348:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a534c:	f858 4024 	ldr.w	r4, [r8, r4, lsl #2]
 80a5350:	4453      	add	r3, sl
 80a5352:	42a3      	cmp	r3, r4
 80a5354:	db01      	blt.n	80a535a <__tzcalc_limits+0x116>
 80a5356:	3b07      	subs	r3, #7
 80a5358:	e7fb      	b.n	80a5352 <__tzcalc_limits+0x10e>
 80a535a:	444b      	add	r3, r9
 80a535c:	698c      	ldr	r4, [r1, #24]
 80a535e:	4a0c      	ldr	r2, [pc, #48]	; (80a5390 <__tzcalc_limits+0x14c>)
 80a5360:	fb02 4303 	mla	r3, r2, r3, r4
 80a5364:	6a0c      	ldr	r4, [r1, #32]
 80a5366:	4423      	add	r3, r4
 80a5368:	f841 3f1c 	str.w	r3, [r1, #28]!
 80a536c:	9b01      	ldr	r3, [sp, #4]
 80a536e:	4299      	cmp	r1, r3
 80a5370:	d1a2      	bne.n	80a52b8 <__tzcalc_limits+0x74>
 80a5372:	69c3      	ldr	r3, [r0, #28]
 80a5374:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80a5376:	4293      	cmp	r3, r2
 80a5378:	bfac      	ite	ge
 80a537a:	2300      	movge	r3, #0
 80a537c:	2301      	movlt	r3, #1
 80a537e:	6003      	str	r3, [r0, #0]
 80a5380:	2001      	movs	r0, #1
 80a5382:	e000      	b.n	80a5386 <__tzcalc_limits+0x142>
 80a5384:	2000      	movs	r0, #0
 80a5386:	b003      	add	sp, #12
 80a5388:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a538c:	080a5d08 	.word	0x080a5d08
 80a5390:	00015180 	.word	0x00015180

080a5394 <__tz_lock>:
 80a5394:	4770      	bx	lr

080a5396 <__tz_unlock>:
 80a5396:	4770      	bx	lr

080a5398 <_tzset_unlocked>:
 80a5398:	4b01      	ldr	r3, [pc, #4]	; (80a53a0 <_tzset_unlocked+0x8>)
 80a539a:	6818      	ldr	r0, [r3, #0]
 80a539c:	f000 b802 	b.w	80a53a4 <_tzset_unlocked_r>
 80a53a0:	20000370 	.word	0x20000370

080a53a4 <_tzset_unlocked_r>:
 80a53a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a53a8:	b08d      	sub	sp, #52	; 0x34
 80a53aa:	4607      	mov	r7, r0
 80a53ac:	f000 f9be 	bl	80a572c <__gettzinfo>
 80a53b0:	49b0      	ldr	r1, [pc, #704]	; (80a5674 <_tzset_unlocked_r+0x2d0>)
 80a53b2:	4604      	mov	r4, r0
 80a53b4:	4638      	mov	r0, r7
 80a53b6:	f000 f9b1 	bl	80a571c <_getenv_r>
 80a53ba:	4eaf      	ldr	r6, [pc, #700]	; (80a5678 <_tzset_unlocked_r+0x2d4>)
 80a53bc:	4605      	mov	r5, r0
 80a53be:	b960      	cbnz	r0, 80a53da <_tzset_unlocked_r+0x36>
 80a53c0:	4bae      	ldr	r3, [pc, #696]	; (80a567c <_tzset_unlocked_r+0x2d8>)
 80a53c2:	4aaf      	ldr	r2, [pc, #700]	; (80a5680 <_tzset_unlocked_r+0x2dc>)
 80a53c4:	6018      	str	r0, [r3, #0]
 80a53c6:	4baf      	ldr	r3, [pc, #700]	; (80a5684 <_tzset_unlocked_r+0x2e0>)
 80a53c8:	6018      	str	r0, [r3, #0]
 80a53ca:	4baf      	ldr	r3, [pc, #700]	; (80a5688 <_tzset_unlocked_r+0x2e4>)
 80a53cc:	6830      	ldr	r0, [r6, #0]
 80a53ce:	601a      	str	r2, [r3, #0]
 80a53d0:	605a      	str	r2, [r3, #4]
 80a53d2:	f7fe f801 	bl	80a33d8 <free>
 80a53d6:	6035      	str	r5, [r6, #0]
 80a53d8:	e148      	b.n	80a566c <_tzset_unlocked_r+0x2c8>
 80a53da:	6831      	ldr	r1, [r6, #0]
 80a53dc:	b979      	cbnz	r1, 80a53fe <_tzset_unlocked_r+0x5a>
 80a53de:	6830      	ldr	r0, [r6, #0]
 80a53e0:	f7fd fffa 	bl	80a33d8 <free>
 80a53e4:	4628      	mov	r0, r5
 80a53e6:	f7ff fde5 	bl	80a4fb4 <strlen>
 80a53ea:	1c41      	adds	r1, r0, #1
 80a53ec:	4638      	mov	r0, r7
 80a53ee:	f7fe f81b 	bl	80a3428 <_malloc_r>
 80a53f2:	6030      	str	r0, [r6, #0]
 80a53f4:	b148      	cbz	r0, 80a540a <_tzset_unlocked_r+0x66>
 80a53f6:	4629      	mov	r1, r5
 80a53f8:	f7ff fdd4 	bl	80a4fa4 <strcpy>
 80a53fc:	e005      	b.n	80a540a <_tzset_unlocked_r+0x66>
 80a53fe:	f7ff fdc7 	bl	80a4f90 <strcmp>
 80a5402:	2800      	cmp	r0, #0
 80a5404:	f000 8132 	beq.w	80a566c <_tzset_unlocked_r+0x2c8>
 80a5408:	e7e9      	b.n	80a53de <_tzset_unlocked_r+0x3a>
 80a540a:	782b      	ldrb	r3, [r5, #0]
 80a540c:	ae0a      	add	r6, sp, #40	; 0x28
 80a540e:	2b3a      	cmp	r3, #58	; 0x3a
 80a5410:	bf08      	it	eq
 80a5412:	3501      	addeq	r5, #1
 80a5414:	4633      	mov	r3, r6
 80a5416:	4a9d      	ldr	r2, [pc, #628]	; (80a568c <_tzset_unlocked_r+0x2e8>)
 80a5418:	499d      	ldr	r1, [pc, #628]	; (80a5690 <_tzset_unlocked_r+0x2ec>)
 80a541a:	4628      	mov	r0, r5
 80a541c:	f7fd ffec 	bl	80a33f8 <siscanf>
 80a5420:	2800      	cmp	r0, #0
 80a5422:	f340 8123 	ble.w	80a566c <_tzset_unlocked_r+0x2c8>
 80a5426:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a5428:	18ef      	adds	r7, r5, r3
 80a542a:	5ceb      	ldrb	r3, [r5, r3]
 80a542c:	2b2d      	cmp	r3, #45	; 0x2d
 80a542e:	d103      	bne.n	80a5438 <_tzset_unlocked_r+0x94>
 80a5430:	3701      	adds	r7, #1
 80a5432:	f04f 35ff 	mov.w	r5, #4294967295
 80a5436:	e003      	b.n	80a5440 <_tzset_unlocked_r+0x9c>
 80a5438:	2b2b      	cmp	r3, #43	; 0x2b
 80a543a:	bf08      	it	eq
 80a543c:	3701      	addeq	r7, #1
 80a543e:	2501      	movs	r5, #1
 80a5440:	f10d 0a20 	add.w	sl, sp, #32
 80a5444:	f10d 0b1e 	add.w	fp, sp, #30
 80a5448:	f04f 0800 	mov.w	r8, #0
 80a544c:	9603      	str	r6, [sp, #12]
 80a544e:	f8cd a008 	str.w	sl, [sp, #8]
 80a5452:	9601      	str	r6, [sp, #4]
 80a5454:	f8cd b000 	str.w	fp, [sp]
 80a5458:	4633      	mov	r3, r6
 80a545a:	aa07      	add	r2, sp, #28
 80a545c:	498d      	ldr	r1, [pc, #564]	; (80a5694 <_tzset_unlocked_r+0x2f0>)
 80a545e:	4638      	mov	r0, r7
 80a5460:	f8ad 801e 	strh.w	r8, [sp, #30]
 80a5464:	f8ad 8020 	strh.w	r8, [sp, #32]
 80a5468:	f7fd ffc6 	bl	80a33f8 <siscanf>
 80a546c:	4540      	cmp	r0, r8
 80a546e:	f340 80fd 	ble.w	80a566c <_tzset_unlocked_r+0x2c8>
 80a5472:	f8bd 201e 	ldrh.w	r2, [sp, #30]
 80a5476:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 80a547a:	213c      	movs	r1, #60	; 0x3c
 80a547c:	fb01 3302 	mla	r3, r1, r2, r3
 80a5480:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 80a5484:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80a5488:	fb01 3302 	mla	r3, r1, r2, r3
 80a548c:	435d      	muls	r5, r3
 80a548e:	4b7f      	ldr	r3, [pc, #508]	; (80a568c <_tzset_unlocked_r+0x2e8>)
 80a5490:	6225      	str	r5, [r4, #32]
 80a5492:	4d7d      	ldr	r5, [pc, #500]	; (80a5688 <_tzset_unlocked_r+0x2e4>)
 80a5494:	f8df 9208 	ldr.w	r9, [pc, #520]	; 80a56a0 <_tzset_unlocked_r+0x2fc>
 80a5498:	602b      	str	r3, [r5, #0]
 80a549a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a549c:	464a      	mov	r2, r9
 80a549e:	441f      	add	r7, r3
 80a54a0:	497b      	ldr	r1, [pc, #492]	; (80a5690 <_tzset_unlocked_r+0x2ec>)
 80a54a2:	4633      	mov	r3, r6
 80a54a4:	4638      	mov	r0, r7
 80a54a6:	f7fd ffa7 	bl	80a33f8 <siscanf>
 80a54aa:	4540      	cmp	r0, r8
 80a54ac:	dc08      	bgt.n	80a54c0 <_tzset_unlocked_r+0x11c>
 80a54ae:	682b      	ldr	r3, [r5, #0]
 80a54b0:	6a22      	ldr	r2, [r4, #32]
 80a54b2:	606b      	str	r3, [r5, #4]
 80a54b4:	4b71      	ldr	r3, [pc, #452]	; (80a567c <_tzset_unlocked_r+0x2d8>)
 80a54b6:	601a      	str	r2, [r3, #0]
 80a54b8:	4b72      	ldr	r3, [pc, #456]	; (80a5684 <_tzset_unlocked_r+0x2e0>)
 80a54ba:	f8c3 8000 	str.w	r8, [r3]
 80a54be:	e0d5      	b.n	80a566c <_tzset_unlocked_r+0x2c8>
 80a54c0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a54c2:	f8c5 9004 	str.w	r9, [r5, #4]
 80a54c6:	18fd      	adds	r5, r7, r3
 80a54c8:	5cfb      	ldrb	r3, [r7, r3]
 80a54ca:	2b2d      	cmp	r3, #45	; 0x2d
 80a54cc:	d103      	bne.n	80a54d6 <_tzset_unlocked_r+0x132>
 80a54ce:	3501      	adds	r5, #1
 80a54d0:	f04f 37ff 	mov.w	r7, #4294967295
 80a54d4:	e003      	b.n	80a54de <_tzset_unlocked_r+0x13a>
 80a54d6:	2b2b      	cmp	r3, #43	; 0x2b
 80a54d8:	bf08      	it	eq
 80a54da:	3501      	addeq	r5, #1
 80a54dc:	2701      	movs	r7, #1
 80a54de:	2300      	movs	r3, #0
 80a54e0:	f8ad 301c 	strh.w	r3, [sp, #28]
 80a54e4:	f8ad 301e 	strh.w	r3, [sp, #30]
 80a54e8:	f8ad 3020 	strh.w	r3, [sp, #32]
 80a54ec:	930a      	str	r3, [sp, #40]	; 0x28
 80a54ee:	9603      	str	r6, [sp, #12]
 80a54f0:	f8cd a008 	str.w	sl, [sp, #8]
 80a54f4:	9601      	str	r6, [sp, #4]
 80a54f6:	f8cd b000 	str.w	fp, [sp]
 80a54fa:	4633      	mov	r3, r6
 80a54fc:	aa07      	add	r2, sp, #28
 80a54fe:	4965      	ldr	r1, [pc, #404]	; (80a5694 <_tzset_unlocked_r+0x2f0>)
 80a5500:	4628      	mov	r0, r5
 80a5502:	f7fd ff79 	bl	80a33f8 <siscanf>
 80a5506:	2800      	cmp	r0, #0
 80a5508:	dc04      	bgt.n	80a5514 <_tzset_unlocked_r+0x170>
 80a550a:	6a23      	ldr	r3, [r4, #32]
 80a550c:	f5a3 6361 	sub.w	r3, r3, #3600	; 0xe10
 80a5510:	63e3      	str	r3, [r4, #60]	; 0x3c
 80a5512:	e00e      	b.n	80a5532 <_tzset_unlocked_r+0x18e>
 80a5514:	f8bd 201e 	ldrh.w	r2, [sp, #30]
 80a5518:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 80a551c:	213c      	movs	r1, #60	; 0x3c
 80a551e:	fb01 3302 	mla	r3, r1, r2, r3
 80a5522:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 80a5526:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80a552a:	fb01 3302 	mla	r3, r1, r2, r3
 80a552e:	435f      	muls	r7, r3
 80a5530:	63e7      	str	r7, [r4, #60]	; 0x3c
 80a5532:	4627      	mov	r7, r4
 80a5534:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a5536:	f04f 0900 	mov.w	r9, #0
 80a553a:	441d      	add	r5, r3
 80a553c:	782b      	ldrb	r3, [r5, #0]
 80a553e:	2b2c      	cmp	r3, #44	; 0x2c
 80a5540:	bf08      	it	eq
 80a5542:	3501      	addeq	r5, #1
 80a5544:	f895 8000 	ldrb.w	r8, [r5]
 80a5548:	f1b8 0f4d 	cmp.w	r8, #77	; 0x4d
 80a554c:	d126      	bne.n	80a559c <_tzset_unlocked_r+0x1f8>
 80a554e:	f10d 0326 	add.w	r3, sp, #38	; 0x26
 80a5552:	9302      	str	r3, [sp, #8]
 80a5554:	ab09      	add	r3, sp, #36	; 0x24
 80a5556:	9300      	str	r3, [sp, #0]
 80a5558:	9603      	str	r6, [sp, #12]
 80a555a:	9601      	str	r6, [sp, #4]
 80a555c:	4633      	mov	r3, r6
 80a555e:	f10d 0222 	add.w	r2, sp, #34	; 0x22
 80a5562:	494d      	ldr	r1, [pc, #308]	; (80a5698 <_tzset_unlocked_r+0x2f4>)
 80a5564:	4628      	mov	r0, r5
 80a5566:	f7fd ff47 	bl	80a33f8 <siscanf>
 80a556a:	2803      	cmp	r0, #3
 80a556c:	d17e      	bne.n	80a566c <_tzset_unlocked_r+0x2c8>
 80a556e:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
 80a5572:	1e4b      	subs	r3, r1, #1
 80a5574:	2b0b      	cmp	r3, #11
 80a5576:	d879      	bhi.n	80a566c <_tzset_unlocked_r+0x2c8>
 80a5578:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
 80a557c:	1e53      	subs	r3, r2, #1
 80a557e:	2b04      	cmp	r3, #4
 80a5580:	d874      	bhi.n	80a566c <_tzset_unlocked_r+0x2c8>
 80a5582:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
 80a5586:	2b06      	cmp	r3, #6
 80a5588:	d870      	bhi.n	80a566c <_tzset_unlocked_r+0x2c8>
 80a558a:	f887 8008 	strb.w	r8, [r7, #8]
 80a558e:	60f9      	str	r1, [r7, #12]
 80a5590:	613a      	str	r2, [r7, #16]
 80a5592:	617b      	str	r3, [r7, #20]
 80a5594:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a5596:	eb05 0803 	add.w	r8, r5, r3
 80a559a:	e02a      	b.n	80a55f2 <_tzset_unlocked_r+0x24e>
 80a559c:	f1b8 0f4a 	cmp.w	r8, #74	; 0x4a
 80a55a0:	bf06      	itte	eq
 80a55a2:	4643      	moveq	r3, r8
 80a55a4:	3501      	addeq	r5, #1
 80a55a6:	2344      	movne	r3, #68	; 0x44
 80a55a8:	220a      	movs	r2, #10
 80a55aa:	a90b      	add	r1, sp, #44	; 0x2c
 80a55ac:	4628      	mov	r0, r5
 80a55ae:	9305      	str	r3, [sp, #20]
 80a55b0:	f7ff fe3e 	bl	80a5230 <strtoul>
 80a55b4:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 80a55b8:	f8ad 0026 	strh.w	r0, [sp, #38]	; 0x26
 80a55bc:	4545      	cmp	r5, r8
 80a55be:	9b05      	ldr	r3, [sp, #20]
 80a55c0:	d114      	bne.n	80a55ec <_tzset_unlocked_r+0x248>
 80a55c2:	234d      	movs	r3, #77	; 0x4d
 80a55c4:	f1b9 0f00 	cmp.w	r9, #0
 80a55c8:	d107      	bne.n	80a55da <_tzset_unlocked_r+0x236>
 80a55ca:	7223      	strb	r3, [r4, #8]
 80a55cc:	2303      	movs	r3, #3
 80a55ce:	60e3      	str	r3, [r4, #12]
 80a55d0:	2302      	movs	r3, #2
 80a55d2:	6123      	str	r3, [r4, #16]
 80a55d4:	f8c4 9014 	str.w	r9, [r4, #20]
 80a55d8:	e00b      	b.n	80a55f2 <_tzset_unlocked_r+0x24e>
 80a55da:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
 80a55de:	230b      	movs	r3, #11
 80a55e0:	62a3      	str	r3, [r4, #40]	; 0x28
 80a55e2:	2301      	movs	r3, #1
 80a55e4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80a55e6:	2300      	movs	r3, #0
 80a55e8:	6323      	str	r3, [r4, #48]	; 0x30
 80a55ea:	e002      	b.n	80a55f2 <_tzset_unlocked_r+0x24e>
 80a55ec:	b280      	uxth	r0, r0
 80a55ee:	723b      	strb	r3, [r7, #8]
 80a55f0:	6178      	str	r0, [r7, #20]
 80a55f2:	2302      	movs	r3, #2
 80a55f4:	f8ad 301c 	strh.w	r3, [sp, #28]
 80a55f8:	2300      	movs	r3, #0
 80a55fa:	f8ad 301e 	strh.w	r3, [sp, #30]
 80a55fe:	f8ad 3020 	strh.w	r3, [sp, #32]
 80a5602:	930a      	str	r3, [sp, #40]	; 0x28
 80a5604:	f898 3000 	ldrb.w	r3, [r8]
 80a5608:	2b2f      	cmp	r3, #47	; 0x2f
 80a560a:	d10b      	bne.n	80a5624 <_tzset_unlocked_r+0x280>
 80a560c:	9603      	str	r6, [sp, #12]
 80a560e:	f8cd a008 	str.w	sl, [sp, #8]
 80a5612:	9601      	str	r6, [sp, #4]
 80a5614:	f8cd b000 	str.w	fp, [sp]
 80a5618:	4633      	mov	r3, r6
 80a561a:	aa07      	add	r2, sp, #28
 80a561c:	491f      	ldr	r1, [pc, #124]	; (80a569c <_tzset_unlocked_r+0x2f8>)
 80a561e:	4640      	mov	r0, r8
 80a5620:	f7fd feea 	bl	80a33f8 <siscanf>
 80a5624:	f8bd 201e 	ldrh.w	r2, [sp, #30]
 80a5628:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 80a562c:	213c      	movs	r1, #60	; 0x3c
 80a562e:	fb01 3302 	mla	r3, r1, r2, r3
 80a5632:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 80a5636:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80a563a:	fb01 3302 	mla	r3, r1, r2, r3
 80a563e:	61bb      	str	r3, [r7, #24]
 80a5640:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80a5642:	f109 0901 	add.w	r9, r9, #1
 80a5646:	f1b9 0f02 	cmp.w	r9, #2
 80a564a:	4445      	add	r5, r8
 80a564c:	f107 071c 	add.w	r7, r7, #28
 80a5650:	f47f af74 	bne.w	80a553c <_tzset_unlocked_r+0x198>
 80a5654:	6860      	ldr	r0, [r4, #4]
 80a5656:	f7ff fdf5 	bl	80a5244 <__tzcalc_limits>
 80a565a:	6a22      	ldr	r2, [r4, #32]
 80a565c:	4b07      	ldr	r3, [pc, #28]	; (80a567c <_tzset_unlocked_r+0x2d8>)
 80a565e:	601a      	str	r2, [r3, #0]
 80a5660:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80a5662:	1a9b      	subs	r3, r3, r2
 80a5664:	4a07      	ldr	r2, [pc, #28]	; (80a5684 <_tzset_unlocked_r+0x2e0>)
 80a5666:	bf18      	it	ne
 80a5668:	2301      	movne	r3, #1
 80a566a:	6013      	str	r3, [r2, #0]
 80a566c:	b00d      	add	sp, #52	; 0x34
 80a566e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a5672:	bf00      	nop
 80a5674:	080a5d68 	.word	0x080a5d68
 80a5678:	200010e4 	.word	0x200010e4
 80a567c:	200010ec 	.word	0x200010ec
 80a5680:	080a5d6b 	.word	0x080a5d6b
 80a5684:	200010e8 	.word	0x200010e8
 80a5688:	20000374 	.word	0x20000374
 80a568c:	200010d7 	.word	0x200010d7
 80a5690:	080a5d6f 	.word	0x080a5d6f
 80a5694:	080a5d92 	.word	0x080a5d92
 80a5698:	080a5d7e 	.word	0x080a5d7e
 80a569c:	080a5d91 	.word	0x080a5d91
 80a56a0:	200010cc 	.word	0x200010cc

080a56a4 <_findenv_r>:
 80a56a4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a56a8:	4607      	mov	r7, r0
 80a56aa:	468b      	mov	fp, r1
 80a56ac:	4690      	mov	r8, r2
 80a56ae:	f000 f8d7 	bl	80a5860 <__env_lock>
 80a56b2:	4b19      	ldr	r3, [pc, #100]	; (80a5718 <_findenv_r+0x74>)
 80a56b4:	681d      	ldr	r5, [r3, #0]
 80a56b6:	469a      	mov	sl, r3
 80a56b8:	b13d      	cbz	r5, 80a56ca <_findenv_r+0x26>
 80a56ba:	465c      	mov	r4, fp
 80a56bc:	4623      	mov	r3, r4
 80a56be:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a56c2:	b142      	cbz	r2, 80a56d6 <_findenv_r+0x32>
 80a56c4:	2a3d      	cmp	r2, #61	; 0x3d
 80a56c6:	461c      	mov	r4, r3
 80a56c8:	d1f8      	bne.n	80a56bc <_findenv_r+0x18>
 80a56ca:	4638      	mov	r0, r7
 80a56cc:	f000 f8c9 	bl	80a5862 <__env_unlock>
 80a56d0:	2000      	movs	r0, #0
 80a56d2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a56d6:	ebcb 0404 	rsb	r4, fp, r4
 80a56da:	46a9      	mov	r9, r5
 80a56dc:	f859 0b04 	ldr.w	r0, [r9], #4
 80a56e0:	2800      	cmp	r0, #0
 80a56e2:	d0f2      	beq.n	80a56ca <_findenv_r+0x26>
 80a56e4:	4622      	mov	r2, r4
 80a56e6:	4659      	mov	r1, fp
 80a56e8:	f7ff fc6c 	bl	80a4fc4 <strncmp>
 80a56ec:	b988      	cbnz	r0, 80a5712 <_findenv_r+0x6e>
 80a56ee:	f859 3c04 	ldr.w	r3, [r9, #-4]
 80a56f2:	191e      	adds	r6, r3, r4
 80a56f4:	5d1b      	ldrb	r3, [r3, r4]
 80a56f6:	2b3d      	cmp	r3, #61	; 0x3d
 80a56f8:	d10b      	bne.n	80a5712 <_findenv_r+0x6e>
 80a56fa:	f8da 3000 	ldr.w	r3, [sl]
 80a56fe:	4638      	mov	r0, r7
 80a5700:	1aed      	subs	r5, r5, r3
 80a5702:	10ad      	asrs	r5, r5, #2
 80a5704:	f8c8 5000 	str.w	r5, [r8]
 80a5708:	f000 f8ab 	bl	80a5862 <__env_unlock>
 80a570c:	1c70      	adds	r0, r6, #1
 80a570e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a5712:	464d      	mov	r5, r9
 80a5714:	e7e1      	b.n	80a56da <_findenv_r+0x36>
 80a5716:	bf00      	nop
 80a5718:	200003bc 	.word	0x200003bc

080a571c <_getenv_r>:
 80a571c:	b507      	push	{r0, r1, r2, lr}
 80a571e:	aa01      	add	r2, sp, #4
 80a5720:	f7ff ffc0 	bl	80a56a4 <_findenv_r>
 80a5724:	b003      	add	sp, #12
 80a5726:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a572c <__gettzinfo>:
 80a572c:	4800      	ldr	r0, [pc, #0]	; (80a5730 <__gettzinfo+0x4>)
 80a572e:	4770      	bx	lr
 80a5730:	2000037c 	.word	0x2000037c

080a5734 <gmtime_r>:
 80a5734:	6802      	ldr	r2, [r0, #0]
 80a5736:	4b46      	ldr	r3, [pc, #280]	; (80a5850 <gmtime_r+0x11c>)
 80a5738:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a573a:	fb92 f4f3 	sdiv	r4, r2, r3
 80a573e:	fb03 2214 	mls	r2, r3, r4, r2
 80a5742:	2a00      	cmp	r2, #0
 80a5744:	bfbc      	itt	lt
 80a5746:	f502 32a8 	addlt.w	r2, r2, #86016	; 0x15000
 80a574a:	f502 72c0 	addlt.w	r2, r2, #384	; 0x180
 80a574e:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 80a5752:	fb92 f3f0 	sdiv	r3, r2, r0
 80a5756:	fb00 2213 	mls	r2, r0, r3, r2
 80a575a:	f04f 003c 	mov.w	r0, #60	; 0x3c
 80a575e:	608b      	str	r3, [r1, #8]
 80a5760:	fb92 f3f0 	sdiv	r3, r2, r0
 80a5764:	fb00 2213 	mls	r2, r0, r3, r2
 80a5768:	f504 242f 	add.w	r4, r4, #716800	; 0xaf000
 80a576c:	bfac      	ite	ge
 80a576e:	f604 246c 	addwge	r4, r4, #2668	; 0xa6c
 80a5772:	f604 246b 	addwlt	r4, r4, #2667	; 0xa6b
 80a5776:	604b      	str	r3, [r1, #4]
 80a5778:	600a      	str	r2, [r1, #0]
 80a577a:	2307      	movs	r3, #7
 80a577c:	1ce2      	adds	r2, r4, #3
 80a577e:	fb92 f3f3 	sdiv	r3, r2, r3
 80a5782:	4d34      	ldr	r5, [pc, #208]	; (80a5854 <gmtime_r+0x120>)
 80a5784:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a5788:	fb94 f5f5 	sdiv	r5, r4, r5
 80a578c:	1ad3      	subs	r3, r2, r3
 80a578e:	f648 62ac 	movw	r2, #36524	; 0x8eac
 80a5792:	f240 57b4 	movw	r7, #1460	; 0x5b4
 80a5796:	618b      	str	r3, [r1, #24]
 80a5798:	4b2f      	ldr	r3, [pc, #188]	; (80a5858 <gmtime_r+0x124>)
 80a579a:	4830      	ldr	r0, [pc, #192]	; (80a585c <gmtime_r+0x128>)
 80a579c:	fb03 4405 	mla	r4, r3, r5, r4
 80a57a0:	fbb4 f2f2 	udiv	r2, r4, r2
 80a57a4:	fbb4 f3f7 	udiv	r3, r4, r7
 80a57a8:	fbb4 f0f0 	udiv	r0, r4, r0
 80a57ac:	4422      	add	r2, r4
 80a57ae:	1ad2      	subs	r2, r2, r3
 80a57b0:	f648 6694 	movw	r6, #36500	; 0x8e94
 80a57b4:	1a13      	subs	r3, r2, r0
 80a57b6:	f240 126d 	movw	r2, #365	; 0x16d
 80a57ba:	fbb3 f6f6 	udiv	r6, r3, r6
 80a57be:	fbb3 f0f2 	udiv	r0, r3, r2
 80a57c2:	fbb3 f3f7 	udiv	r3, r3, r7
 80a57c6:	4434      	add	r4, r6
 80a57c8:	1ae3      	subs	r3, r4, r3
 80a57ca:	fb02 3310 	mls	r3, r2, r0, r3
 80a57ce:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80a57d2:	2499      	movs	r4, #153	; 0x99
 80a57d4:	3202      	adds	r2, #2
 80a57d6:	fbb2 f2f4 	udiv	r2, r2, r4
 80a57da:	4354      	muls	r4, r2
 80a57dc:	1ca6      	adds	r6, r4, #2
 80a57de:	2405      	movs	r4, #5
 80a57e0:	fbb6 f4f4 	udiv	r4, r6, r4
 80a57e4:	2a0a      	cmp	r2, #10
 80a57e6:	bf34      	ite	cc
 80a57e8:	2602      	movcc	r6, #2
 80a57ea:	f06f 0609 	mvncs.w	r6, #9
 80a57ee:	4416      	add	r6, r2
 80a57f0:	f44f 72c8 	mov.w	r2, #400	; 0x190
 80a57f4:	fb02 0505 	mla	r5, r2, r5, r0
 80a57f8:	1c5f      	adds	r7, r3, #1
 80a57fa:	2e01      	cmp	r6, #1
 80a57fc:	bf98      	it	ls
 80a57fe:	3501      	addls	r5, #1
 80a5800:	f5b3 7f99 	cmp.w	r3, #306	; 0x132
 80a5804:	eba7 0704 	sub.w	r7, r7, r4
 80a5808:	d302      	bcc.n	80a5810 <gmtime_r+0xdc>
 80a580a:	f5a3 7299 	sub.w	r2, r3, #306	; 0x132
 80a580e:	e014      	b.n	80a583a <gmtime_r+0x106>
 80a5810:	0782      	lsls	r2, r0, #30
 80a5812:	d105      	bne.n	80a5820 <gmtime_r+0xec>
 80a5814:	2464      	movs	r4, #100	; 0x64
 80a5816:	fbb0 f2f4 	udiv	r2, r0, r4
 80a581a:	fb04 0212 	mls	r2, r4, r2, r0
 80a581e:	b94a      	cbnz	r2, 80a5834 <gmtime_r+0x100>
 80a5820:	f44f 72c8 	mov.w	r2, #400	; 0x190
 80a5824:	fbb0 f4f2 	udiv	r4, r0, r2
 80a5828:	fb02 0014 	mls	r0, r2, r4, r0
 80a582c:	fab0 f280 	clz	r2, r0
 80a5830:	0952      	lsrs	r2, r2, #5
 80a5832:	e000      	b.n	80a5836 <gmtime_r+0x102>
 80a5834:	2201      	movs	r2, #1
 80a5836:	333b      	adds	r3, #59	; 0x3b
 80a5838:	441a      	add	r2, r3
 80a583a:	f2a5 756c 	subw	r5, r5, #1900	; 0x76c
 80a583e:	2300      	movs	r3, #0
 80a5840:	61ca      	str	r2, [r1, #28]
 80a5842:	614d      	str	r5, [r1, #20]
 80a5844:	610e      	str	r6, [r1, #16]
 80a5846:	60cf      	str	r7, [r1, #12]
 80a5848:	620b      	str	r3, [r1, #32]
 80a584a:	4608      	mov	r0, r1
 80a584c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a584e:	bf00      	nop
 80a5850:	00015180 	.word	0x00015180
 80a5854:	00023ab1 	.word	0x00023ab1
 80a5858:	fffdc54f 	.word	0xfffdc54f
 80a585c:	00023ab0 	.word	0x00023ab0

080a5860 <__env_lock>:
 80a5860:	4770      	bx	lr

080a5862 <__env_unlock>:
 80a5862:	4770      	bx	lr

080a5864 <dynalib_user>:
 80a5864:	001d 080a 005d 080a 0089 080a 008d 080a     ....]...........
 80a5874:	0000 0000                                   ....

080a5878 <_ZTVN8particle13__SPISettingsE>:
	...
 80a5880:	07c9 080a                                   ....

080a5884 <_ZTV6SdFile>:
	...
 80a588c:	0771 080a 0821 080a 0833 080a 082d 080a     q...!...3...-...
 80a589c:	6564 6166 6c75 2074 4d00 4253 4c00 4253     default .MSB.LSB
 80a58ac:	3c00 5053 5349 7465 6974 676e 2073 6564     .<SPISettings de
 80a58bc:	6166 6c75 3e74 3c00 5053 5349 7465 6974     fault>.<SPISetti
 80a58cc:	676e 2073 7325 6c25 2075 7325 4d20 444f     ngs %s%lu %s MOD
 80a58dc:	2545 3e64 4500 5f4c 4f4c 4441 465f 4152     E%d>.EL_LOAD_FRA
 80a58ec:	454d 2e53 7363 0076 4223 534d 2c00 4300     MES.csv.#BMS.,.C
 80a58fc:	4e4f 4946 2e47 7874 0074 0000               ONFIG.txt...

080a5908 <_ZL12scawSDtimers>:
 80a5908:	03e8 0000 003c 0000 03e8 0000               ....<.......

080a5914 <_ZL17scawGatewayTimers>:
 80a5914:	07d0 0000 2328 0000 00c8 0000 07d0 0000     ....(#..........
 80a5924:	1f40 0000 1770 0000 0fa0 0000               @...p.......

080a5930 <_ZL16scawElLoadTimers>:
 80a5930:	00c8 0000 0000 0000 7973 7473 723a 6d65     ........syst:rem
 80a5940:	2a00 6c63 0073 4e49 2050 464f 0046 5546     .*cls.INP OFF.FU
 80a5950:	434e 4d3a 444f 2045 4946 0058 494c 5453     NC:MODE FIX.LIST
 80a5960:	523a 4c43 3220 4600 4e55 3a43 4f4d 4544     :RCL 2.FUNC:MODE
 80a5970:	4c20 5349 0054 4e49 2050 4e4f 2a00 5254      LIST.INP ON.*TR
 80a5980:	0047 5546 434e 5020 574f 5000 574f 2520     G.FUNC POW.POW %
 80a5990:	0a64 6700 7370 735f 7265 6169 006c 5047     d..gps_serial.GP
 80a59a0:	4d52 0043 4e47 4d52 0043 5047 4747 0041     RMC.GNRMC.GPGGA.
 80a59b0:	4e47 4747 0041 4e4e 0045 4e45 0045 5345     GNGGA.NNE.ENE.ES
 80a59c0:	0045 5353 0045 5353 0057 5357 0057 4e57     E.SSE.SSW.WSW.WN
 80a59d0:	0057 4e4e 0057 0000                         W.NNW...

080a59d8 <_ZTV8SPIClass>:
	...
 80a59e0:	3439 080a 343b 080a                         94..;4..

080a59e8 <_ZL14clock_divisors>:
 80a59e8:	0800 1810 2820 3830 0066 6e6c 6600 006e     .... (08f.ln.fn.
 80a59f8:	6f63 6564 6400 7465 6961 006c 0a0d 2500     code.detail....%
 80a5a08:	3130 7530 0020 205d 2500 0064 202c 2800     010u .] .%d., .(
 80a5a18:	3a29 0020 5b20 6300 646f 2065 203d 2500     ): . [.code = .%
 80a5a28:	0069 6564 6174 6c69 2073 203d 6200 7561     i.details = .bau
 80a5a38:	0064 6553 6972 6c61 5500 4253 6553 6972     d.Serial.USBSeri
 80a5a48:	6c61 0031 7974 6570 7000 7261 6d61 6300     al1.type.param.c
 80a5a58:	646d 6900 0064 6e68 0064 7473 6d72 6600     md.id.hnd.strm.f
 80a5a68:	6c69 0074 766c 006c 6461 4864 6e61 6c64     ilt.lvl.addHandl
 80a5a78:	7265 7200 6d65 766f 4865 6e61 6c64 7265     er.removeHandler
 80a5a88:	6500 756e 486d 6e61 6c64 7265 0073 534a     .enumHandlers.JS
 80a5a98:	4e4f 7453 6572 6d61 6f4c 4867 6e61 6c64     ONStreamLogHandl
 80a5aa8:	7265 6100 7070 6e00 6e6f 0065 7274 6361     er.app.none.trac
 80a5ab8:	0065 6e69 6f66 7700 7261 006e 7265 6f72     e.info.warn.erro
 80a5ac8:	0072 6170 696e 0063 6c61 006c 2b25 3330     r.panic.all.%+03
 80a5ad8:	3a64 3025 7532 2500 2d59 6d25 252d 5464     d:%02u.%Y-%m-%dT
 80a5ae8:	4825 253a 3a4d 5325 7a25 6100 6373 6974     %H:%M:%S%z.ascti
 80a5af8:	656d 0000                                   me..

080a5afc <_ZTV9IPAddress>:
	...
 80a5b04:	3b33 080a 3b25 080a 3b27 080a               3;..%;..';..

080a5b10 <_ZTV9USBSerial>:
	...
 80a5b18:	3b9d 080a 3be1 080a 3bbb 080a 370f 080a     .;...;...;...7..
 80a5b28:	3bb5 080a 3b9f 080a 3ba7 080a 3bdb 080a     .;...;...;...;..
 80a5b38:	3baf 080a 3b99 080a                         .;...;..

080a5b40 <_ZTV11USARTSerial>:
	...
 80a5b48:	3d89 080a 3dad 080a 3db9 080a 370f 080a     .=...=...=...7..
 80a5b58:	3d95 080a 3da1 080a 3d9b 080a 3da7 080a     .=...=...=...=..
 80a5b68:	3d8b 080a 3d8f 080a                         .=...=..

080a5b70 <_ZTV7TwoWire>:
	...
 80a5b78:	3e69 080a 3eb3 080a 3e8b 080a 3e6b 080a     i>...>...>..k>..
 80a5b88:	3e93 080a 3e9b 080a 3ea3 080a 3eab 080a     .>...>...>...>..

080a5b98 <_ZTVN5spark9WiFiClassE>:
	...
 80a5ba0:	3f15 080a                                   .?..

080a5ba4 <_ZSt7nothrow>:
	...

080a5ba5 <_ctype_>:
 80a5ba5:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
 80a5bb5:	2020 2020 2020 2020 2020 2020 2020 2020                     
 80a5bc5:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
 80a5bd5:	0410 0404 0404 0404 0404 1004 1010 1010     ................
 80a5be5:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
 80a5bf5:	0101 0101 0101 0101 0101 0101 1010 1010     ................
 80a5c05:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
 80a5c15:	0202 0202 0202 0202 0202 0202 1010 1010     ................
 80a5c25:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...

080a5ca8 <__sf_fake_stdin>:
	...

080a5cc8 <__sf_fake_stdout>:
	...

080a5ce8 <__sf_fake_stderr>:
	...

080a5d08 <__month_lengths>:
 80a5d08:	001f 0000 001c 0000 001f 0000 001e 0000     ................
 80a5d18:	001f 0000 001e 0000 001f 0000 001f 0000     ................
 80a5d28:	001e 0000 001f 0000 001e 0000 001f 0000     ................
 80a5d38:	001f 0000 001d 0000 001f 0000 001e 0000     ................
 80a5d48:	001f 0000 001e 0000 001f 0000 001f 0000     ................
 80a5d58:	001e 0000 001f 0000 001e 0000 001f 0000     ................
 80a5d68:	5a54 4700 544d 2500 3031 5e5b 2d30 2c39     TZ.GMT.%10[^0-9,
 80a5d78:	2d2b 255d 006e 254d 7568 6e25 252e 7568     +-]%n.M%hu%n.%hu
 80a5d88:	6e25 252e 7568 6e25 2f00 6825 2575 3a6e     %n.%hu%n./%hu%n:
 80a5d98:	6825 2575 3a6e 6825 2575 006e               %hu%n:%hu%n.

080a5da4 <link_const_variable_data_end>:
 80a5da4:	080a03dd 	.word	0x080a03dd
 80a5da8:	080a0701 	.word	0x080a0701
 80a5dac:	080a0a15 	.word	0x080a0a15
 80a5db0:	080a0bab 	.word	0x080a0bab
 80a5db4:	080a0bf9 	.word	0x080a0bf9
 80a5db8:	080a0c61 	.word	0x080a0c61
 80a5dbc:	080a0c95 	.word	0x080a0c95
 80a5dc0:	080a0cbd 	.word	0x080a0cbd
 80a5dc4:	080a0d29 	.word	0x080a0d29
 80a5dc8:	080a0d8b 	.word	0x080a0d8b
 80a5dcc:	080a104b 	.word	0x080a104b
 80a5dd0:	080a15f1 	.word	0x080a15f1
 80a5dd4:	080a15f5 	.word	0x080a15f5
 80a5dd8:	080a15f9 	.word	0x080a15f9
 80a5ddc:	080a1c21 	.word	0x080a1c21
 80a5de0:	080a1c25 	.word	0x080a1c25
 80a5de4:	080a1c29 	.word	0x080a1c29
 80a5de8:	080a1c2d 	.word	0x080a1c2d
 80a5dec:	080a233d 	.word	0x080a233d
 80a5df0:	080a2361 	.word	0x080a2361
 80a5df4:	080a2365 	.word	0x080a2365
 80a5df8:	080a2689 	.word	0x080a2689
 80a5dfc:	080a268d 	.word	0x080a268d
 80a5e00:	080a2691 	.word	0x080a2691
 80a5e04:	080a2bcb 	.word	0x080a2bcb
 80a5e08:	080a2bcf 	.word	0x080a2bcf
 80a5e0c:	080a2bd3 	.word	0x080a2bd3
 80a5e10:	080a2c79 	.word	0x080a2c79
 80a5e14:	080a2f77 	.word	0x080a2f77
 80a5e18:	080a35c5 	.word	0x080a35c5
 80a5e1c:	080a3841 	.word	0x080a3841
 80a5e20:	080a39a9 	.word	0x080a39a9
 80a5e24:	080a39d1 	.word	0x080a39d1
 80a5e28:	080a3f21 	.word	0x080a3f21
 80a5e2c:	080a400d 	.word	0x080a400d
 80a5e30:	080a4051 	.word	0x080a4051
 80a5e34:	080a4101 	.word	0x080a4101
 80a5e38:	080a4185 	.word	0x080a4185
 80a5e3c:	080a4249 	.word	0x080a4249
 80a5e40:	080a430d 	.word	0x080a430d

080a5e44 <link_constructors_end>:
	...
